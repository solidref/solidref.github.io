<!DOCTYPE html>
<html lang="en-us" dir="ltr">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="description" content="
  Liskov Substitution Principle (LSP)
  #

The Liskov Substitution Principle (LSP) is the third principle in the SOLID principles of object-oriented design. It states:
“Objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of the program.”
In other words, if class B is a subclass of class A, then instances of A should be replaceable by instances of B without altering the program&rsquo;s behavior. LSP ensures that a derived class can stand in for its base class without breaking functionality, making inheritance more predictable and reliable.">
<meta name="theme-color" media="(prefers-color-scheme: light)" content="#ffffff">
<meta name="theme-color" media="(prefers-color-scheme: dark)" content="#343a40">
<meta name="color-scheme" content="light dark"><meta property="og:url" content="http://localhost:1313/docs/coding-principles/solid/liskov-substitution/">
  <meta property="og:site_name" content="SOLID.ref">
  <meta property="og:title" content="Liskov Substitution Principle (LSP)">
  <meta property="og:description" content="Liskov Substitution Principle (LSP) # The Liskov Substitution Principle (LSP) is the third principle in the SOLID principles of object-oriented design. It states:
“Objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of the program.”
In other words, if class B is a subclass of class A, then instances of A should be replaceable by instances of B without altering the program’s behavior. LSP ensures that a derived class can stand in for its base class without breaking functionality, making inheritance more predictable and reliable.">
  <meta property="og:locale" content="en_us">
  <meta property="og:type" content="article">
    <meta property="article:section" content="docs">
<title>Liskov Substitution Principle (LSP) | SOLID.ref</title>
<link rel="icon" href="/favicon.png" >
<link rel="manifest" href="/manifest.json">
<link rel="canonical" href="http://localhost:1313/docs/coding-principles/solid/liskov-substitution/">
<link rel="stylesheet" href="/book.min.5cca5b9eae3794f73f645864ddc88f2f6a986c858cff98b19a2950df4bab8853.css" integrity="sha256-XMpbnq43lPc/ZFhk3ciPL2qYbIWM/5ixmilQ30uriFM=" crossorigin="anonymous">
  <script defer src="/fuse.min.js"></script>
  <script defer src="/en.search.min.1ca45c072f658d605da4c39f5488baab8f623eee0de706444de815f392fc14b2.js" integrity="sha256-HKRcBy9ljWBdpMOfVIi6q49iPu4N5wZETegV85L8FLI=" crossorigin="anonymous"></script>
<!--
Made with Book Theme
https://github.com/alex-shpak/hugo-book
-->
  
</head>
<body dir="ltr">
  <input type="checkbox" class="hidden toggle" id="menu-control" />
  <input type="checkbox" class="hidden toggle" id="toc-control" />
  <main class="container flex">
    <aside class="book-menu">
      <div class="book-menu-content">
        
  <nav>
<h2 class="book-brand">
  <a class="flex align-center" href="/"><span>SOLID.ref</span>
  </a>
</h2>


<div class="book-search hidden">
  <input type="text" id="book-search-input" placeholder="Search" aria-label="Search" maxlength="64" data-hotkeys="s/" />
  <div class="book-search-spinner hidden"></div>
  <ul id="book-search-results"></ul>
</div>
<script>document.querySelector(".book-search").classList.remove("hidden")</script>















  
  <ul>
    
      
        <li>
          
  
  

  
    <a href="/docs/clean-code/" class="">Clean Code</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/coding-principles/" class="">Coding Principles</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
      
        <li>
          
  
  

  
    <a href="/docs/design-patterns/" class="">Design Patterns</a>
  

          
  <ul>
    
  </ul>

        </li>
      
    
  </ul>














</nav>




  <script>(function(){var e=document.querySelector("aside .book-menu-content");addEventListener("beforeunload",function(){localStorage.setItem("menu.scrollTop",e.scrollTop)}),e.scrollTop=localStorage.getItem("menu.scrollTop")})()</script>


 
      </div>
    </aside>

    <div class="book-page">
      <header class="book-header">
        
  <div class="flex align-center justify-between">
  <label for="menu-control">
    <img src="/svg/menu.svg" class="book-icon" alt="Menu" />
  </label>

  <h3>Liskov Substitution Principle (LSP)</h3>

  <label for="toc-control">
    
    <img src="/svg/toc.svg" class="book-icon" alt="Table of Contents" />
    
  </label>
</div>


  
  <aside class="hidden clearfix">
    
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#why-use-the-liskov-substitution-principle">Why Use the Liskov Substitution Principle?</a></li>
    <li><a href="#key-concepts-of-lsp">Key Concepts of LSP</a></li>
    <li><a href="#lsp-in-action">LSP in Action</a>
      <ul>
        <li><a href="#without-lsp-violation-example">Without LSP: Violation Example</a></li>
        <li><a href="#with-lsp-corrected-example">With LSP: Corrected Example</a></li>
        <li><a href="#lsp-in-real-world-applications">LSP in Real-World Applications</a></li>
      </ul>
    </li>
    <li><a href="#benefits-and-challenges-of-lsp">Benefits and Challenges of LSP</a>
      <ul>
        <li><a href="#benefits">Benefits</a></li>
        <li><a href="#challenges">Challenges</a></li>
      </ul>
    </li>
    <li><a href="#best-practices-for-implementing-lsp">Best Practices for Implementing LSP</a></li>
    <li><a href="#conclusion">Conclusion</a></li>
  </ul>
</nav>



  </aside>
  
 
      </header>

      
      
  <article class="markdown book-article"><h1 id="liskov-substitution-principle-lsp">
  Liskov Substitution Principle (LSP)
  <a class="anchor" href="#liskov-substitution-principle-lsp">#</a>
</h1>
<p>The Liskov Substitution Principle (LSP) is the third principle in the SOLID principles of object-oriented design. It states:</p>
<p><strong>“Objects of a superclass should be replaceable with objects of a subclass without affecting the correctness of the program.”</strong></p>
<p>In other words, if class <code>B</code> is a subclass of class <code>A</code>, then instances of <code>A</code> should be replaceable by instances of <code>B</code> without altering the program&rsquo;s behavior. LSP ensures that a derived class can stand in for its base class without breaking functionality, making inheritance more predictable and reliable.</p>
<h2 id="why-use-the-liskov-substitution-principle">
  Why Use the Liskov Substitution Principle?
  <a class="anchor" href="#why-use-the-liskov-substitution-principle">#</a>
</h2>
<p>Violations of LSP can lead to unexpected bugs and breakages when subclasses behave differently from their base classes. Adhering to LSP helps:</p>
<ol>
<li><strong>Ensure Consistency</strong>: Subclasses are expected to behave consistently with their base classes.</li>
<li><strong>Maintain Predictability</strong>: LSP allows for predictable behavior, so consumers of the base class don’t need to know about subclass-specific details.</li>
<li><strong>Enhance Code Reusability</strong>: By ensuring that subclasses don’t violate the expectations of their base classes, we promote reusable code that’s easier to extend.</li>
</ol>
<h2 id="key-concepts-of-lsp">
  Key Concepts of LSP
  <a class="anchor" href="#key-concepts-of-lsp">#</a>
</h2>
<ol>
<li><strong>Behavioral Consistency</strong>: Subclasses should not change the expected behavior of methods inherited from the base class.</li>
<li><strong>Subtype Polymorphism</strong>: LSP enables polymorphism by ensuring that subclasses can be used interchangeably with their base class.</li>
<li><strong>No Weakened Preconditions or Strengthened Postconditions</strong>: Subclasses should not impose stricter conditions than the base class (preconditions) or give stronger guarantees on the result (postconditions).</li>
</ol>
<h2 id="lsp-in-action">
  LSP in Action
  <a class="anchor" href="#lsp-in-action">#</a>
</h2>
<p>Let’s explore an example to see how LSP works and what happens when it’s violated.</p>
<h3 id="without-lsp-violation-example">
  Without LSP: Violation Example
  <a class="anchor" href="#without-lsp-violation-example">#</a>
</h3>
<p>Consider a <code>Rectangle</code> class with <code>width</code> and <code>height</code> properties, and a <code>Square</code> subclass that inherits from it.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Rectangle</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">int</span> width;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">int</span> height;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setWidth</span>(<span style="color:#66d9ef">int</span> width) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">width</span> <span style="color:#f92672">=</span> width;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setHeight</span>(<span style="color:#66d9ef">int</span> height) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">height</span> <span style="color:#f92672">=</span> height;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getArea</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> width <span style="color:#f92672">*</span> height;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Square</span> <span style="color:#66d9ef">extends</span> Rectangle {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setWidth</span>(<span style="color:#66d9ef">int</span> width) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">width</span> <span style="color:#f92672">=</span> width;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">height</span> <span style="color:#f92672">=</span> width; <span style="color:#75715e">// Square has equal width and height</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">setHeight</span>(<span style="color:#66d9ef">int</span> height) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">height</span> <span style="color:#f92672">=</span> height;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">width</span> <span style="color:#f92672">=</span> height; <span style="color:#75715e">// Square has equal width and height</span>
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In this example:</p>
<ul>
<li>The <code>Square</code> class overrides <code>setWidth</code> and <code>setHeight</code> to ensure that the width and height remain equal, as squares require.</li>
<li>However, this breaks the expected behavior of the <code>Rectangle</code> class. For example, if a function expects a <code>Rectangle</code> but is passed a <code>Square</code>, setting only the <code>width</code> or <code>height</code> will produce incorrect results.</li>
</ul>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">resizeRectangle</span>(Rectangle rectangle) {
</span></span><span style="display:flex;"><span>    rectangle.<span style="color:#a6e22e">setWidth</span>(5);
</span></span><span style="display:flex;"><span>    rectangle.<span style="color:#a6e22e">setHeight</span>(10);
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">assert</span> rectangle.<span style="color:#a6e22e">getArea</span>() <span style="color:#f92672">==</span> 50; <span style="color:#75715e">// This fails for Square</span>
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In this case, using <code>Square</code> in place of <code>Rectangle</code> causes unexpected behavior, violating LSP.</p>
<h3 id="with-lsp-corrected-example">
  With LSP: Corrected Example
  <a class="anchor" href="#with-lsp-corrected-example">#</a>
</h3>
<p>To satisfy LSP, we should avoid making <code>Square</code> a subclass of <code>Rectangle</code> because a square is not a type of rectangle in terms of the expected behavior of width and height properties. Instead, we can create separate classes that share a common interface.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Shape</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getArea</span>();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Rectangle</span> <span style="color:#66d9ef">implements</span> Shape {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">int</span> width;
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">int</span> height;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Rectangle</span>(<span style="color:#66d9ef">int</span> width, <span style="color:#66d9ef">int</span> height) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">width</span> <span style="color:#f92672">=</span> width;
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">height</span> <span style="color:#f92672">=</span> height;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getArea</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> width <span style="color:#f92672">*</span> height;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Square</span> <span style="color:#66d9ef">implements</span> Shape {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> side;
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">Square</span>(<span style="color:#66d9ef">int</span> side) {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">this</span>.<span style="color:#a6e22e">side</span> <span style="color:#f92672">=</span> side;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getArea</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">return</span> side <span style="color:#f92672">*</span> side;
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>Now:</p>
<ul>
<li><code>Rectangle</code> and <code>Square</code> implement a common <code>Shape</code> interface, rather than <code>Square</code> inheriting from <code>Rectangle</code>.</li>
<li>Both classes provide an <code>getArea</code> method, so either can be used interchangeably where a <code>Shape</code> is expected.</li>
<li>This approach avoids violating LSP, as the behavior of <code>Square</code> and <code>Rectangle</code> no longer conflict.</li>
</ul>
<h3 id="lsp-in-real-world-applications">
  LSP in Real-World Applications
  <a class="anchor" href="#lsp-in-real-world-applications">#</a>
</h3>
<p>Let’s consider a practical scenario involving document processing.</p>
<p>Suppose we have a base class <code>Document</code> with a method <code>print</code> and a derived class <code>ReadOnlyDocument</code> that represents read-only documents.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">Document</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span>() {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Printing document...&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">save</span>() {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Saving document...&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ReadOnlyDocument</span> <span style="color:#66d9ef">extends</span> Document {
</span></span><span style="display:flex;"><span>    <span style="color:#a6e22e">@Override</span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">save</span>() {
</span></span><span style="display:flex;"><span>        <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> UnsupportedOperationException(<span style="color:#e6db74">&#34;Cannot save a read-only document&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>In this example:</p>
<ul>
<li><code>ReadOnlyDocument</code> violates LSP because it changes the expected behavior of the <code>save</code> method.</li>
<li>If a function that processes <code>Document</code> objects tries to save a <code>ReadOnlyDocument</code>, it will encounter an exception.</li>
</ul>
<h4 id="solution">
  Solution
  <a class="anchor" href="#solution">#</a>
</h4>
<p>To fix this, we can refactor by separating the behavior using interfaces.</p>
<div class="highlight"><pre tabindex="0" style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4;"><code class="language-java" data-lang="java"><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Printable</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span>();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">Saveable</span> {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">save</span>();
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">EditableDocument</span> <span style="color:#66d9ef">implements</span> Printable, Saveable {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span>() {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Printing document...&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">save</span>() {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Saving document...&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span><span style="display:flex;"><span>
</span></span><span style="display:flex;"><span><span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ReadOnlyDocument</span> <span style="color:#66d9ef">implements</span> Printable {
</span></span><span style="display:flex;"><span>    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">print</span>() {
</span></span><span style="display:flex;"><span>        System.<span style="color:#a6e22e">out</span>.<span style="color:#a6e22e">println</span>(<span style="color:#e6db74">&#34;Printing read-only document...&#34;</span>);
</span></span><span style="display:flex;"><span>    }
</span></span><span style="display:flex;"><span>}
</span></span></code></pre></div><p>This approach ensures that <code>ReadOnlyDocument</code> and <code>EditableDocument</code> conform to LSP, as each class now has methods that are specific to its functionality.</p>
<h2 id="benefits-and-challenges-of-lsp">
  Benefits and Challenges of LSP
  <a class="anchor" href="#benefits-and-challenges-of-lsp">#</a>
</h2>
<h3 id="benefits">
  Benefits
  <a class="anchor" href="#benefits">#</a>
</h3>
<ol>
<li><strong>Improved Predictability</strong>: Clients can use subclasses without needing to know their specific details, as behavior is consistent across the hierarchy.</li>
<li><strong>Enhanced Code Reusability</strong>: By following LSP, subclasses can be seamlessly reused where base classes are expected.</li>
<li><strong>Reduced Bugs</strong>: Violations of LSP can introduce subtle bugs, so adherence to LSP reduces the likelihood of unexpected behavior.</li>
</ol>
<h3 id="challenges">
  Challenges
  <a class="anchor" href="#challenges">#</a>
</h3>
<ol>
<li><strong>Complex Hierarchies</strong>: LSP can be challenging in complex hierarchies where subclass-specific behaviors conflict with base class expectations.</li>
<li><strong>Increased Design Overhead</strong>: LSP requires careful planning of class hierarchies and interfaces, which can add complexity to the design phase.</li>
<li><strong>Potential for Over-Refactoring</strong>: Strict adherence to LSP can sometimes lead to over-refactoring, where the desire for compliance introduces excessive interfaces or classes.</li>
</ol>
<h2 id="best-practices-for-implementing-lsp">
  Best Practices for Implementing LSP
  <a class="anchor" href="#best-practices-for-implementing-lsp">#</a>
</h2>
<ol>
<li><strong>Test Substitutability</strong>: Regularly test that subclasses can replace base classes without changing behavior, especially if the base class has defined contracts or invariants.</li>
<li><strong>Favor Composition Over Inheritance</strong>: Where LSP is difficult to achieve, consider using composition rather than inheritance to share functionality without inheriting unwanted behavior.</li>
<li><strong>Avoid Overloading Subclass Responsibilities</strong>: Limit the responsibilities of subclasses to avoid conflicts with base class expectations.</li>
</ol>
<h2 id="conclusion">
  Conclusion
  <a class="anchor" href="#conclusion">#</a>
</h2>
<p>The Liskov Substitution Principle is essential for creating robust, extendable, and reusable class hierarchies. By adhering to LSP, we ensure that subclasses behave in a way that is consistent with their base classes, allowing for predictable and interchangeable code. Though it may require extra design considerations, LSP ultimately leads to software that is more flexible, maintainable, and less prone to errors.</p>
</article>
 
      

      <footer class="book-footer">
        
  <div class="flex flex-wrap justify-between">





</div>



  <script>(function(){function e(e){const t=window.getSelection(),n=document.createRange();n.selectNodeContents(e),t.removeAllRanges(),t.addRange(n)}document.querySelectorAll("pre code").forEach(t=>{t.addEventListener("click",function(){if(window.getSelection().toString())return;e(t.parentElement),navigator.clipboard&&navigator.clipboard.writeText(t.parentElement.textContent)})})})()</script>


 
        
      </footer>

      
  
  <div class="book-comments">

</div>
  
 

      <label for="menu-control" class="hidden book-menu-overlay"></label>
    </div>

    
    <aside class="book-toc">
      <div class="book-toc-content">
        
  
<nav id="TableOfContents">
  <ul>
    <li><a href="#why-use-the-liskov-substitution-principle">Why Use the Liskov Substitution Principle?</a></li>
    <li><a href="#key-concepts-of-lsp">Key Concepts of LSP</a></li>
    <li><a href="#lsp-in-action">LSP in Action</a>
      <ul>
        <li><a href="#without-lsp-violation-example">Without LSP: Violation Example</a></li>
        <li><a href="#with-lsp-corrected-example">With LSP: Corrected Example</a></li>
        <li><a href="#lsp-in-real-world-applications">LSP in Real-World Applications</a></li>
      </ul>
    </li>
    <li><a href="#benefits-and-challenges-of-lsp">Benefits and Challenges of LSP</a>
      <ul>
        <li><a href="#benefits">Benefits</a></li>
        <li><a href="#challenges">Challenges</a></li>
      </ul>
    </li>
    <li><a href="#best-practices-for-implementing-lsp">Best Practices for Implementing LSP</a></li>
    <li><a href="#conclusion">Conclusion</a></li>
  </ul>
</nav>


 
      </div>
      
      <div class="book-toc-languages">
        
<h4>Coding Principles in ...</h4>
<nav>
  <div class="book-search">
    <input type="text" id="book-search-language-input" placeholder="Search Language" aria-label="Search Language" maxlength="64" data-hotkeys="s/">
  </div>
  <ul id="languages"></ul>
  <script>
    const languages = [];
    const languageLinks = document.getElementById('languages');
    const searchInput = document.getElementById('book-search-language-input');
    const maxLanguages = 15

    const listLanguages = (filter = '') => {
      languageLinks.innerHTML = ''
      const filtered = languages
        .filter(item => item.title.toLowerCase().includes(filter.toLowerCase()))
      filtered.slice(0, filtered.length > maxLanguages ? maxLanguages : filtered.length)
        .forEach(item => {
          const link = document.createElement('a');
          link.href = item.href;
          link.textContent = item.title;
          const li = document.createElement('li');
          li.appendChild(link);
          languageLinks.appendChild(li);
        })
      if (filtered.length > maxLanguages) {
        const li = document.createElement('li');
        li.textContent = '...';
        languageLinks.appendChild(li);
      }
    }

    listLanguages('')
    searchInput.onkeyup = () => { listLanguages(searchInput.value) }
  </script>
</nav>
 
      </div>
      
    </aside>
    
  </main>

  
</body>
</html>














