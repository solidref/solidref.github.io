{"name":"JavaScript (ECMAScript)","code":"javascript","birth":1995,"death":"N/A","inspiredBy":["awk","hypertalk","java","perl","python","self","scheme"],"inspiring":["typescript","coffeescript","dart","elm"],"description":"A key technology of the World Wide Web, JavaScript is an essential language for front-end web development,\nenabling interactive web pages. It's also used in server-side development (Node.js, Deno, and Bun). As a multi-paradigm language,\nit supports event-driven, functional, and imperative programming styles. It has dynamic typing and supports object-oriented programming.\nJavaScript has seen significant evolution since its inception, particularly with the introduction of ECMAScript 6 (ES6) in 2015,\nwhich brought major syntactic improvements and features like classes, modules, arrow functions, and template literals.\n","patterns":{"patterns_behavioural":[{"title":"Chain Of Responsibility","examples":[{"code":"// Chain of Responsibility Pattern in JavaScript\nclass Handler {\n    constructor(nextHandler) {\n        this.nextHandler = nextHandler;\n    }\n\n    handle(request) {\n        if (this.nextHandler) {\n            return this.nextHandler.handle(request);\n        }\n\n        return null;\n    }\n}\n\n// Concrete Handlers\nclass ConcreteHandler1 extends Handler {\n    handle(request) {\n        if (request === 'handle1') {\n            return 'Handled by ConcreteHandler1';\n        }\n        return super.handle(request);\n    }\n}\n\nclass ConcreteHandler2 extends Handler {\n    handle(request) {\n        if (request === 'handle2') {\n            return 'Handled by ConcreteHandler2';\n        }\n        return super.handle(request);\n    }\n}\n\n// Client code\nconst handler1 = new ConcreteHandler1();\nconst handler2 = new ConcreteHandler2(handler1);\n\nconsole.log(handler2.handle('handle2'));\nconsole.log(handler2.handle('handle1'));\n"}]},{"title":"Command","examples":[{"code":"// Command Pattern in JavaScript\nclass Command {\n    execute() {}\n}\n\nclass Light {\n    turnOn() {\n        console.log('Light turned on');\n    }\n\n    turnOff() {\n        console.log('Light turned off');\n    }\n}\n\nclass TurnOnCommand extends Command {\n    constructor(light) {\n        super();\n        this.light = light;\n    }\n\n    execute() {\n        this.light.turnOn();\n    }\n}\n\nclass TurnOffCommand extends Command {\n    constructor(light) {\n        super();\n        this.light = light;\n    }\n\n    execute() {\n        this.light.turnOff();\n    }\n}\n\n// Invoker\nclass RemoteControl {\n    submit(command) {\n        command.execute();\n    }\n}\n\n// Client code\nconst light = new Light();\nconst turnOnCommand = new TurnOnCommand(light);\nconst turnOffCommand = new TurnOffCommand(light);\nconst remote = new RemoteControl();\n\nremote.submit(turnOnCommand);\nremote.submit(turnOffCommand);\n"}]},{"title":"Iterator","examples":[{"code":"// Iterator Pattern in JavaScript\nclass Iterator {\n    constructor(collection) {\n        this.collection = collection;\n        this.index = 0;\n    }\n\n    next() {\n        return this.collection[this.index++];\n    }\n\n    hasNext() {\n        return this.index < this.collection.length;\n    }\n}\n\n// Client code\nconst items = [1, 'two', 3, 'four', 5];\nconst iterator = new Iterator(items);\n\nwhile (iterator.hasNext()) {\n    console.log(iterator.next());\n}\n"}]},{"title":"Mediator","examples":[{"code":"// Mediator Pattern in JavaScript\nclass Mediator {\n    constructor() {\n        this.colleagues = [];\n    }\n\n    register(colleague) {\n        this.colleagues.push(colleague);\n        colleague.setMediator(this);\n    }\n\n    send(message, sender) {\n        this.colleagues.forEach(colleague => {\n            if (colleague !== sender) {\n                colleague.receive(message);\n            }\n        });\n    }\n}\n\nclass Colleague {\n    setMediator(mediator) {\n        this.mediator = mediator;\n    }\n\n    send(message) {\n        this.mediator.send(message, this);\n    }\n\n    receive(message) {\n        console.log(`${this.constructor.name} received message: ${message}`);\n    }\n}\n\n// Concrete Colleagues\nclass ConcreteColleague1 extends Colleague {}\nclass ConcreteColleague2 extends Colleague {}\n\n// Client code\nconst mediator = new Mediator();\nconst colleague1 = new ConcreteColleague1();\nconst colleague2 = new ConcreteColleague2();\n\nmediator.register(colleague1);\nmediator.register(colleague2);\n\ncolleague1.send('Hello from Colleague 1');\ncolleague2.send('Hello from Colleague 2');\n"}]},{"title":"Memento","examples":[{"code":"// Memento Pattern in JavaScript\nclass Memento {\n    constructor(state) {\n        this.state = state;\n    }\n\n    getState() {\n        return this.state;\n    }\n}\n\nclass Originator {\n    constructor() {\n        this.state = '';\n    }\n\n    setState(state) {\n        this.state = state;\n    }\n\n    getState() {\n        return this.state;\n    }\n\n    save() {\n        return new Memento(this.state);\n    }\n\n    restore(memento) {\n        this.state = memento.getState();\n    }\n}\n\nclass Caretaker {\n    constructor() {\n        this.mementos = [];\n    }\n\n    addMemento(memento) {\n        this.mementos.push(memento);\n    }\n\n    getMemento(index) {\n        return this.mementos[index];\n    }\n}\n\n// Client code\nconst originator = new Originator();\nconst caretaker = new Caretaker();\n\noriginator.setState('State #1');\ncaretaker.addMemento(originator.save());\n\noriginator.setState('State #2');\ncaretaker.addMemento(originator.save());\n\noriginator.restore(caretaker.getMemento(0));\nconsole.log(originator.getState());\n"}]},{"title":"Observer","examples":[{"code":"// Observer Pattern in JavaScript\nclass Subject {\n    constructor() {\n        this.observers = [];\n    }\n\n    subscribe(observer) {\n        this.observers.push(observer);\n    }\n\n    unsubscribe(observer) {\n        const index = this.observers.indexOf(observer);\n        if (index > -1) {\n            this.observers.splice(index, 1);\n        }\n    }\n\n    notify(data) {\n        this.observers.forEach(observer => observer.update(data));\n    }\n}\n\nclass Observer {\n    update(data) {\n        console.log(`Observer received data: ${data}`);\n    }\n}\n\n// Client code\nconst subject = new Subject();\nconst observer1 = new Observer();\nconst observer2 = new Observer();\n\nsubject.subscribe(observer1);\nsubject.subscribe(observer2);\n\nsubject.notify('Hello Observers!');\n\nsubject.unsubscribe(observer2);\nsubject.notify('Goodbye Observers!');\n"}]},{"title":"State","examples":[{"code":"/**\n* The Context defines the interface of interest to clients. It also maintains a\n* reference to an instance of a State subclass, which represents the current\n* state of the Context.\n*/\nclass Context {\n    /**\n    * @type {State} A reference to the current state of the Context.\n    */\n    private state: State;\n\n    constructor(state: State) {\n        this.transitionTo(state);\n    }\n\n    /**\n    * The Context allows changing the State object at runtime.\n    */\n    public transitionTo(state: State): void {\n        console.log(`Context: Transition to ${(<any>state).constructor.name}.`);\n        this.state = state;\n        this.state.setContext(this);\n    }\n\n    /**\n    * The Context delegates part of its behavior to the current State object.\n    */\n    public request1(): void {\n        this.state.handle1();\n    }\n\n    public request2(): void {\n        this.state.handle2();\n    }\n}\n\n/**\n* The base State class declares methods that all Concrete State should\n* implement and also provides a backreference to the Context object, associated\n* with the State. This backreference can be used by States to transition the\n* Context to another State.\n*/\nabstract class State {\n    protected context: Context;\n\n    public setContext(context: Context) {\n        this.context = context;\n    }\n\n    public abstract handle1(): void;\n\n    public abstract handle2(): void;\n}\n\n/**\n* Concrete States implement various behaviors, associated with a state of the\n* Context.\n*/\nclass ConcreteStateA extends State {\n    public handle1(): void {\n        console.log('ConcreteStateA handles request1.');\n        console.log('ConcreteStateA wants to change the state of the context.');\n        this.context.transitionTo(new ConcreteStateB());\n    }\n\n    public handle2(): void {\n        console.log('ConcreteStateA handles request2.');\n    }\n}\n\nclass ConcreteStateB extends State {\n    public handle1(): void {\n        console.log('ConcreteStateB handles request1.');\n    }\n\n    public handle2(): void {\n        console.log('ConcreteStateB handles request2.');\n        console.log('ConcreteStateB wants to change the state of the context.');\n        this.context.transitionTo(new ConcreteStateA());\n    }\n}\n\n/**\n* The client code.\n*/\nconst context = new Context(new ConcreteStateA());\ncontext.request1();\ncontext.request2();\n"}]},{"title":"Strategy","examples":[{"code":"// Strategy Pattern in JavaScript\nclass Strategy {\n    execute(data) {\n        throw new Error('Strategy method execute() is not implemented');\n    }\n}\n\nclass ConcreteStrategyA extends Strategy {\n    execute(data) {\n        return `Strategy A with data ${data}`;\n    }\n}\n\nclass ConcreteStrategyB extends Strategy {\n    execute(data) {\n        return `Strategy B with data ${data}`;\n    }\n}\n\n// Context\nclass Context {\n    constructor(strategy) {\n        this.strategy = strategy;\n    }\n\n    setStrategy(strategy) {\n        this.strategy = strategy;\n    }\n\n    executeStrategy(data) {\n        return this.strategy.execute(data);\n    }\n}\n\n// Client code\nconst context = new Context(new ConcreteStrategyA());\nconsole.log(context.executeStrategy('123'));\n\ncontext.setStrategy(new ConcreteStrategyB());\nconsole.log(context.executeStrategy('456'));\n"}]},{"title":"TemplateMethod","examples":[{"code":"// Template Method Pattern in JavaScript\nclass AbstractClass {\n    templateMethod() {\n        this.baseOperation1();\n        this.requiredOperation1();\n        this.baseOperation2();\n        this.hook1();\n        this.requiredOperation2();\n        this.baseOperation3();\n        this.hook2();\n    }\n\n    baseOperation1() {\n        console.log(\"AbstractClass says: I am doing the bulk of the work\");\n    }\n\n    baseOperation2() {\n        console.log(\"AbstractClass says: But I let subclasses override some operations\");\n    }\n\n    baseOperation3() {\n        console.log(\"AbstractClass says: But I am doing the bulk of the work anyway\");\n    }\n\n    requiredOperation1() {}\n    requiredOperation2() {}\n\n    hook1() {}\n    hook2() {}\n}\n\nclass ConcreteClass1 extends AbstractClass {\n    requiredOperation1() {\n        console.log(\"ConcreteClass1 says: Implemented Operation1\");\n    }\n\n    requiredOperation2() {\n        console.log(\"ConcreteClass1 says: Implemented Operation2\");\n    }\n}\n\nclass ConcreteClass2 extends AbstractClass {\n    requiredOperation1() {\n        console.log(\"ConcreteClass2 says: Implemented Operation1\");\n    }\n\n    requiredOperation2() {\n        console.log(\"ConcreteClass2 says: Implemented Operation2\");\n    }\n\n    hook1() {\n        console.log(\"ConcreteClass2 says: Overridden Hook1\");\n    }\n}\n\n// Client code\nconsole.log('Same client code can work with different subclasses:');\nnew ConcreteClass1().templateMethod();\nconsole.log('');\nnew ConcreteClass2().templateMethod();\n"}]},{"title":"Visitor","examples":[{"code":"// Visitor Pattern in JavaScript\nclass Visitor {\n    visitConcreteComponentA(element) {}\n    visitConcreteComponentB(element) {}\n}\n\nclass ConcreteComponentA {\n    accept(visitor) {\n        visitor.visitConcreteComponentA(this);\n    }\n\n    exclusiveMethodOfConcreteComponentA() {\n        return 'A';\n    }\n}\n\nclass ConcreteComponentB {\n    accept(visitor) {\n        visitor.visitConcreteComponentB(this);\n    }\n\n    specialMethodOfConcreteComponentB() {\n        return 'B';\n    }\n}\n\nclass ConcreteVisitor1 extends Visitor {\n    visitConcreteComponentA(element) {\n        console.log(\\`$\\{element.exclusiveMethodOfConcreteComponentA()} + ConcreteVisitor1\\`);\n    }\n\n    visitConcreteComponentB(element) {\n        console.log(\\`$\\{element.specialMethodOfConcreteComponentB()} + ConcreteVisitor1\\`);\n    }\n}\n\n// Client code\nconst components = [\n    new ConcreteComponentA(),\n    new ConcreteComponentB(),\n];\n\nconst visitor1 = new ConcreteVisitor1();\n\ncomponents.forEach((c) => c.accept(visitor1));\n"}]}],"patterns_creational":[{"title":"Factory Method","examples":[{"code":"// Factory Method Pattern in JavaScript\nclass Creator {\n    factoryMethod() {\n        return new ConcreteProduct();\n    }\n\n    someOperation() {\n        const product = this.factoryMethod();\n        return `Creator: The same creator's code has just worked with ${product.operation()}`;\n    }\n}\n\nclass ConcreteCreator1 extends Creator {\n    factoryMethod() {\n        return new ConcreteProduct1();\n    }\n}\n\nclass ConcreteCreator2 extends Creator {\n    factoryMethod() {\n        return new ConcreteProduct2();\n    }\n}\n\nclass Product {\n    operation() {\n        return '{Result of the Product}';\n    }\n}\n\nclass ConcreteProduct1 extends Product {\n    operation() {\n        return '{Result of the ConcreteProduct1}';\n    }\n}\n\nclass ConcreteProduct2 extends Product {\n    operation() {\n        return '{Result of the ConcreteProduct2}';\n    }\n}\n\n// Client code\nfunction clientCode(creator) {\n    console.log('Client: I\\'m not aware of the creator\\'s class, but it still works.');\n    console.log(creator.someOperation());\n}\n\nconsole.log('App: Launched with the ConcreteCreator1.');\nclientCode(new ConcreteCreator1());\nconsole.log('');\n\nconsole.log('App: Launched with the ConcreteCreator2.');\nclientCode(new ConcreteCreator2());\n"}]},{"title":"Abstract Factory","examples":[{"code":"// Abstract Factory Pattern in JavaScript\nclass AbstractFactory {\n    createProductA() {}\n    createProductB() {}\n}\n\nclass ConcreteFactory1 extends AbstractFactory {\n    createProductA() {\n        return new ConcreteProductA1();\n    }\n\n    createProductB() {\n        return new ConcreteProductB1();\n    }\n}\n\nclass ConcreteFactory2 extends AbstractFactory {\n    createProductA() {\n        return new ConcreteProductA2();\n    }\n\n    createProductB() {\n        return new ConcreteProductB2();\n    }\n}\n\nclass AbstractProductA {\n    usefulFunctionA() {}\n}\n\nclass ConcreteProductA1 extends AbstractProductA {\n    usefulFunctionA() {\n        return 'The result of the product A1.';\n    }\n}\n\nclass ConcreteProductA2 extends AbstractProductA {\n    usefulFunctionA() {\n        return 'The result of the product A2.';\n    }\n}\n\nclass AbstractProductB {\n    usefulFunctionB() {}\n    anotherUsefulFunctionB(collaborator) {}\n}\n\nclass ConcreteProductB1 extends AbstractProductB {\n    usefulFunctionB() {\n        return 'The result of the product B1.';\n    }\n\n    anotherUsefulFunctionB(collaborator) {\n        const result = collaborator.usefulFunctionA();\n        return `The result of the B1 collaborating with the (${result})`;\n    }\n}\n\nclass ConcreteProductB2 extends AbstractProductB {\n    usefulFunctionB() {\n        return 'The result of the product B2.';\n    }\n\n    anotherUsefulFunctionB(collaborator) {\n        const result = collaborator.usefulFunctionA();\n        return `The result of the B2 collaborating with the (${result})`;\n    }\n}\n\n// Client code\nfunction clientCode(factory) {\n    const productA = factory.createProductA();\n    const productB = factory.createProductB();\n\n    console.log(productB.usefulFunctionB());\n    console.log(productB.anotherUsefulFunctionB(productA));\n}\n\nclientCode(new ConcreteFactory1());\nclientCode(new ConcreteFactory2());\n"}]},{"title":"Builder","examples":[{"code":"// Builder Pattern in JavaScript\nclass Director {\n    constructor() {\n        this.builder = null;\n    }\n\n    setBuilder(builder) {\n        this.builder = builder;\n    }\n\n    construct() {\n        this.builder.buildPartA();\n        this.builder.buildPartB();\n        this.builder.buildPartC();\n    }\n}\n\nclass Builder {\n    buildPartA() {}\n    buildPartB() {}\n    buildPartC() {}\n    getResult() {}\n}\n\nclass ConcreteBuilder extends Builder {\n    constructor() {\n        super();\n        this.product = new Product();\n    }\n\n    buildPartA() {\n        this.product.parts.push('PartA');\n    }\n\n    buildPartB() {\n        this.product.parts.push('PartB');\n    }\n\n    buildPartC() {\n        this.product.parts.push('PartC');\n    }\n\n    getResult() {\n        return this.product;\n    }\n}\n\nclass Product {\n    constructor() {\n        this.parts = [];\n    }\n}\n\n// Client code\nconst director = new Director();\nconst builder = new ConcreteBuilder();\ndirector.setBuilder(builder);\n\ndirector.construct();\nconst product = builder.getResult();\nconsole.log(product.parts);\n"}]},{"title":"Prototype","examples":[{"code":"// Prototype Pattern in JavaScript\nclass Prototype {\n    clone() {\n        const clone = Object.create(this);\n        clone.component = Object.create(this.component);\n\n        // Clone each property if needed (deep copy)\n        clone.circularReference = {\n            ...this.circularReference,\n            prototype: { ...this },\n        };\n\n        return clone;\n    }\n}\n\nclass ConcretePrototype1 extends Prototype {\n    constructor() {\n        super();\n        this.primitive = 245;\n        this.component = new Date();\n        this.circularReference = {\n            prototype: this,\n        };\n    }\n}\n\n// Client code\nconst p1 = new ConcretePrototype1();\nconst p2 = p1.clone();\n\nconsole.log('p1:', p1);\nconsole.log('p2:', p2);\nconsole.log('Same component?', p1.component === p2.component); // false, deep copy\n"}]},{"title":"Singleton","examples":[{"code":"// Singleton Pattern in JavaScript\nclass Singleton {\n    constructor() {\n        if (!Singleton.instance) {\n            Singleton.instance = this;\n        }\n        return Singleton.instance;\n    }\n\n    // Some business logic\n    someBusinessLogic() {}\n\n    static getInstance() {\n        if (!this.instance) {\n            this.instance = new Singleton();\n        }\n        return this.instance;\n    }\n}\n\n// Client code\nconst instance1 = Singleton.getInstance();\nconst instance2 = Singleton.getInstance();\n\n\nconsole.log('Same instance?', instance1 === instance2); // true\n"}]}],"patterns_structural":[{"title":"Adapter","examples":[{"code":"// Adapter Pattern in JavaScript\nclass Target {\n    request() {\n        return 'Target: The default target\\'s behavior.';\n    }\n}\n\nclass Adaptee {\n    specificRequest() {\n        return '.eetpadA eht fo roivaheb laicepS';\n    }\n}\n\nclass Adapter extends Target {\n    constructor(adaptee) {\n        super();\n        this.adaptee = adaptee;\n    }\n\n    request() {\n        const result = this.adaptee.specificRequest().split('').reverse().join('');\n        return `Adapter: (TRANSLATED) ${result}`;\n    }\n}\n\n// Client code\nconst target = new Target();\nconsole.log(target.request());\n\nconst adaptee = new Adaptee();\nconsole.log(`Adaptee: ${adaptee.specificRequest()}`);\n\nconsole.log('After using Adapter...');\nconst adapter = new Adapter(adaptee);\nconsole.log(adapter.request());\n"}]},{"title":"Bridge","examples":[{"code":"// Bridge Pattern in JavaScript\nclass Abstraction {\n    constructor(implementation) {\n        this.implementation = implementation;\n    }\n\n    operation() {\n        const result = this.implementation.operationImplementation();\n        return `Abstraction: Base operation with:\\n${result}`;\n    }\n}\n\nclass ExtendedAbstraction extends Abstraction {\n    operation() {\n        const result = this.implementation.operationImplementation();\n        return `ExtendedAbstraction: Extended operation with:\\n${result}`;\n    }\n}\n\nclass ImplementationA {\n    operationImplementation() {\n        return 'ImplementationA: Here\\'s the result on the platform A.';\n    }\n}\n\nclass ImplementationB {\n    operationImplementation() {\n        return 'ImplementationB: Here\\'s the result on the platform B.';\n    }\n}\n\n// Client code\nlet implementation = new ImplementationA();\nlet abstraction = new Abstraction(implementation);\nconsole.log(abstraction.operation());\n\nimplementation = new ImplementationB();\nabstraction = new ExtendedAbstraction(implementation);\nconsole.log(abstraction.operation());\n"}]},{"title":"Composite","examples":[{"code":"// Composite Pattern in JavaScript\nclass Component {\n    constructor(name) {\n        this.name = name;\n    }\n\n    add(component) {}\n\n    remove(component) {}\n\n    display(depth) {}\n}\n\nclass Leaf extends Component {\n    constructor(name) {\n        super(name);\n    }\n\n    display(depth) {\n        console.log('-'.repeat(depth) + this.name);\n    }\n}\n\nclass Composite extends Component {\n    constructor(name) {\n        super(name);\n        this.children = [];\n    }\n\n    add(component) {\n        this.children.push(component);\n    }\n\n    remove(component) {\n        const index = this.children.indexOf(component);\n        if (index > -1) {\n            this.children.splice(index, 1);\n        }\n    }\n\n    display(depth) {\n        console.log('-'.repeat(depth) + this.name);\n\n        for (const child of this.children) {\n            child.display(depth + 2);\n        }\n    }\n}\n\n// Client code\nconst root = new Composite('root');\nroot.add(new Leaf('Leaf A'));\nroot.add(new Leaf('Leaf B'));\n\nconst comp = new Composite('Composite X');\ncomp.add(new Leaf('Leaf XA'));\ncomp.add(new Leaf('Leaf XB'));\n\nroot.add(comp);\nroot.add(new Leaf('Leaf C'));\n\nconst leaf = new Leaf('Leaf D');\nroot.add(leaf);\nroot.remove(leaf);\n\nroot.display(1);\n"}]},{"title":"Decorator","examples":[{"code":"// Decorator Pattern in JavaScript\nclass Component {\n    operation() {\n        return 'Component';\n    }\n}\n\nclass ConcreteComponent extends Component {\n    operation() {\n        return `ConcreteComponent`;\n    }\n}\n\nclass Decorator extends Component {\n    constructor(component) {\n        super();\n        this.component = component;\n    }\n\n    operation() {\n        return this.component.operation();\n    }\n}\n\nclass ConcreteDecoratorA extends Decorator {\n    operation() {\n        return `ConcreteDecoratorA(${super.operation()})`;\n    }\n}\n\nclass ConcreteDecoratorB extends Decorator {\n    operation() {\n        return `ConcreteDecoratorB(${super.operation()})`;\n    }\n}\n\n// Client code\nlet simple = new ConcreteComponent();\nconsole.log(`Simple component: ${simple.operation()}`);\n\nlet decorator1 = new ConcreteDecoratorA(simple);\nlet decorator2 = new ConcreteDecoratorB(decorator1);\nconsole.log(`Decorated component: ${decorator2.operation()}`);\n"}]},{"title":"Facade","examples":[{"code":"// Facade Pattern in JavaScript\nclass Subsystem1 {\n    operation1() {\n        return 'Subsystem1: Ready!';\n    }\n\n    operationN() {\n        return 'Subsystem1: Go!';\n    }\n}\n\nclass Subsystem2 {\n    operation1() {\n        return 'Subsystem2: Get ready!';\n    }\n\n    operationZ() {\n        return 'Subsystem2: Fire!';\n    }\n}\n\nclass Facade {\n    constructor(subsystem1, subsystem2) {\n        this.subsystem1 = subsystem1 || new Subsystem1();\n        this.subsystem2 = subsystem2 || new Subsystem2();\n    }\n\n    operation() {\n        let result = 'Facade initializes subsystems:\\n';\n        result += this.subsystem1.operation1();\n        result += this.subsystem2.operation1();\n        result += 'Facade orders subsystems to perform the action:\\n';\n        result += this.subsystem1.operationN();\n        result += this.subsystem2.operationZ();\n        return result;\n    }\n}\n\n// Client code\nconst subsystem1 = new Subsystem1();\nconst subsystem2 = new Subsystem2();\nconst facade = new Facade(subsystem1, subsystem2);\nconsole.log(facade.operation());\n"}]},{"title":"Flyweight","examples":[{"code":"// Flyweight Pattern in JavaScript\nclass Flyweight {\n    constructor(sharedState) {\n        this.sharedState = sharedState;\n    }\n\n    operation(uniqueState) {\n        const s = JSON.stringify(this.sharedState);\n        const u = JSON.stringify(uniqueState);\n        console.log(`Flyweight: Displaying shared (${s}) and unique (${u}) state.`);\n    }\n}\n\nclass FlyweightFactory {\n    constructor(initialFlyweights) {\n        this.flyweights = {};\n        for (const state of initialFlyweights) {\n            this.flyweights[this.getKey(state)] = new Flyweight(state);\n        }\n    }\n\n    getKey(state) {\n        return state.join('_');\n    }\n\n    getFlyweight(sharedState) {\n        const key = this.getKey(sharedState);\n\n        if (!(key in this.flyweights)) {\n            console.log('FlyweightFactory: Can\\'t find a flyweight, creating new one.');\n            this.flyweights[key] = new Flyweight(sharedState);\n        } else {\n            console.log('FlyweightFactory: Reusing existing flyweight.');\n        }\n\n        return this.flyweights[key];\n    }\n}\n\n// Client code\nconst factory = new FlyweightFactory([\n    ['Chevrolet', 'Camaro2018', 'pink'],\n    ['Mercedes Benz', 'C300', 'black'],\n    ['Mercedes Benz', 'C500', 'red'],\n]);\n\nfactory.getFlyweight(['Chevrolet', 'Camaro2018', 'pink']).operation(['A001', 'Jul 30, 2020']);\nfactory.getFlyweight(['Mercedes Benz', 'C300', 'black']).operation(['B002', 'May 18, 2021']);\n\nconsole.log('\\nAdding new car to pool');\nfactory.getFlyweight(['BMW', 'M5', 'red']).operation(['C003', 'Mar 15, 2022']);\n"}]},{"title":"Proxy","examples":[{"code":"// Proxy Pattern in JavaScript\nclass Subject {\n    request() {\n        return 'Subject: Handling request.';\n    }\n}\n\nclass RealSubject extends Subject {\n    request() {\n        return 'RealSubject: Handling request.';\n    }\n}\n\nclass Proxy extends Subject {\n    constructor(realSubject) {\n        super();\n        this.realSubject = realSubject;\n    }\n\n    request() {\n        if (this.checkAccess()) {\n            this.realSubject.request();\n            this.logAccess();\n            return 'Proxy: Logged and handing over to RealSubject.';\n        }\n        return 'Proxy: I am sorry, but I cannot let you through.';\n    }\n\n    checkAccess() {\n        // Some real checks should go here.\n        console.log('Proxy: Checking access prior to firing a real request.');\n        return true;\n    }\n\n    logAccess() {\n        console.log('Proxy: Logging the time of request.');\n    }\n}\n\n// Client code\nconst realSubject = new RealSubject();\nconsole.log(realSubject.request());\n\nconst proxy = new Proxy(realSubject);\nconsole.log(proxy.request());\n"}]}],"patterns_proprietary":[{"title":"Module","description":[{"variant":"subtitle1","content":"The Module Pattern encapsulates \"privacy\", state, and organization using closures. It's commonly used in the JavaScript community due to its powerful ability to create private and public parts.\n"},{"variant":"h6","content":"Benefits"},{"variant":"subtitle1","content":"This pattern provides a way to encapsulate private members while exposing a public API. It also helps in organizing code into manageable sections.\n"}],"examples":[{"code":"const Module = (function() {\n    let privateVar = 'I am private...';\n    return {\n        publicMethod: function() {\n            console.log(privateVar);\n        }\n    };\n})();\nModule.publicMethod(); // Outputs: 'I am private...'\n"}]},{"title":"Revealing Module","description":[{"variant":"subtitle1","content":"A variant of the Module pattern, the Revealing Module Pattern explicitly reveals public pointers to methods inside the module's scope.\n"},{"variant":"h6","content":"Benefits"},{"variant":"subtitle1","content":"This pattern makes the syntax more consistent and makes it clear at the end of the module which of its members are public.\n"}],"examples":[{"code":"const RevealingModule = (function() {\n    let privateVar = 'I am private...';\n    function privateFunction() {\n        console.log(privateVar);\n    }\n    return {\n        publicMethod: function() {\n            privateFunction();\n        }\n    };\n})();\nRevealingModule.publicMethod(); // Outputs: 'I am private...'\n"}]},{"title":"Mixin","description":[{"variant":"subtitle1","content":"JavaScript's object model includes features that allow it to mimic a classical inheritance pattern, known as Mixins. They allow objects to take on properties and methods from other objects.\n"},{"variant":"h6","content":"Benefits"},{"variant":"subtitle1","content":"Mixins help in avoiding the issues related to traditional inheritance and provide a way to add reusable functionalities to objects. They can be used to augment a class by adding multiple behaviors like event handling as mixins.\n"}],"examples":[{"code":"let CarMixin = {\n    revEngine() {\n        console.log(`The ${this.name} goes vroom vroom!`);\n    }\n};\nfunction Car(name) {\n    this.name = name;\n}\nObject.assign(Car.prototype, CarMixin);\nlet raceCar = new Car(\"Ferrari\");\nraceCar.revEngine();  // Outputs: The Ferrari goes vroom vroom!\n"}]},{"title":"Publish/Subscribe","description":[{"variant":"subtitle1","content":"This pattern allows you to create modules that can communicate with each other over a single interface without knowing about each other's inner workings. It's a form of decoupling that can be incredibly useful for larger applications.\n"},{"variant":"h6","content":"Benefits"},{"variant":"subtitle1","content":"The pattern promotes loose coupling and enables better testability, maintainability, and scalability of the application. It's an essential pattern for building complex applications that require various modules to communicate with each other asynchronously.\n"}],"examples":[{"code":"var pubsub = {};\n(function(q) {\n    var topics = {}, subUid = -1;\n    q.publish = function(topic, args) {\n        if (!topics[topic]) {\n            return false;\n        }\n        var subscribers = topics[topic],\n            len = subscribers ? subscribers.length : 0;\n        while (len--) {\n            subscribers[len].func(topic, args);\n        }\n        return this;\n    };\n    q.subscribe = function(topic, func) {\n        if (!topics[topic]) {\n            topics[topic] = [];\n        }\n        var token = (++subUid).toString();\n        topics[topic].push({\n            token: token,\n            func: func\n        });\n        return token;\n    };\n    q.unsubscribe = function(token) {\n        for (var m in topics) {\n            if (topics[m]) {\n                for (var i = 0, j = topics[m].length; i < j; i++) {\n                    if (topics[m][i].token === token) {\n                        topics[m].splice(i, 1);\n                        return token;\n                    }\n                }\n            }\n        }\n        return this;\n    };\n}(pubsub));\nvar messageLogger = function(topics, data) {\n    console.log(`Logging: ${topics}: ${data}`);\n};\nvar subscription = pubsub.subscribe('inbox/newMessage', messageLogger);\npubsub.publish('inbox/newMessage', 'hello world!');\npubsub.publish('inbox/newMessage', ['test', 'a', 'b', 'c']);\npubsub.publish('inbox/newMessage', [{\n    sender: 'hello@google.com',\n    body: 'Hey again!'\n}]);\npubsub.unsubscribe(subscription);\n"}]},{"title":"Promise","description":[{"variant":"subtitle1","content":"With the advent of ES6, Promises are a model for asynchronous programming. Promises are a first-class representation of a value that may be made available in the future.\n"},{"variant":"h6","content":"Benefits"},{"variant":"subtitle1","content":"Promises provide a cleaner, more robust way of handling asynchronous operations compared to callbacks. They simplify error handling, improve readability and make it easier to write asynchronous code.\n"}],"examples":[{"code":"let promise = new Promise(function(resolve, reject) {\n    setTimeout(function() {\n        resolve('Hello world!');\n    }, 2000);\n});\npromise.then(function(value) {\n    console.log(value); // \"Hello world!\"\n}).catch(function(error) {\n    console.log(error);\n});\n"}]}]},"principles":{"principles_solid":[{"title":"Single Responsibility","examples":[{"title":"Good Example (ES6)","code":"// Good example (ES6): Using ES6 classes to split responsibilities\nclass UserDataManager {\n    saveUserData() { /* ... */ }\n}\n\nclass UserNotification {\n    sendNotification() { /* ... */ }\n}\n"},{"title":"Good Example (ES5)","code":"// Good example (ES5): Splitting responsibilities using function constructors\nfunction UserDataManager() {\n    this.saveUserData = function() { /* ... */ };\n}\n\nfunction UserNotification() {\n    this.sendNotification = function() { /* ... */ };\n}\n"},{"title":"Bad Example (ES6)","code":"// Bad example (ES6): A single ES6 class handling both user data and notifications\nclass User {\n    saveUserData() { /* ... */ }\n    sendNotification() { /* ... */ }\n}\n"},{"title":"Bad Example (ES5)","code":"// Bad example (ES5): A single function constructor handling both user data and notifications\nfunction User() {\n    this.saveUserData = function() { /* ... */ };\n    this.sendNotification = function() { /* ... */ };\n}\n"}]},{"title":"Open-Closed","examples":[{"title":"Good Example (ES6)","code":"// Good example (ES6): Using ES6 classes and inheritance for the Open/Closed principle\nclass Shape {\n    computeArea() { throw new Error('Must be implemented in subclasses'); }\n}\n\nclass Rectangle extends Shape {\n    constructor(width, height) {\n        super();\n        this.width = width;\n        this.height = height;\n    }\n\n    computeArea() {\n        return this.width * this.height;\n    }\n}\n"},{"title":"Good Example (ES5)","code":"// Good example (ES5): Using prototype to allow extension without modification\nfunction Shape() {}\nShape.prototype.computeArea = function() { throw new Error('Must be implemented in subclasses'); };\n\nfunction Rectangle(width, height) {\n    this.width = width;\n    this.height = height;\n}\nRectangle.prototype = Object.create(Shape.prototype);\nRectangle.prototype.computeArea = function() {\n    return this.width * this.height;\n};\n"},{"title":"Bad Example (ES6)","code":"// Bad example (ES6): Modifying existing ES6 class methods to add new functionality\nclass AreaCalculator {\n    computeArea(shape) {\n        if (shape instanceof Rectangle) {\n            return shape.width * shape.height;\n        } else if (shape instanceof Circle) {\n            return 3.14 * shape.radius * shape.radius;\n        }\n    }\n}\n"},{"title":"Bad Example (ES5)","code":"// Bad example (ES5): Modifying existing code to add new functionality\nfunction AreaCalculator(shape) {\n    if (shape.type === 'rectangle') {\n        return shape.width * shape.height;\n    } else if (shape.type === 'circle') {\n        return 3.14 * shape.radius * shape.radius;\n    }\n}\n"}]},{"title":"Liskov Substitution","examples":[{"title":"Good Example (ES6)","code":"// Good example (ES6): Using ES6 classes to ensure derived classes maintain the behavior of the base class\nclass Bird {\n    fly() { /* ... */ }\n}\n\nclass Sparrow extends Bird {\n    fly() { /* ... */ }  // Sparrow, being a Bird, can fly\n}\n"},{"title":"Good Example (ES5)","code":"// Good example (ES5): Using function constructors and prototype inheritance\nfunction Bird() {}\nBird.prototype.fly = function() { /* ... */ };\n\nfunction Sparrow() {}\nSparrow.prototype = Object.create(Bird.prototype);\n"},{"title":"Bad Example (ES6)","code":"// Bad example (ES6): Using ES6 classes where the derived class changes the behavior of the base class\nclass Bird {\n    fly() { /* ... */ }\n}\n\nclass Ostrich extends Bird {\n    fly() {\n        throw new Error(\"Can't fly\");  // Ostrich, being a Bird, should not alter the expected behavior of the fly method\n    }\n}\n"},{"title":"Bad Example (ES5)","code":"// Bad example (ES5): Using function constructors where the derived class alters the base class behavior\nfunction Bird() {}\nBird.prototype.fly = function() { /* ... */ };\n\nfunction Ostrich() {}\nOstrich.prototype = Object.create(Bird.prototype);\nOstrich.prototype.fly = function() {\n    throw new Error(\"Can't fly\");\n}\n"}]},{"title":"Interface Segregation","examples":[{"title":"Good Example (ES6)","code":"// Good example (ES6): Using ES6 classes to provide specific interfaces\nclass Worker {\n    work() { /* ... */ }\n}\n\nclass Feeder {\n    eat() { /* ... */ }\n}\n\nclass Human extends Worker {}\nclass Robot extends Worker {}\n\nclass Animal extends Feeder {}\n"},{"title":"Good Example (ES5)","code":"// Good example (ES5): Using function constructors to segregate interfaces\nfunction Worker() {}\nWorker.prototype.work = function() { /* ... */ };\n\nfunction Feeder() {}\nFeeder.prototype.eat = function() { /* ... */ };\n\nfunction Human() {}\nHuman.prototype = Object.create(Worker.prototype);\n\nfunction Robot() {}\nRobot.prototype = Object.create(Worker.prototype);\n\nfunction Animal() {}\nAnimal.prototype = Object.create(Feeder.prototype);\n"},{"title":"Bad Example (ES6)","code":"// Bad example (ES6): Using a single ES6 class that does not segregate interfaces\nclass Worker {\n    work() { /* ... */ }\n    eat() { /* ... */ }  // This method should not be part of the Worker interface\n}\n"},{"title":"Bad Example (ES5)","code":"// Bad example (ES5): Using a single function constructor that does not segregate interfaces\nfunction Worker() {}\nWorker.prototype.work = function() { /* ... */ };\nWorker.prototype.eat = function() { /* ... */ };  // This method should not be part of the Worker interface\n"}]},{"title":"Dependency Inversion","examples":[{"title":"Good Example (ES6)","code":"// Good example (ES6): Using ES6 classes with both high-level and low-level modules depending on abstractions\nclass Switch {\n    constructor(device) {\n        this.device = device;\n    }\n    operate() {\n        this.device.turnOn();\n    }\n}\n\nclass Fan {\n    turnOn() { /* ... */ }\n}\n\nconst wallSwitch = new Switch(new Fan());\n"},{"title":"Good Example (ES5)","code":"// Good example (ES5): Using function constructors and prototype inheritance for dependency inversion\nfunction Switch(device) {\n    this.device = device;\n}\nSwitch.prototype.operate = function() {\n    this.device.turnOn();\n};\n\nfunction Fan() {}\nFan.prototype.turnOn = function() { /* ... */ };\n\nconst wallSwitch = new Switch(new Fan());\n"},{"title":"Bad Example (ES6)","code":"// Bad example (ES6): Using ES6 classes where the high-level module depends directly on a low-level module\nclass LightBulb {\n    turnOn() { /* ... */ }\n}\n\nclass Switch {\n    constructor() {\n        this.bulb = new LightBulb();\n    }\n    operate() {\n        this.bulb.turnOn();\n    }\n}\n"},{"title":"Bad Example (ES5)","code":"// Bad example (ES5): Using function constructors where the high-level module has a direct dependency on the low-level module\nfunction LightBulb() {}\nLightBulb.prototype.turnOn = function() { /* ... */ };\n\nfunction Switch() {\n    this.bulb = new LightBulb();\n}\nSwitch.prototype.operate = function() {\n    this.bulb.turnOn();\n};\n"}]}],"principles_other":[{"title":"Don't Repeat Yourself (DRY)","examples":[{"title":"Good Example (ES6)","code":"// Good example (ES6): Using default parameters and arrow functions for repeated logic\nconst addTax = (price, rate = 0.05) => price + (price * rate);\n"},{"title":"Good Example (ES5)","code":"// Good example (ES5): Reusing a single function to avoid duplicated logic\nfunction addTax(price, rate) {\n    rate = rate || 0.05;\n    return price + (price * rate);\n}\n"},{"title":"Bad Example (ES6)","code":"// Bad example (ES6): Repeated logic in separate arrow functions\nconst addTaxForFood = (price) => price + (price * 0.05);\nconst addTaxForElectronics = (price) => price + (price * 0.05);\n"},{"title":"Bad Example (ES5)","code":"// Bad example (ES5): Repeated logic in separate functions\nfunction addTaxForFood(price) {\n    return price + (price * 0.05);\n}\n\nfunction addTaxForElectronics(price) {\n    return price + (price * 0.05);\n}\n"}]},{"title":"Keep It Simple Stupid (KISS)","examples":[{"title":"Good Example (ES6)","code":"// Good example (ES6): Simplified approach using arrow function\nconst isEven = num => num % 2 === 0;\n"},{"title":"Good Example (ES5)","code":"// Good example (ES5): Straightforward function to check even numbers\nfunction isEven(num) {\n    return num % 2 === 0;\n}\n"},{"title":"Bad Example (ES6)","code":"// Bad example (ES6): Overcomplicated check using arrow function\nconst isEven = num => num % Math.abs(2) === 0;\n"},{"title":"Bad Example (ES5)","code":"// Bad example (ES5): Overcomplicated way to check even numbers\nfunction isEven(num) {\n    return num % Math.abs(2) === 0;\n}\n"}]},{"title":"You Aren't Gonna Need It (YAGNI)","examples":[{"title":"Good Example (ES6)","code":"// Good example (ES6): Implementing only the needed methods using classes\nclass Car {\n    drive() { /* ... */ }\n}\n"},{"title":"Good Example (ES5)","code":"// Good example (ES5): Implementing only the needed methods using function constructor\nfunction Car() {}\nCar.prototype.drive = function() { /* ... */ };\n"},{"title":"Bad Example (ES6)","code":"// Bad example (ES6): Adding unnecessary features using classes\nclass Car {\n    drive() { /* ... */ }\n    fly() { /* ... */ }  // Cars don't fly!\n}\n"},{"title":"Bad Example (ES5)","code":"// Bad example (ES5): Adding unnecessary features using function constructor\nfunction Car() {}\nCar.prototype.drive = function() { /* ... */ };\nCar.prototype.fly = function() { /* ... */ };  // Cars don't fly!\n"}]},{"title":"Law of Demeter (Principle of Least Knowledge)","examples":[{"title":"Good Example (ES6)","code":"// Good example (ES6): Using classes for encapsulation\nclass Wallet {\n    constructor() {\n        this._money = 100;\n    }\n    getAmount() {\n        return this._money;\n    }\n}\n\nclass Person {\n    constructor() {\n        this.wallet = new Wallet();\n    }\n    getMoneyAmount() {\n        return this.wallet.getAmount();\n    }\n}\n\nfunction purchase(item, buyer) {\n    if (buyer.getMoneyAmount() >= item.price) { /* ... */ }\n}\n"},{"title":"Good Example (ES5)","code":"// Good example (ES5): Using function constructors for encapsulation\nfunction Wallet() {\n    this._money = 100;\n}\nWallet.prototype.getAmount = function() {\n    return this._money;\n}\n\nfunction Person() {\n    this.wallet = new Wallet();\n}\nPerson.prototype.getMoneyAmount = function() {\n    return this.wallet.getAmount();\n}\n\nfunction purchase(item, buyer) {\n    if (buyer.getMoneyAmount() >= item.price) { /* ... */ }\n}\n"},{"title":"Bad Example (ES6)","code":"// Bad example (ES6): Accessing nested structures directly using classes\nclass Wallet {\n    constructor() {\n        this.money = { amount: 100 };\n    }\n}\n\nclass Person {\n    constructor() {\n        this.wallet = new Wallet();\n    }\n}\n\nfunction purchase(item, buyer) {\n    if (buyer.wallet.money.amount >= item.price) { /* ... */ }\n}\n"},{"title":"Bad Example (ES5)","code":"// Bad example (ES5): Accessing nested structures directly using function constructors\nfunction Wallet() {\n    this.money = { amount: 100 };\n}\n\nfunction Person() {\n    this.wallet = new Wallet();\n}\n\nfunction purchase(item, buyer) {\n    if (buyer.wallet.money.amount >= item.price) { /* ... */ }\n}\n"}]},{"title":"Separation of Concerns","examples":[{"title":"Good Example (ES6)","code":"// Good example (ES6): Separating concerns into different classes\nclass UserDataService {\n    fetchUserData() { /* ... */ }\n}\n\nclass UserLogic {\n    calculateAge() { /* ... */ }\n}\n\nclass UserComponent {\n    render() { /* ... */ }\n}\n"},{"title":"Good Example (ES5)","code":"// Good example (ES5): Separating concerns into different function constructors\nfunction UserDataService() {}\nUserDataService.prototype.fetchUserData = function() { /* ... */ }\n\nfunction UserLogic() {}\nUserLogic.prototype.calculateAge = function() { /* ... */ }\n\nfunction UserComponent() {}\nUserComponent.prototype.render = function() { /* ... */ }\n"},{"title":"Bad Example (ES6)","code":"// Bad example (ES6): Mixing data retrieval, logic, and presentation in one class\nclass UserComponent {\n    fetchUserData() { /* ... */ }\n    render() { /* ... */ }\n    calculateAge() { /* ... */ }\n}\n"},{"title":"Bad Example (ES5)","code":"// Bad example (ES5): Mixing data retrieval, logic, and presentation in one function constructor\nfunction UserComponent() {}\nUserComponent.prototype.fetchUserData = function() { /* ... */ }\nUserComponent.prototype.render = function() { /* ... */ }\nUserComponent.prototype.calculateAge = function() { /* ... */ }\n"}]}],"principles_proprietary":[{"title":"Dynamic Typing","description":[{"variant":"subtitle1","content":"JavaScript is a loosely typed or a dynamic language. Variables are not directly associated with any particular value type, and any variable can be assigned and re-assigned values of all types.\n"}],"examples":[{"title":"Dynamic Typing Example","code":"let data = 42; // data is now a number\ndata = 'hello'; // data is now a string\ndata = true; // data is now a boolean\n"}]},{"title":"Prototype-based Object Orientation","description":[{"variant":"subtitle1","content":"Instead of classical inheritance, JavaScript uses prototypes. Each object has a private property which holds a link to another object called its prototype.\n"}],"examples":[{"title":"Prototype-based Inheritance Example","code":"function Person(firstName) {\n  this.firstName = firstName;\n}\nPerson.prototype.sayHello = function() {\n  return \"Hello, I'm \" + this.firstName;\n};\nconst john = new Person(\"John\");\nconsole.log(john.sayHello()); // \"Hello, I'm John\"\n"}]},{"title":"First-Class Functions","description":[{"variant":"subtitle1","content":"In JavaScript, functions are first-class objects. They can be stored in variables, passed as arguments to other functions, returned from those functions, and have their own properties and methods.\n"}],"examples":[{"title":"First-Class Functions Example","code":"function greet() {\n  return \"Hello World!\";\n}\nlet greetMsg = greet; // Assigning function to variable\nconsole.log(greetMsg()); // \"Hello World!\"\n"}]},{"title":"Event-Driven Programming","description":[{"variant":"subtitle1","content":"JavaScript is heavily used in web browsers where the flow of the program is determined by events such as user actions (clicks, keyboard events, etc).\n"}],"examples":[{"title":"Event-Driven Programming Example","code":"document.getElementById(\"myBtn\").addEventListener(\"click\", displayDate);\nfunction displayDate() {\n  document.getElementById(\"demo\").innerHTML = Date();\n}\n"}]},{"title":"Asynchronous Programming","description":[{"variant":"subtitle1","content":"With features like callbacks, promises, and async/await, JavaScript handles asynchronous operations. This is especially useful for operations like fetching data from a server without blocking the main thread.\n"}],"examples":[{"title":"Asynchronous Programming Example","code":"async function fetchData() {\n  let response = await fetch('https://api.example.com/data');\n  let data = await response.json();\n  console.log(data);\n}\nfetchData();\n"}]},{"title":"Closure","description":[{"variant":"subtitle1","content":"Functions in JavaScript form closures. A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (lexical environment).\n"}],"examples":[{"title":"Closure Example","code":"function makeAdder(x) {\n  return function(y) {\n    return x + y;\n  };\n}\nlet add5 = makeAdder(5);\nconsole.log(add5(2));  // 7\n"}]},{"title":"Single-Threaded with Non-blocking I/O","description":[{"variant":"subtitle1","content":"JavaScript is single-threaded, but it uses asynchronous callbacks and an event loop to handle concurrency.\n"}],"examples":[{"title":"Non-blocking I/O Example","code":"console.log('First');\nsetTimeout(function() {\n  console.log('Second');\n}, 0);\nconsole.log('Third');\n// Output: First, Third, Second\n"}]},{"title":"Truthy and Falsy Values","description":[{"variant":"subtitle1","content":"In JavaScript, values are considered either \"truthy\" or \"falsy\", not just true or false. This affects flow control and operations in ways that can be peculiar compared to other languages.\n"}],"examples":[{"title":"Truthy and Falsy Example","code":"if ('') console.log('Falsy!');\nif ('hello') console.log('Truthy!');\n// Output: Truthy!\n"}]},{"title":"Template Literals","description":[{"variant":"subtitle1","content":"JavaScript allows for string interpolation and multi-line strings in a more readable fashion with template literals.\n"}],"examples":[{"title":"Template Literals Example","code":"const name = \"world\";\nconsole.log(`Hello, ${name}!`); // Hello, world!\n"}]},{"title":"ES6 and Beyond","description":[{"variant":"subtitle1","content":"The ECMAScript 2016 (ES6) and later versions brought many additions and improvements, like classes, enhanced object literals, default parameters, destructuring, spread operator, and more, influencing how JavaScript is written.\n"}],"examples":[{"title":"ES6 Features Example","code":"class Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  speak() {\n    console.log(`${this.name} makes a noise.`);\n  }\n}\nclass Dog extends Animal {\n  speak() {\n    console.log(`${this.name} barks.`);\n  }\n}\nlet dog = new Dog('Rex');\ndog.speak(); // Rex barks.\n"}]}]}}