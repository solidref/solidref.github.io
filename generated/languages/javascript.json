{"name":"JavaScript (ECMAScript)","code":"javascript","ext":"js","birth":1995,"death":"N/A","inspiredBy":["awk","hypertalk","java","perl","python","self","scheme"],"inspiring":["typescript","coffeescript","dart","elm"],"description":"A key technology of the World Wide Web, JavaScript is an essential language for front-end web development,\nenabling interactive web pages. It's also used in server-side development (Node.js, Deno, and Bun). As a multi-paradigm language,\nit supports event-driven, functional, and imperative programming styles. It has dynamic typing and supports object-oriented programming.\nJavaScript has seen significant evolution since its inception, particularly with the introduction of ECMAScript 6 (ES6) in 2015,\nwhich brought major syntactic improvements and features like classes, modules, arrow functions, and template literals.\n","patterns":{"patterns_behavioural":[{"title":"Chain Of Responsibility","examples":[{"codeFile":"patterns/behavioural/chain-of-responsibility/example","code":"class Level1Support {\n  constructor() {\n    this.nextHandler = null;\n  }\n\n  setNextHandler(handler) {\n    this.nextHandler = handler;\n  }\n\n  handleRequest(request) {\n    if (request.includes('basic')) {\n      return 'Level 1 Support: Issue resolved at basic level.';\n    } else if (this.nextHandler) {\n      return this.nextHandler.handleRequest(request);\n    } else {\n      return null; // No more handlers in the chain\n    }\n  }\n}\n\nclass Level2Support {\n  constructor() {\n    this.nextHandler = null;\n  }\n\n  setNextHandler(handler) {\n    this.nextHandler = handler;\n  }\n\n  handleRequest(request) {\n    if (request.includes('advanced')) {\n      return 'Level 2 Support: Issue resolved at advanced level.';\n    } else if (this.nextHandler) {\n      return this.nextHandler.handleRequest(request);\n    } else {\n      return null; // No more handlers in the chain\n    }\n  }\n}\n\nclass Level3Support {\n  constructor() {\n    this.nextHandler = null; // Level 3 does not technically need this, but added for consistency\n  }\n\n  handleRequest(request) {\n    if (request.includes('bug')) {\n      return 'Level 3 Support: Issue resolved at development level.';\n    } else {\n      return 'Level 3 Support: Unable to resolve the issue.';\n    }\n  }\n\n  setNextHandler() {\n    throw new Error('Level 3 Support is the highest level and does not have a next handler.');\n  }\n}\n\n// Client code\nfunction main() {\n  const level1 = new Level1Support();\n  const level2 = new Level2Support();\n  const level3 = new Level3Support();\n\n  level1.setNextHandler(level2);\n  level2.setNextHandler(level3);\n\n  console.log(level1.handleRequest('Fix basic login issue')); // Output: Level 1 Support: Issue resolved at basic level.\n  console.log(level1.handleRequest('Debug advanced performance problem')); // Output: Level 2 Support: Issue resolved at advanced level.\n  console.log(level1.handleRequest('Investigate bug causing application crash')); // Output: Level 3 Support: Issue resolved at development level.\n}\n\nmain();\n\n\n/**\n * This code demonstrates how the Chain of Responsibility pattern can be used in a support\n * ticket system. The SupportHandler interface defines the contract for handling support\n * requests, and concrete implementations (Level1Support, Level2Support, and Level3Support)\n * represent different levels of support. Each handler decides whether it can handle a\n * request or should pass it to the next handler in the chain.\n */\n"}]},{"title":"Command","examples":[{"codeFile":"patterns/behavioural/command/example","code":"// Command interface\nclass Command {\n  execute() { }\n}\n\n// Concrete Command\nclass TurnOnCommand extends Command {\n  constructor(receiver) {\n    super();\n    this.receiver = receiver;\n  }\n\n  execute() {\n    this.receiver.turnOn();\n  }\n}\n\nclass TurnOffCommand extends Command {\n  constructor(receiver) {\n    super();\n    this.receiver = receiver;\n  }\n\n  execute() {\n    this.receiver.turnOff();\n  }\n}\n\n// Receiver\nclass Light {\n  turnOn() {\n    console.log(\"The light is on\");\n  }\n\n  turnOff() {\n    console.log(\"The light is off\");\n  }\n}\n\n// Invoker\nclass RemoteControl {\n  submit(command) {\n    command.execute();\n  }\n}\n\n// Client code\nconst light = new Light();\nconst turnOnCommand = new TurnOnCommand(light);\nconst turnOffCommand = new TurnOffCommand(light);\n\nconst remote = new RemoteControl();\nremote.submit(turnOnCommand); // The light is on\nremote.submit(turnOffCommand); // The light is off\n\n/**\n * This code demonstrates how the Command pattern can be used in a remote control\n * system to control a light. The Command interface defines the contract for executing\n * commands, and concrete command classes (TurnOnCommand and TurnOffCommand) encapsulate\n * the actions to be performed on the Light receiver object. The RemoteControl acts as\n * the invoker, which holds and triggers the commands. Pressing buttons on the remote\n * control executes the corresponding commands, resulting in the light being turned on\n * and off.\n */\n"}]},{"title":"Iterator","examples":[{"codeFile":"patterns/behavioural/iterator/example","code":"class Iterator {\n  constructor(collection) {\n    this.collection = collection;\n    this.index = 0;\n  }\n\n  next() {\n    if (this.hasNext()) {\n      return this.collection[this.index++];\n    } else {\n      return undefined;\n    }\n  }\n\n  hasNext() {\n    return this.index < this.collection.length;\n  }\n}\n\n// Client code\nconst items = [1, 'two', 3, 'four', 5];\nconst iterator = new Iterator(items);\n\nwhile (iterator.hasNext()) {\n  console.log(iterator.next());\n}\n\n/**\n * In this example, the Iterator pattern is used to iterate over a collection of books\n * stored in a BookCollection. The Iterator interface defines methods for checking if\n * there are more elements (hasNext) and retrieving the next element (next). The\n * ArrayIterator class provides a concrete implementation of the iterator for an array\n * of books. The BookCollection class implements the Iterable interface, which allows\n * it to create iterators for iterating over its collection of books. Finally, in the\n * client code, we create a BookCollection, add books to it, and iterate over the\n * collection using the iterator, printing each book's name.\n */\n"}]},{"title":"Mediator","examples":[{"codeFile":"patterns/behavioural/mediator/example","code":"// Concrete Mediator implementation for a chat room\nclass ChatRoom {\n  sendMessage(message, user) {\n    console.log(`[${user.getName()}] sends message: ${message}`);\n  }\n}\n\n// Concrete Colleague implementation for a chat user\nclass ChatUser {\n  constructor(name, mediator) {\n    this.name = name;\n    this.mediator = mediator;\n  }\n\n  send(message) {\n    console.log(`[${this.name}] sends message: ${message}`);\n    this.mediator.sendMessage(message, this);\n  }\n\n  receive(message) {\n    console.log(`[${this.name}] received message: ${message}`);\n  }\n\n  getName() {\n    return this.name;\n  }\n}\n\n// Client code\nfunction main() {\n  // Create a chat room mediator\n  const chatMediator = new ChatRoom();\n\n  // Create chat users\n  const user1 = new ChatUser('User1', chatMediator);\n  const user2 = new ChatUser('User2', chatMediator);\n\n  // Send messages between users\n  user1.send('Hello, User2!');\n  user2.send('Hi, User1!');\n}\n\nmain();\n\n/**\n * In this example, the Mediator pattern is used to facilitate communication between\n * users in a chat room. The ChatMediator interface defines a method sendMessage for\n * sending messages to users. The ChatRoom class provides a concrete implementation\n * of the mediator for managing communication between users in the chat room.\n *\n * The User interface defines methods send and receive for sending and receiving messages,\n * respectively, as well as a method getName for getting the user's name. The ChatUser\n * class implements the User interface and interacts with the mediator to send and\n * receive messages.\n *\n * In the client code, we create a chat room mediator and two chat users. Users can send\n * messages to each other by calling the send method, which delegates the message sending\n * to the mediator. When a message is received, the mediator distributes it to the\n * appropriate user's receive method.\n */\n"}]},{"title":"Memento","examples":[{"codeFile":"patterns/behavioural/memento/example","code":"// Originator class represents the object whose state needs to be saved and restored\nclass Editor {\n  constructor(text) {\n    this.text = text;\n  }\n\n  setText(text) {\n    this.text = text;\n  }\n\n  getText() {\n    return this.text;\n  }\n\n  // Creates a memento containing the current state of the editor\n  save() {\n    return new Memento(this.text);\n  }\n\n  // Restores the editor's state from a memento\n  restore(memento) {\n    this.text = memento.getState();\n  }\n}\n\n// Memento class represents the stored state of the editor\nclass Memento {\n  constructor(state) {\n    this.state = state;\n  }\n\n  getState() {\n    return this.state;\n  }\n}\n\n// Caretaker class is responsible for keeping track of multiple mementos\nclass History {\n  constructor() {\n    this.mementos = [];\n  }\n\n  // Adds a memento to the history\n  addMemento(memento) {\n    this.mementos.push(memento);\n  }\n\n  // Retrieves the most recent memento from the history\n  getLatestMemento() {\n    if (this.mementos.length === 0) {\n      throw new Error(\"No mementos available\");\n    }\n    return this.mementos[this.mementos.length - 1];\n  }\n}\n\n// Client code\nfunction main() {\n  const editor = new Editor(\"Initial text\");\n\n  // Create a history to store mementos\n  const history = new History();\n\n  // Add a memento to the history\n  history.addMemento(editor.save());\n\n  // Modify the text\n  editor.setText(\"Modified text\");\n\n  // Add another memento to the history\n  history.addMemento(editor.save());\n\n  // Restore the editor's state to a previous memento\n  editor.restore(history.getLatestMemento());\n\n  console.log(editor.getText()); // Output: Modified text (restored from the previous state)\n}\n\nmain();\n\n/**\n * In this example, the Editor class represents an object whose state can be modified. The save\n * method creates a memento containing the current state of the editor, and the restore method\n * restores the editor's state from a given memento.\n *\n * The Memento class represents the stored state of the editor at a particular point in time.\n *\n * The History class is responsible for maintaining a list of mementos. It provides methods\n * to add a memento to the history and retrieve the most recent memento.\n *\n * In the client code, we create an editor object and a history object. We modify the editor's\n * state, save it to a memento, modify it again, and then restore it to the previous state using\n * the memento stored in the history.\n */\n"}]},{"title":"Observer","examples":[{"codeFile":"patterns/behavioural/observer/example","code":"class ConcreteSubject {\n  constructor() {\n    this.observers = [];\n  }\n\n  subscribe(observer) {\n    this.observers.push(observer);\n  }\n\n  unsubscribe(observer) {\n    const index = this.observers.indexOf(observer);\n    if (index > -1) {\n      this.observers.splice(index, 1);\n    }\n  }\n\n  notify(data) {\n    this.observers.forEach(observer => observer.update(data));\n  }\n}\n\nclass ConcreteObserver {\n  update(data) {\n    console.log(`Observer received data: ${data}`);\n  }\n}\n\n// Client code\nconst subject = new ConcreteSubject();\nconst observer1 = new ConcreteObserver();\nconst observer2 = new ConcreteObserver();\n\nsubject.subscribe(observer1);\nsubject.subscribe(observer2);\n\nsubject.notify('Hello Observers!');\n\nsubject.unsubscribe(observer2);\nsubject.notify('Goodbye Observers!');\n\n/**\n * In this example, the Editor class represents an object whose state can be modified.\n * The save method creates a memento containing the current state of the editor, and\n * the restore method restores the editor's state from a given memento.\n *\n * The Memento class represents the stored state of the editor at a particular point in time.\n * The History class is responsible for maintaining a list of mementos. It provides\n * methods to add a memento to the history and retrieve the most recent memento.\n *\n * In the client code, we create an editor object and a history object. We modify the\n * editor's state, save it to a memento, modify it again, and then restore it to the\n * previous state using the memento stored in the history.\n */\n"}]},{"title":"State","examples":[{"codeFile":"patterns/behavioural/state/example","code":"class RedState {\n  changeState(trafficLight) {\n    console.log(\"Traffic light is now RED. Stop!\");\n    setTimeout(() => {\n      trafficLight.setState(new YellowState());\n    }, 3000);\n  }\n}\n\nclass YellowState {\n  changeState(trafficLight) {\n    console.log(\"Traffic light is now YELLOW. Prepare to stop or proceed with caution.\");\n    setTimeout(() => {\n      trafficLight.setState(new GreenState());\n    }, 2000);\n  }\n}\n\nclass GreenState {\n  changeState(trafficLight) {\n    console.log(\"Traffic light is now GREEN. Go!\");\n    setTimeout(() => {\n      trafficLight.setState(new RedState());\n    }, 4000);\n  }\n}\n\nclass TrafficLight {\n  constructor() {\n    this.state = new RedState();\n    this.state.changeState(this); // Start with the initial state\n  }\n\n  setState(state) {\n    this.state = state;\n    this.state.changeState(this);\n  }\n}\n\n// Client code\nfunction main() {\n  const trafficLight = new TrafficLight();\n  // The initial state will automatically transition due to the state behavior\n}\n\nmain();\n\n/**\n * The TrafficLightState interface defines the common behavior for all traffic light states.\n * Each concrete state implements this interface and provides its own implementation of the\n * changeState method.\n *\n * Concrete state classes (RedState, YellowState, and GreenState) represent different states\n * of the traffic light and define how the traffic light behaves in each state.\n *\n * The TrafficLight class acts as the context and maintains a reference to the current state.\n * It provides a method setState to change the state of the traffic light.\n *\n * In the client code, we create a TrafficLight object and change its state to simulate the\n * behavior of a traffic light system.\n */\n"}]},{"title":"Strategy","examples":[{"codeFile":"patterns/behavioural/strategy/example","code":"// Concrete strategy for processing payments via credit card\nclass CreditCardPaymentStrategy {\n  constructor(cardNumber, expiryDate, cvv) {\n    this.cardNumber = cardNumber;\n    this.expiryDate = expiryDate;\n    this.cvv = cvv;\n  }\n\n  pay(amount) {\n    console.log(`Processing credit card payment of $${amount} with card number ${this.cardNumber}`);\n    // Logic to process payment via credit card\n  }\n}\n\n// Concrete strategy for processing payments via PayPal\nclass PayPalPaymentStrategy {\n  constructor(email, password) {\n    this.email = email;\n    this.password = password;\n  }\n\n  pay(amount) {\n    console.log(`Processing PayPal payment of $${amount} with email ${this.email}`);\n    // Logic to process payment via PayPal\n  }\n}\n\n// Context class representing the payment processor\nclass PaymentProcessor {\n  setPaymentStrategy(paymentStrategy) {\n    this.paymentStrategy = paymentStrategy;\n  }\n\n  processPayment(amount) {\n    if (this.paymentStrategy) {\n      this.paymentStrategy.pay(amount);\n    } else {\n      console.log(\"Payment strategy not set. Please select a payment method.\");\n    }\n  }\n}\n\n// Client code\nfunction main() {\n  const paymentProcessor = new PaymentProcessor();\n\n  // Select a payment method (strategy) dynamically\n  const creditCardStrategy = new CreditCardPaymentStrategy(\"1234 5678 9012 3456\", \"12/25\", \"123\");\n  paymentProcessor.setPaymentStrategy(creditCardStrategy);\n  paymentProcessor.processPayment(100);\n\n  // Change payment method (strategy)\n  const payPalStrategy = new PayPalPaymentStrategy(\"example@example.com\", \"password\");\n  paymentProcessor.setPaymentStrategy(payPalStrategy);\n  paymentProcessor.processPayment(50);\n}\n\nmain();\n\n/**\n * The PaymentStrategy interface defines the common behavior for all payment strategies. Each concrete payment\n * strategy class implements this interface and provides its own implementation of the pay method.\n *\n * Concrete strategy classes (CreditCardPaymentStrategy and PayPalPaymentStrategy) represent different payment\n * methods and define how payments are processed for each method.\n *\n * The PaymentProcessor class acts as the context and maintains a reference to the current payment strategy.\n * It provides a setter method setPaymentStrategy to dynamically set the payment strategy, and a processPayment\n * method to process payments using the selected strategy.\n *\n * In the client code, we create a PaymentProcessor object and dynamically select the payment method (strategy)\n * based on user input. We then process payments using the selected strategy.\n *\n */\n"}]},{"title":"Template Method","examples":[{"codeFile":"patterns/behavioural/template-method/example","code":"class Breakfast {\n  // Template method\n  prepare() {\n    this.boilWater();\n    this.addIngredients();\n    this.cook();\n    this.serve();\n  }\n\n  // Placeholder methods for steps that will vary\n  addIngredients() {\n    throw new Error('Method \"addIngredients()\" must be implemented.');\n  }\n\n  cook() {\n    throw new Error('Method \"cook()\" must be implemented.');\n  }\n\n  // Concrete methods\n  boilWater() {\n    console.log(\"Boiling water...\");\n  }\n\n  serve() {\n    console.log(\"Breakfast is served!\");\n  }\n}\n\nclass OmeletteBreakfast extends Breakfast {\n  addIngredients() {\n    console.log(\"Adding eggs, cheese, and vegetables to the pan.\");\n  }\n\n  cook() {\n    console.log(\"Cooking the omelette until golden brown.\");\n  }\n}\n\nclass PancakeBreakfast extends Breakfast {\n  addIngredients() {\n    console.log(\"Mixing flour, eggs, milk, and sugar to make the batter.\");\n  }\n\n  cook() {\n    console.log(\"Pouring the batter onto the griddle and flipping until cooked.\");\n  }\n}\n\n// Client code\nconsole.log(\"Preparing Omelette Breakfast:\");\nconst omeletteBreakfast = new OmeletteBreakfast();\nomeletteBreakfast.prepare();\n\nconsole.log(\"\\nPreparing Pancake Breakfast:\");\nconst pancakeBreakfast = new PancakeBreakfast();\npancakeBreakfast.prepare();\n\n/**\n * In this example, we have an abstract class Breakfast representing the template method pattern. It defines\n * the steps of preparing breakfast in the prepare() method, which serves as the template method. The abstract\n * methods addIngredients() and cook() are placeholders for the specific steps that vary between different\n * types of breakfasts.\n *\n * Subclasses such as OmeletteBreakfast and PancakeBreakfast extend the Breakfast class and implement the\n * abstract methods to provide specific implementations for adding ingredients and cooking. The template\n * method prepare() orchestrates the sequence of steps required to prepare each type of breakfast.\n *\n */\n"}]},{"title":"Visitor","examples":[{"codeFile":"patterns/behavioural/visitor/example","code":"// Concrete visitor implementing the operations on animals\nclass AnimalFeeder {\n  visitLion(lion) {\n    console.log(`Feeding meat to ${lion.getName()}.`);\n  }\n\n  visitElephant(elephant) {\n    console.log(`Feeding hay to ${elephant.getName()}.`);\n  }\n\n  visitGiraffe(giraffe) {\n    console.log(`Feeding leaves to ${giraffe.getName()}.`);\n  }\n}\n\n// Concrete elements representing different types of animals\nclass Lion {\n  constructor(name) {\n    this.name = name;\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  accept(visitor) {\n    visitor.visitLion(this);\n  }\n}\n\nclass Elephant {\n  constructor(name) {\n    this.name = name;\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  accept(visitor) {\n    visitor.visitElephant(this);\n  }\n}\n\nclass Giraffe {\n  constructor(name) {\n    this.name = name;\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  accept(visitor) {\n    visitor.visitGiraffe(this);\n  }\n}\n\n// Object structure containing the collection of animals\nclass Zoo {\n  constructor() {\n    this.animals = [];\n  }\n\n  addAnimal(animal) {\n    this.animals.push(animal);\n  }\n\n  // Perform the operation defined by the visitor on each animal\n  performOperation(visitor) {\n    this.animals.forEach(animal => animal.accept(visitor));\n  }\n}\n\n// Client code\nconst zoo = new Zoo();\nzoo.addAnimal(new Lion(\"Simba\"));\nzoo.addAnimal(new Elephant(\"Dumbo\"));\nzoo.addAnimal(new Giraffe(\"Melman\"));\n\nconst feeder = new AnimalFeeder();\nzoo.performOperation(feeder);\n\n/**\n * The AnimalVisitor interface defines the operations that can be performed on different types of animals.\n *\n * The AnimalFeeder class is a concrete visitor that implements feeding operations for lions, elephants,\n * and giraffes.\n *\n * The Animal interface represents animals, and concrete animal classes (Lion, Elephant, and Giraffe)\n * implement this interface and define how they accept a visitor.\n *\n * The Zoo class represents the object structure that contains a collection of animals. It has methods to\n * add animals and perform an operation (feeding in this case) using a visitor.\n *\n * Finally, in the client code, we create a zoo, add animals to it, create a visitor (animal feeder), and\n * then perform the feeding operation on each animal in the zoo using the visitor.\n */\n"}]}],"patterns_creational":[{"title":"Factory Method","examples":[{"codeFile":"patterns/creational/factory-method/example","code":"// Concrete Products: Car and Truck\nclass Car {\n  drive() {\n    console.log(\"Driving a car...\");\n  }\n}\n\nclass Truck {\n  drive() {\n    console.log(\"Driving a truck...\");\n  }\n}\n\n// Creator: VehicleFactory\nclass VehicleFactory {\n  // Factory Method\n  createVehicle() {\n    throw new Error(\"This method should be overridden.\");\n  }\n\n  // An operation that uses the factory method\n  deliverVehicle() {\n    const vehicle = this.createVehicle();\n    console.log(\"Delivering the vehicle...\");\n    vehicle.drive();\n  }\n}\n\n// Concrete Creators: CarFactory and TruckFactory\nclass CarFactory extends VehicleFactory {\n  // Factory Method implementation for creating a car\n  createVehicle() {\n    console.log(\"Creating a car...\");\n    return new Car();\n  }\n}\n\nclass TruckFactory extends VehicleFactory {\n  // Factory Method implementation for creating a truck\n  createVehicle() {\n    console.log(\"Creating a truck...\");\n    return new Truck();\n  }\n}\n\n// Client code\nconst carFactory = new CarFactory();\ncarFactory.deliverVehicle();\n\nconst truckFactory = new TruckFactory();\ntruckFactory.deliverVehicle();\n\n/**\n * The Vehicle interface defines a common interface for all vehicles, which includes a drive() method.\n *\n * The Car and Truck classes are concrete implementations of the Vehicle interface.\n *\n * The VehicleFactory class is an abstract class representing a creator. It declares the createVehicle()\n * method, which serves as the Factory Method for creating vehicles. The deliverVehicle() method is a\n * common operation that uses the Factory Method to create and deliver a vehicle.\n *\n * The CarFactory and TruckFactory classes are concrete implementations of the VehicleFactory class.\n * They override the createVehicle() method to create specific types of vehicles (i.e., cars and trucks).\n *\n */\n"}]},{"title":"Abstract Factory","examples":[{"codeFile":"patterns/creational/abstract-factory/example","code":"// Concrete Factory 1: Modern Furniture Factory\nclass ModernFurnitureFactory {\n  createChair() {\n    return new ModernChair();\n  }\n\n  createTable() {\n    return new ModernTable();\n  }\n}\n\n// Concrete Factory 2: Vintage Furniture Factory\nclass VintageFurnitureFactory {\n  createChair() {\n    return new VintageChair();\n  }\n\n  createTable() {\n    return new VintageTable();\n  }\n}\n\n// Concrete Product: Modern Chair\nclass ModernChair {\n  sitOn() {\n    console.log(\"Sitting on a modern chair.\");\n  }\n}\n\n// Concrete Product: Vintage Chair\nclass VintageChair {\n  sitOn() {\n    console.log(\"Sitting on a vintage chair.\");\n  }\n}\n\n// Concrete Product: Modern Table\nclass ModernTable {\n  putOn() {\n    console.log(\"Putting something on a modern table.\");\n  }\n}\n\n// Concrete Product: Vintage Table\nclass VintageTable {\n  putOn() {\n    console.log(\"Putting something on a vintage table.\");\n  }\n}\n\n// Client code function to create furniture using the provided factory\nfunction createFurniture(factory) {\n  const chair = factory.createChair();\n  const table = factory.createTable();\n\n  console.log(\"Created furniture:\");\n  chair.sitOn();\n  table.putOn();\n}\n\n// Creating modern furniture\nconsole.log(\"Creating modern furniture:\");\ncreateFurniture(new ModernFurnitureFactory());\n\n// Creating vintage furniture\nconsole.log(\"\\nCreating vintage furniture:\");\ncreateFurniture(new VintageFurnitureFactory());\n\n/**\n * The FurnitureFactory interface declares methods for creating chairs and tables.\n *\n * Concrete factories (ModernFurnitureFactory and VintageFurnitureFactory) implement the\n * FurnitureFactory interface to produce modern and vintage furniture, respectively.\n *\n * The Chair interface declares a method for sitting on a chair, and concrete chair classes\n * (ModernChair and VintageChair) implement this interface.\n *\n * The Table interface declares a method for putting something on a table, and concrete table\n * classes (ModernTable and VintageTable) implement this interface.\n * The createFurniture function acts as a client and receives a FurnitureFactory as a parameter.\n * It creates a chair and a table using the factory and then performs actions on the created furniture.\n *\n */\n"}]},{"title":"Builder","examples":[{"codeFile":"patterns/creational/builder/example","code":"class Computer {\n  constructor(cpu = \"\", ram = 0, storage = 0, gpu = \"\", screenSize = 0) {\n    this.cpu = cpu;\n    this.ram = ram;\n    this.storage = storage;\n    this.gpu = gpu;\n    this.screenSize = screenSize;\n  }\n\n  displaySpecs() {\n    console.log(`CPU: ${this.cpu}`);\n    console.log(`RAM: ${this.ram} GB`);\n    console.log(`Storage: ${this.storage} GB`);\n    console.log(`GPU: ${this.gpu}`);\n    console.log(`Screen Size: ${this.screenSize} inches`);\n  }\n}\n\nclass GamingComputerBuilder {\n  constructor() {\n    this.reset();\n  }\n\n  reset() {\n    this.computer = new Computer();\n  }\n\n  setCPU(cpu) {\n    this.computer.cpu = cpu;\n    return this;\n  }\n\n  setRAM(ram) {\n    this.computer.ram = ram;\n    return this;\n  }\n\n  setStorage(storage) {\n    this.computer.storage = storage;\n    return this;\n  }\n\n  setGPU(gpu) {\n    this.computer.gpu = gpu;\n    return this;\n  }\n\n  setScreenSize(screenSize) {\n    this.computer.screenSize = screenSize;\n    return this;\n  }\n\n  getResult() {\n    return this.computer;\n  }\n}\n\nclass ComputerBuilderDirector {\n  constructor(builder) {\n    this.builder = builder;\n  }\n\n  constructGamingComputer() {\n    this.builder.setCPU(\"Intel Core i9\")\n      .setRAM(32)\n      .setStorage(1000)\n      .setGPU(\"NVIDIA GeForce RTX 3080\")\n      .setScreenSize(27);\n  }\n}\n\n// Client code\nconst gamingComputerBuilder = new GamingComputerBuilder();\nconst director = new ComputerBuilderDirector(gamingComputerBuilder);\ndirector.constructGamingComputer();\nconst gamingComputer = gamingComputerBuilder.getResult();\nconsole.log(\"Gaming Computer Specifications:\");\ngamingComputer.displaySpecs();\n\n/**\n * The Computer class represents the product we want to build, which is a custom computer with\n * various specifications like CPU, RAM, storage, GPU, and screen size.\n *\n * The ComputerBuilder interface defines methods for setting each component of the computer.\n *\n * The GamingComputerBuilder class is a concrete builder that implements the ComputerBuilder\n * interface to construct a gaming computer with specific configurations.\n *\n * The ComputerBuilderDirector class is responsible for directing the construction process using\n * a builder.\n *\n * The client code creates a GamingComputerBuilder, passes it to the director, and instructs the\n * director to construct a gaming computer. Finally, it retrieves the constructed gaming computer\n * and displays its specifications.\n *\n */\n"}]},{"title":"Prototype","examples":[{"codeFile":"patterns/creational/prototype/example","code":"// Concrete Prototype: DefaultUserProfile\nclass DefaultUserProfile {\n  constructor(username, bio, profilePicture) {\n    this.username = username;\n    this.bio = bio;\n    this.profilePicture = profilePicture;\n  }\n\n  clone() {\n    // Using Object.assign for a shallow copy, which is sufficient for primitive properties.\n    // For deep cloning, consider using a library or implementing a deeper clone logic.\n    return new DefaultUserProfile(this.username, this.bio, this.profilePicture);\n  }\n\n  customizeProfile(settings) {\n    if (settings.username) {\n      this.username = settings.username;\n    }\n    if (settings.bio) {\n      this.bio = settings.bio;\n    }\n    if (settings.profilePicture) {\n      this.profilePicture = settings.profilePicture;\n    }\n  }\n\n  displayProfile() {\n    console.log(\"Username:\", this.username);\n    console.log(\"Bio:\", this.bio);\n    console.log(\"Profile Picture:\", this.profilePicture);\n  }\n}\n\n// Client code\nconst defaultProfile = new DefaultUserProfile(\"user123\", \"Welcome to my profile!\", \"default.jpg\");\n\n// Clone the default profile to create a customized profile\nconst customizedProfile = defaultProfile.clone();\ncustomizedProfile.customizeProfile({ bio: \"I'm a software developer.\", profilePicture: \"avatar.jpg\" });\n\n// Display both profiles\nconsole.log(\"Default Profile:\");\ndefaultProfile.displayProfile();\n\nconsole.log(\"\\nCustomized Profile:\");\ncustomizedProfile.displayProfile();\n\n/**\n * The UserProfile interface defines methods for cloning a profile, customizing profile settings, and\n * displaying the profile.\n *\n * The DefaultUserProfile class is a concrete implementation of the UserProfile interface. It represents\n * the default user profile with properties like username, bio, and profile picture. The clone()\n * method creates a copy of the profile, and the customizeProfile() method allows modifying profile\n * settings.\n *\n * The UserProfileSettings interface defines optional settings that can be customized in a user profile.\n *\n * In the client code, we create a default user profile and then clone it to create a customized profile\n * with updated settings. Both profiles can be displayed independently, demonstrating the use of the\n * Prototype pattern to create new objects by copying existing ones.\n */\n"}]},{"title":"Singleton","examples":[{"codeFile":"patterns/creational/singleton/example","code":"class Logger {\n  constructor() {\n    if (!Logger.instance) {\n      Logger.instance = this;\n      this.logHistory = [];\n    }\n    return Logger.instance;\n  }\n\n  log(message) {\n    const timestamp = new Date().toISOString();\n    const logEntry = `[${timestamp}] ${message}`;\n    this.logHistory.push(logEntry);\n    console.log(logEntry);\n  }\n\n  getLogHistory() {\n    return this.logHistory;\n  }\n}\n\n// Ensuring the constructor is not callable from outside. In JavaScript, this approach\n// replaces the private constructor concept. The static method or property belongs\n// to the class itself, not to the object of the class.\nLogger.instance = null;\n\n// Client code\nconst logger1 = new Logger();\nconst logger2 = new Logger();\n\nconsole.log(logger1 === logger2); // Output: true, both references point to the same instance\n\nlogger1.log(\"User logged in\");\nlogger2.log(\"Data saved to database\");\n\nconsole.log(logger1.getLogHistory());\n\n/**\n * The Logger class has a private static instance property that holds the single instance of the logger.\n *\n * The constructor is made private to prevent instantiation from outside the class.\n *\n * The getInstance() method is a static method that returns the singleton instance of the logger. It\n * ensures that only one instance of the logger is created throughout the application.\n *\n * The log() method logs a message along with a timestamp and adds the log entry to the logHistory array.\n *\n * The getLogHistory() method retrieves the log history.\n *\n * In the client code, both logger1 and logger2 references point to the same instance of the logger\n * obtained using the getInstance() method.\n *\n * Logging messages using either logger1 or logger2 will result in consistent logging behavior, and the\n * log history can be retrieved from either instance.\n */\n"}]}],"patterns_structural":[{"title":"Adapter","examples":[{"codeFile":"patterns/structural/adapter/example","code":"// Adaptee: Existing MP3 player\nclass Mp3Player {\n  playMp3(fileName) {\n    console.log(`Playing MP3 file: ${fileName}`);\n  }\n}\n\n// Adapter: Converts OGG audio files to MP3 format\nclass OggToMp3Adapter {\n  constructor() {\n    this.mp3Player = new Mp3Player();\n  }\n\n  play(fileName) {\n    if (fileName.endsWith('.ogg')) {\n      console.log(`Converting OGG file '${fileName}' to MP3 format`);\n      fileName = this.convertToMp3(fileName);\n    }\n    this.mp3Player.playMp3(fileName);\n  }\n\n  private convertToMp3(fileName) {\n    // Simulate conversion process (replace extension)\n    return fileName.replace('.ogg', '.mp3');\n  }\n}\n\n// Client code\nconst audioPlayer = new OggToMp3Adapter();\n\n// Play MP3 file\naudioPlayer.play('audio1.mp3');\n\n// Play OGG file (automatically converted to MP3)\naudioPlayer.play('audio2.ogg');\n\n\n/**\n * Mp3Player represents the existing audio player that can play MP3 files.\n *\n * AudioPlayer is the target interface that defines the unified interface expected by the\n * client application for playing audio files.\n *\n * OggToMp3Adapter is the adapter class that implements the AudioPlayer interface. It internally\n * uses the Mp3Player to play MP3 files but converts OGG files to MP3 format before delegating to\n * the Mp3Player.\n *\n * In the client code, the application interacts with the AudioPlayer interface, unaware of whether\n * it's playing MP3 or OGG files. When playing an OGG file, the adapter automatically converts it\n * to MP3 format before playing it using the Mp3Player.\n *\n */\n"}]},{"title":"Bridge","examples":[{"codeFile":"patterns/structural/bridge/example","code":"// Adaptee: Existing MP3 player\nclass Mp3Player {\n  playMp3(fileName) {\n    console.log(`Playing MP3 file: ${fileName}`);\n  }\n}\n\n// Adapter: Converts OGG audio files to MP3 format\nclass OggToMp3Adapter {\n  constructor() {\n    this.mp3Player = new Mp3Player();\n  }\n\n  play(fileName) {\n    if (fileName.endsWith('.ogg')) {\n      console.log(`Converting OGG file '${fileName}' to MP3 format`);\n      fileName = this.convertToMp3(fileName);\n    }\n    this.mp3Player.playMp3(fileName);\n  }\n\n  private convertToMp3(fileName) {\n    // Simulate conversion process (replace extension)\n    return fileName.replace('.ogg', '.mp3');\n  }\n}\n\n// Client code\nconst audioPlayer = new OggToMp3Adapter();\n\n// Play MP3 file\naudioPlayer.play('audio1.mp3');\n\n// Play OGG file (automatically converted to MP3)\naudioPlayer.play('audio2.ogg');\n\n/**\n * The Vehicle class represents the abstraction, which is extended by Car and Truck.\n *\n * The Workshop interface represents the implementor, defining the work method.\n *\n * PaintWorkshop and RepairWorkshop are concrete implementations of the Workshop interface.\n *\n * Each vehicle can be associated with a specific workshop using composition, and it delegates the work to that workshop.\n */\n"}]},{"title":"Composite","examples":[{"codeFile":"patterns/structural/composite/example","code":"// Leaf: Individual Department\nclass IndividualDepartment {\n  constructor(name, employees) {\n    this.name = name;\n    this.employees = employees;\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  getEmployees() {\n    return this.employees;\n  }\n}\n\n// Composite: Composite Department\nclass CompositeDepartment {\n  constructor(name) {\n    this.name = name;\n    this.departments = [];\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  addDepartment(department) {\n    this.departments.push(department);\n  }\n\n  removeDepartment(department) {\n    const index = this.departments.indexOf(department);\n    if (index !== -1) {\n      this.departments.splice(index, 1);\n    }\n  }\n\n  getEmployees() {\n    let employees = [];\n    for (const department of this.departments) {\n      employees = employees.concat(department.getEmployees());\n    }\n    return employees;\n  }\n}\n\n// Client code\nconst salesDepartment = new IndividualDepartment('Sales Department', ['John', 'Alice', 'Bob']);\nconst marketingDepartment = new IndividualDepartment('Marketing Department', ['Emily', 'David']);\nconst engineeringDepartment = new IndividualDepartment('Engineering Department', ['Michael', 'Sarah', 'Chris']);\n\nconst headDepartment = new CompositeDepartment('Head Department');\nheadDepartment.addDepartment(salesDepartment);\nheadDepartment.addDepartment(marketingDepartment);\n\nconst parentEngineeringDepartment = new CompositeDepartment('Parent Engineering Department');\nparentEngineeringDepartment.addDepartment(engineeringDepartment);\n\nconst rootDepartment = new CompositeDepartment('Root Department');\nrootDepartment.addDepartment(headDepartment);\nrootDepartment.addDepartment(parentEngineeringDepartment);\n\n// Get all employees in the root department\nconsole.log('Employees in the root department:');\nconsole.log(rootDepartment.getEmployees());\n\n\n/**\n * The Department interface defines the common methods for both individual departments and composite departments.\n *\n * IndividualDepartment represents an individual department with a name and a list of employees.\n *\n * CompositeDepartment represents a composite department that can contain sub-departments. It maintains a\n * list of departments and delegates the getEmployees method to its sub-departments recursively.\n *\n * The client code creates a hierarchical structure of departments and retrieves all employees from the root department.\n */\n"}]},{"title":"Decorator","examples":[{"codeFile":"patterns/structural/decorator/example","code":"// Concrete Component: Base Notification\nclass BaseNotification {\n  send() {\n    return 'Base notification: You have a new message!';\n  }\n}\n\n// Decorator: Notification Decorator\nclass NotificationDecorator {\n  constructor(notification) {\n    this.notification = notification;\n  }\n\n  send() {\n    return this.notification.send();\n  }\n}\n\n// Concrete Decorator: Sound Notification\nclass SoundNotificationDecorator extends NotificationDecorator {\n  send() {\n    return `${super.send()} (Sound notification: Ding!)`;\n  }\n}\n\n// Concrete Decorator: Priority Notification\nclass PriorityNotificationDecorator extends NotificationDecorator {\n  send() {\n    return `${super.send()} (Priority notification: High priority!)`;\n  }\n}\n\n// Client code\nconst baseNotification = new BaseNotification();\nconsole.log(baseNotification.send());\n\nconst soundNotification = new SoundNotificationDecorator(baseNotification);\nconsole.log(soundNotification.send());\n\nconst priorityNotification = new PriorityNotificationDecorator(baseNotification);\nconsole.log(priorityNotification.send());\n\nconst soundAndPriorityNotification = new PriorityNotificationDecorator(new SoundNotificationDecorator(baseNotification));\nconsole.log(soundAndPriorityNotification.send());\n\n/**\n * The Notification interface defines the common method for sending notifications.\n *\n * BaseNotification represents the base notification without any additional features.\n *\n * NotificationDecorator is an abstract class that serves as the base class for concrete decorators.\n * It holds a reference to the wrapped notification.\n *\n * SoundNotificationDecorator adds sound notification functionality to the base notification.\n *\n * PriorityNotificationDecorator adds priority notification functionality to the base notification.\n *\n * The client code demonstrates how we can dynamically add sound notification, priority notification,\n * or both to the base notification. Each decorator enhances the behavior of the base notification\n * without modifying its implementation.\n */\n"}]},{"title":"Facade","examples":[{"codeFile":"patterns/structural/facade/example","code":"// Subsystem: Flight Booking\nclass FlightBookingSystem {\n  bookFlight(origin, destination) {\n    return `Flight booked from ${origin} to ${destination}`;\n  }\n}\n\n// Subsystem: Hotel Booking\nclass HotelBookingSystem {\n  bookHotel(location, checkInDate, checkOutDate) {\n    return `Hotel booked at ${location} from ${checkInDate.toDateString()} to ${checkOutDate.toDateString()}`;\n  }\n}\n\n// Subsystem: Car Rental\nclass CarRentalSystem {\n  rentCar(location, startDate, endDate) {\n    return `Car rented at ${location} from ${startDate.toDateString()} to ${endDate.toDateString()}`;\n  }\n}\n\n// Facade: TravelFacade\nclass TravelFacade {\n  constructor() {\n    this.flightBookingSystem = new FlightBookingSystem();\n    this.hotelBookingSystem = new HotelBookingSystem();\n    this.carRentalSystem = new CarRentalSystem();\n  }\n\n  bookTravel(origin, destination, location, checkInDate, checkOutDate, startDate, endDate) {\n    const flightDetails = this.flightBookingSystem.bookFlight(origin, destination);\n    const hotelDetails = this.hotelBookingSystem.bookHotel(location, checkInDate, checkOutDate);\n    const carDetails = this.carRentalSystem.rentCar(location, startDate, endDate);\n\n    return `${flightDetails}\\n${hotelDetails}\\n${carDetails}`;\n  }\n}\n\n// Client code\nconst travelFacade = new TravelFacade();\nconst bookingDetails = travelFacade.bookTravel('New York', 'Los Angeles', 'Hilton', new Date('2023-12-15'), new Date('2023-12-20'), new Date('2023-12-15'), new Date('2023-12-20'));\nconsole.log(bookingDetails);\n\n/**\n * The FlightBookingSystem, HotelBookingSystem, and CarRentalSystem classes represent the\n * subsystems of flight booking, hotel booking, and car rental, respectively.\n *\n * The TravelFacade class provides a simplified interface for booking a complete travel\n * package. It encapsulates the complexities of interacting with the subsystems.\n *\n * The client code interacts with the TravelFacade to book a complete travel package without\n * directly interacting with the subsystems.\n */\n"}]},{"title":"Flyweight","examples":[{"codeFile":"patterns/structural/flyweight/example","code":"// Flyweight: Character\nclass Character {\n  constructor(character) {\n    this.character = character;\n  }\n\n  display(font, size) {\n    return `Character: ${this.character}, Font: ${font}, Size: ${size}`;\n  }\n}\n\n// Flyweight Factory: CharacterFactory\nclass CharacterFactory {\n  constructor() {\n    this.characters = {};\n  }\n\n  getCharacter(character) {\n    if (!this.characters[character]) {\n      this.characters[character] = new Character(character);\n    }\n    return this.characters[character];\n  }\n}\n\n// Client code\nconst characterFactory = new CharacterFactory();\n\n// Text document\nconst text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\";\n\n// Rendering text with flyweight characters\nconst renderedText = [];\n\nfor (const char of text) {\n  const character = characterFactory.getCharacter(char);\n  renderedText.push(character.display('Arial', 12)); // Assume same font and size for simplicity\n}\n\n// Displaying rendered text\nconsole.log(renderedText.join('\\n'));\n\n/**\n * The Character class represents the flyweight object for a character. It contains intrinsic\n * state (the character itself).\n *\n * The CharacterFactory class acts as a flyweight factory, creating and managing flyweight\n * objects. It ensures that each character is shared among multiple instances.\n *\n * In the client code, we create a text document and render it using flyweight characters.\n * Instead of creating a new character object for each character in the text, we retrieve\n * existing flyweight characters from the factory, saving memory and improving performance.\n */\n"}]},{"title":"Proxy","examples":[{"codeFile":"patterns/structural/proxy/example","code":"// Subject: Interface representing the common behavior of RealSubject and Proxy\nclass IHttpServer {\n  async request(url) {\n    throw new Error(\"Method not implemented.\");\n  }\n}\n\n// RealSubject: The actual HTTP server implementation\nclass HttpServer extends IHttpServer {\n  async request(url) {\n    // Simulating HTTP request to the actual server\n    return `Response from server for URL: ${url}`;\n  }\n}\n\n// Proxy: Proxy server that intercepts requests before forwarding them to the real server\nclass ProxyServer extends IHttpServer {\n  constructor() {\n    super();\n    this.httpServer = new HttpServer();\n  }\n\n  async request(url) {\n    // Additional logic can be added here, e.g., caching, access control, logging\n    console.log(`Proxy: Intercepted request for URL: ${url}`);\n\n    // Forward the request to the real server\n    const response = await this.httpServer.request(url);\n\n    // Additional processing on the response can be done here\n\n    return response;\n  }\n}\n\n// Client code\nasync function testProxy() {\n  const proxy = new ProxyServer();\n\n  // Client sends a request to the proxy server\n  const response = await proxy.request(\"https://example.com\");\n\n  console.log(response);\n}\n\n// Test the proxy\ntestProxy();\n\n/**\n * The IHttpServer interface defines the common behavior for both the HttpServer and ProxyServer classes.\n *\n * The HttpServer class represents the real HTTP server implementation. It implements the request method\n * to send HTTP requests to the actual server.\n *\n * The ProxyServer class acts as a proxy server. It intercepts requests before forwarding them to the real\n * server. The request method of the proxy performs additional tasks such as logging, caching, or access\n * control before delegating the request to the real server.\n *\n * In the client code, we instantiate a ProxyServer object and send a request to it. The proxy intercepts\n * the request, performs any necessary processing, and then forwards the request to the real server.\n * Finally, it returns the response to the client.\n */\n"}]}],"patterns_proprietary":[{"title":"Module","description":[{"variant":"subtitle1","content":"The Module Pattern encapsulates \"privacy\", state, and organization using closures. It's commonly used in the JavaScript community due to its powerful ability to create private and public parts.\n"},{"variant":"h6","content":"Benefits"},{"variant":"subtitle1","content":"This pattern provides a way to encapsulate private members while exposing a public API. It also helps in organizing code into manageable sections.\n"}],"examples":[{"code":"const Module = (function() {\n    let privateVar = 'I am private...';\n    return {\n        publicMethod: function() {\n            console.log(privateVar);\n        }\n    };\n})();\nModule.publicMethod(); // Outputs: 'I am private...'\n"}]},{"title":"Revealing Module","description":[{"variant":"subtitle1","content":"A variant of the Module pattern, the Revealing Module Pattern explicitly reveals public pointers to methods inside the module's scope.\n"},{"variant":"h6","content":"Benefits"},{"variant":"subtitle1","content":"This pattern makes the syntax more consistent and makes it clear at the end of the module which of its members are public.\n"}],"examples":[{"code":"const RevealingModule = (function() {\n    let privateVar = 'I am private...';\n    function privateFunction() {\n        console.log(privateVar);\n    }\n    return {\n        publicMethod: function() {\n            privateFunction();\n        }\n    };\n})();\nRevealingModule.publicMethod(); // Outputs: 'I am private...'\n"}]},{"title":"Mixin","description":[{"variant":"subtitle1","content":"JavaScript's object model includes features that allow it to mimic a classical inheritance pattern, known as Mixins. They allow objects to take on properties and methods from other objects.\n"},{"variant":"h6","content":"Benefits"},{"variant":"subtitle1","content":"Mixins help in avoiding the issues related to traditional inheritance and provide a way to add reusable functionalities to objects. They can be used to augment a class by adding multiple behaviors like event handling as mixins.\n"}],"examples":[{"code":"let CarMixin = {\n    revEngine() {\n        console.log(`The ${this.name} goes vroom vroom!`);\n    }\n};\nfunction Car(name) {\n    this.name = name;\n}\nObject.assign(Car.prototype, CarMixin);\nlet raceCar = new Car(\"Ferrari\");\nraceCar.revEngine();  // Outputs: The Ferrari goes vroom vroom!\n"}]},{"title":"Publish/Subscribe","description":[{"variant":"subtitle1","content":"This pattern allows you to create modules that can communicate with each other over a single interface without knowing about each other's inner workings. It's a form of decoupling that can be incredibly useful for larger applications.\n"},{"variant":"h6","content":"Benefits"},{"variant":"subtitle1","content":"The pattern promotes loose coupling and enables better testability, maintainability, and scalability of the application. It's an essential pattern for building complex applications that require various modules to communicate with each other asynchronously.\n"}],"examples":[{"code":"var pubsub = {};\n(function(q) {\n    var topics = {}, subUid = -1;\n    q.publish = function(topic, args) {\n        if (!topics[topic]) {\n            return false;\n        }\n        var subscribers = topics[topic],\n            len = subscribers ? subscribers.length : 0;\n        while (len--) {\n            subscribers[len].func(topic, args);\n        }\n        return this;\n    };\n    q.subscribe = function(topic, func) {\n        if (!topics[topic]) {\n            topics[topic] = [];\n        }\n        var token = (++subUid).toString();\n        topics[topic].push({\n            token: token,\n            func: func\n        });\n        return token;\n    };\n    q.unsubscribe = function(token) {\n        for (var m in topics) {\n            if (topics[m]) {\n                for (var i = 0, j = topics[m].length; i < j; i++) {\n                    if (topics[m][i].token === token) {\n                        topics[m].splice(i, 1);\n                        return token;\n                    }\n                }\n            }\n        }\n        return this;\n    };\n}(pubsub));\nvar messageLogger = function(topics, data) {\n    console.log(`Logging: ${topics}: ${data}`);\n};\nvar subscription = pubsub.subscribe('inbox/newMessage', messageLogger);\npubsub.publish('inbox/newMessage', 'hello world!');\npubsub.publish('inbox/newMessage', ['test', 'a', 'b', 'c']);\npubsub.publish('inbox/newMessage', [{\n    sender: 'hello@google.com',\n    body: 'Hey again!'\n}]);\npubsub.unsubscribe(subscription);\n"}]},{"title":"Promise","description":[{"variant":"subtitle1","content":"With the advent of ES6, Promises are a model for asynchronous programming. Promises are a first-class representation of a value that may be made available in the future.\n"},{"variant":"h6","content":"Benefits"},{"variant":"subtitle1","content":"Promises provide a cleaner, more robust way of handling asynchronous operations compared to callbacks. They simplify error handling, improve readability and make it easier to write asynchronous code.\n"}],"examples":[{"code":"let promise = new Promise(function(resolve, reject) {\n    setTimeout(function() {\n        resolve('Hello world!');\n    }, 2000);\n});\npromise.then(function(value) {\n    console.log(value); // \"Hello world!\"\n}).catch(function(error) {\n    console.log(error);\n});\n"}]}]},"principles":{"principles_solid":[{"title":"Single Responsibility Principle (SRP)","examples":[{"title":"Good Example","codeFile":"principles/solid/single-responsibility/good-example","code":"// Employee class responsible only for storing employee data\nclass Employee {\n  constructor(name, position, salary) {\n    this.name = name;\n    this.position = position;\n    this.salary = salary;\n  }\n\n  getName() {\n    return this.name;\n  }\n\n  getPosition() {\n    return this.position;\n  }\n\n  getSalary() {\n    return this.salary;\n  }\n}\n\n// Printer class responsible only for printing employee information\nclass EmployeePrinter {\n  print(employee) {\n    console.log(`Name: ${employee.getName()}`);\n    console.log(`Position: ${employee.getPosition()}`);\n    console.log(`Salary: ${employee.getSalary()}`);\n  }\n}\n\n// Usage\nconst employee = new Employee(\"John Doe\", \"Software Engineer\", 50000);\nconst printer = new EmployeePrinter();\nprinter.print(employee);\n"},{"title":"Bad Example","codeFile":"principles/solid/single-responsibility/bad-example","code":"class Employee {\n  constructor(name, position, salary) {\n    this.name = name;\n    this.position = position;\n    this.salary = salary;\n  }\n\n  // Method responsible for storing employee data and printing employee information\n  print() {\n    console.log(`Name: ${this.name}`);\n    console.log(`Position: ${this.position}`);\n    console.log(`Salary: ${this.salary}`);\n  }\n}\n\n// Usage\nconst employee = new Employee(\"John Doe\", \"Software Engineer\", 50000);\nemployee.print();\n"}]},{"title":"Open/Closed Principle (OCP)","examples":[{"title":"Good Example","codeFile":"principles/solid/open-closed/good-example","code":"class Shape {\n  computeArea() {\n    throw new Error('Must be implemented in subclasses');\n  }\n}\n\nclass Rectangle extends Shape {\n  constructor(width, height) {\n    super();\n    this.width = width;\n    this.height = height;\n  }\n\n  computeArea() {\n    return this.width * this.height;\n  }\n}\n\nclass Circle extends Shape {\n  constructor(radius) {\n    super();\n    this.radius = radius;\n  }\n\n  computeArea() {\n    return Math.PI * Math.pow(this.radius, 2);\n  }\n}\n\n// Usage\nconst rectangle = new Rectangle(5, 10);\nconsole.log(rectangle.computeArea()); // Output: 50\n\nconst circle = new Circle(5);\nconsole.log(circle.computeArea()); // Output: Approximately 78.54\n"},{"title":"Bad Example","codeFile":"principles/solid/open-closed/bad-example","code":"class Rectangle {\n  constructor(width, height) {\n    this.width = width;\n    this.height = height;\n  }\n}\n\nclass Circle {\n  constructor(radius) {\n    this.radius = radius;\n  }\n}\n\nclass AreaCalculator {\n  computeArea(shape) {\n    if (shape instanceof Rectangle) {\n      return shape.width * shape.height;\n    } else if (shape instanceof Circle) {\n      return Math.PI * Math.pow(shape.radius, 2);\n    }\n\n    // Needs modification for each new shape type, violating the Open/Closed Principle\n    return 0;\n  }\n}\n\n// Usage\nconst rectangle = new Rectangle(5, 10);\nconst circle = new Circle(5);\nconst calculator = new AreaCalculator();\n\nconsole.log(calculator.computeArea(rectangle)); // Output: 50\nconsole.log(calculator.computeArea(circle)); // Output: Approximately 78.54\n"}]},{"title":"Liskov Substitution Principle (LSP)","examples":[{"title":"Good Example","codeFile":"principles/solid/liskov-substitution/good-example","code":"class Bird {\n  fly() {\n    console.log(\"Bird is flying\");\n  }\n}\n\nclass Duck extends Bird {\n  quack() {\n    console.log(\"Duck is quacking\");\n  }\n}\n\nclass Goose extends Bird {\n  swim() {\n    console.log(\"Penguin is swimming\");\n  }\n}\n\nfunction makeBirdFly(bird) {\n  bird.fly();\n}\n\nconst duck = new Duck();\nconst penguin = new Goose();\n\nmakeBirdFly(duck);     // Output\nmakeBirdFly(penguin);  // Output\n"},{"title":"Bad Example","codeFile":"principles/solid/liskov-substitution/bad-example","code":"class Bird {\n  fly() { /* ... */ }\n}\n\nclass Ostrich extends Bird {\n  fly() {\n    throw new Error(\"Can't fly\");  // Ostrich, being a Bird, should not alter the expected behavior of the fly method\n  }\n}\n"}]},{"title":"Interface Segregation Principle (ISP)","examples":[{"title":"Good Example","codeFile":"principles/solid/interface-segregation/good-example","code":"// Simulating the Printer interface functionality\nclass SimplePrinter {\n  printDocument() {\n    console.log(\"Printing document...\");\n  }\n}\n\n// Simulating the MultifunctionalPrinter that implements Printer, Fax, and Scanner functionalities\nclass MultifunctionalPrinter {\n  printDocument() {\n    console.log(\"Printing document...\");\n  }\n\n  faxDocument() {\n    console.log(\"Faxing document...\");\n  }\n\n  scanDocument() {\n    console.log(\"Scanning document...\");\n  }\n}\n\n// Usage examples:\n\nconst simplePrinter = new SimplePrinter();\nsimplePrinter.printDocument(); // \"Printing document...\"\n\nconst multifunctionalPrinter = new MultifunctionalPrinter();\nmultifunctionalPrinter.printDocument(); // \"Printing document...\"\nmultifunctionalPrinter.faxDocument(); // \"Faxing document...\"\nmultifunctionalPrinter.scanDocument(); // \"Scanning document...\"\n"},{"title":"Bad Example","codeFile":"principles/solid/interface-segregation/bad-example","code":"// Instead of a single Machine interface, we conceptually segregate the functionalities.\n\nclass Printer {\n  printDocument() {\n    console.log(\"Printing document...\");\n  }\n}\n\n// Assuming we need to demonstrate the use of faxing and scanning capabilities\n// without forcing them onto a class that doesn't support them:\n\nclass FaxMachine {\n  faxDocument() {\n    console.log(\"Faxing document...\");\n  }\n}\n\nclass Scanner {\n  scanDocument() {\n    console.log(\"Scanning document...\");\n  }\n}\n\n// OldPrinter now only has methods relevant to its capabilities\nclass OldPrinter extends Printer {\n  // It only needs to override or implement methods for its actual functionality,\n  // in this case, printDocument, which is already provided by the Printer class.\n  // Thus, OldPrinter does not need to implement faxDocument or scanDocument.\n}\n\n// Usage\nconst oldPrinter = new OldPrinter();\noldPrinter.printDocument(); // \"Printing document...\"\n\n// Separate classes for each functionality demonstrate ISP\nconst faxMachine = new FaxMachine();\nfaxMachine.faxDocument(); // \"Faxing document...\"\n\nconst scanner = new Scanner();\nscanner.scanDocument(); // \"Scanning document...\"\n"}]},{"title":"Dependency Inversion Principle (DIP)","examples":[{"title":"Good Example","codeFile":"principles/solid/interface-segregation/good-example","code":"// Simulating the Printer interface functionality\nclass SimplePrinter {\n  printDocument() {\n    console.log(\"Printing document...\");\n  }\n}\n\n// Simulating the MultifunctionalPrinter that implements Printer, Fax, and Scanner functionalities\nclass MultifunctionalPrinter {\n  printDocument() {\n    console.log(\"Printing document...\");\n  }\n\n  faxDocument() {\n    console.log(\"Faxing document...\");\n  }\n\n  scanDocument() {\n    console.log(\"Scanning document...\");\n  }\n}\n\n// Usage examples:\n\nconst simplePrinter = new SimplePrinter();\nsimplePrinter.printDocument(); // \"Printing document...\"\n\nconst multifunctionalPrinter = new MultifunctionalPrinter();\nmultifunctionalPrinter.printDocument(); // \"Printing document...\"\nmultifunctionalPrinter.faxDocument(); // \"Faxing document...\"\nmultifunctionalPrinter.scanDocument(); // \"Scanning document...\"\n"},{"title":"Bad Example","codeFile":"principles/solid/interface-segregation/bad-example","code":"// Instead of a single Machine interface, we conceptually segregate the functionalities.\n\nclass Printer {\n  printDocument() {\n    console.log(\"Printing document...\");\n  }\n}\n\n// Assuming we need to demonstrate the use of faxing and scanning capabilities\n// without forcing them onto a class that doesn't support them:\n\nclass FaxMachine {\n  faxDocument() {\n    console.log(\"Faxing document...\");\n  }\n}\n\nclass Scanner {\n  scanDocument() {\n    console.log(\"Scanning document...\");\n  }\n}\n\n// OldPrinter now only has methods relevant to its capabilities\nclass OldPrinter extends Printer {\n  // It only needs to override or implement methods for its actual functionality,\n  // in this case, printDocument, which is already provided by the Printer class.\n  // Thus, OldPrinter does not need to implement faxDocument or scanDocument.\n}\n\n// Usage\nconst oldPrinter = new OldPrinter();\noldPrinter.printDocument(); // \"Printing document...\"\n\n// Separate classes for each functionality demonstrate ISP\nconst faxMachine = new FaxMachine();\nfaxMachine.faxDocument(); // \"Faxing document...\"\n\nconst scanner = new Scanner();\nscanner.scanDocument(); // \"Scanning document...\"\n"}]}],"principles_other":[{"title":"Don't Repeat Yourself (DRY)","examples":[{"title":"Good Example","codeFile":"principles/other/dry/good-example","code":"// Using default parameters and arrow functions for repeated logic\nconst addTax = (price, rate = 0.05) => price + (price * rate);\n"},{"title":"Bad Example","codeFile":"principles/other/dry/bad-example","code":"const addTaxForFood = (price) => price + (price * 0.05);\nconst addTaxForElectronics = (price) => price + (price * 0.05);\n"}]},{"title":"Keep It Simple Stupid (KISS)","examples":[{"title":"Good Example","codeFile":"principles/other/kiss/good-example","code":"const isEven = (num) => num % 2 === 0;\n"},{"title":"Bad Example","codeFile":"principles/other/kiss/bad-example","code":"// there is no need for absolute value here\nconst isEven = (num) => num % Math.abs(2) === 0;\n"}]},{"title":"You Aren't Gonna Need It (YAGNI)","examples":[{"codeFile":"principles/other/yagni/bad-example","code":"class Calculator {\n  add(a, b) {\n    return a + b;\n  }\n\n  // Do not define methods unless they are used\n\n  multiply(a, b) {\n    return a * b;\n  }\n\n  divide(a, b) {\n    if (b === 0) {\n      throw new Error(\"Division by zero is not allowed.\");\n    }\n    return a / b;\n  }\n\n  subtract(a, b) {\n    return a - b;\n  }\n}\n"}]},{"title":"Law of Demeter (Principle of Least Knowledge)","examples":[{"title":"Good Example","codeFile":"principles/other/demeter/good-example","code":"class Wallet {\n  constructor() {\n    this.money = 100; // This is public in ES6. For private fields, use #money and access it with this.#money\n  }\n\n  getAmount() {\n    return this.money;\n  }\n}\n\nclass Person {\n  constructor() {\n    this.wallet = new Wallet();\n  }\n\n  getMoneyAmount() {\n    return this.wallet.getAmount();\n  }\n}\n\nfunction purchase(item, buyer) {\n  if (buyer.getMoneyAmount() >= item.price) {\n    // ...\n  }\n}\n"},{"title":"Bad Example","codeFile":"principles/other/demeter/bad-example","code":"class Wallet {\n  constructor() {\n    this.money = { amount: 100 }; // Initialized with an example amount\n  }\n}\n\nclass Person {\n  constructor() {\n    this.wallet = new Wallet();\n  }\n}\n\nfunction purchase(item, buyer) {\n  if (buyer.wallet.money.amount >= item.price) {\n    // ...\n  }\n}\n"},{"title":"Good Example","codeFile":"principles/other/demeter/good-example","code":"class Wallet {\n  constructor() {\n    this.money = 100; // This is public in ES6. For private fields, use #money and access it with this.#money\n  }\n\n  getAmount() {\n    return this.money;\n  }\n}\n\nclass Person {\n  constructor() {\n    this.wallet = new Wallet();\n  }\n\n  getMoneyAmount() {\n    return this.wallet.getAmount();\n  }\n}\n\nfunction purchase(item, buyer) {\n  if (buyer.getMoneyAmount() >= item.price) {\n    // ...\n  }\n}\n"},{"title":"Good Example (ES 2020+)","codeFile":"principles/other/demeter/good-example-2020","code":"class Wallet {\n  #money;\n\n  constructor() {\n    this.#money = 100;\n  }\n\n  getAmount() {\n    return this.#money;\n  }\n}\n\nclass Person {\n  constructor() {\n    this.wallet = new Wallet();\n  }\n\n  getMoneyAmount() {\n    return this.wallet.getAmount();\n  }\n}\n\nfunction purchase(item, buyer) {\n  if (buyer.getMoneyAmount() >= item.price) {\n    // ...\n  }\n}\n"}]},{"title":"Separation of Concerns","examples":[{"title":"Good Example","codeFile":"principles/other/separation/good-example","code":"// Authentication service\nclass AuthenticationService {\n  login(username, password) {\n    // Authentication logic here\n    return true; // Dummy implementation\n  }\n\n  logout() {\n    // Logout logic here\n  }\n}\n\n// Data service\nclass DataService {\n  fetchData() {\n    // Data retrieval logic here\n    return []; // Dummy implementation\n  }\n}\n\n/**\n * - `AuthenticationService` and `DataService` are responsible for handling authentication and data retrieval, respectively.\n * - `UserController` and `DataController` serve as intermediaries between the HTTP layer (not shown) and the services.\n * - Each component has a single responsibility, promoting modularity, testability, and maintainability.\n *\n */\n\n// User controller\nclass UserController {\n  constructor(authService) {\n    this.authService = authService;\n  }\n\n  loginUser(username, password) {\n    return this.authService.login(username, password);\n  }\n\n  logoutUser() {\n    this.authService.logout();\n  }\n}\n\n// Data controller\nclass DataController {\n  constructor(dataService) {\n    this.dataService = dataService;\n  }\n\n  getData() {\n    return this.dataService.fetchData();\n  }\n}\n\n// Usage\nconst authService = new AuthenticationService();\nconst dataService = new DataService();\n\nconst userController = new UserController(authService);\nconst dataController = new DataController(dataService);\n\n// Simulate user login/logout\nuserController.loginUser(\"username\", \"password\");\nuserController.logoutUser();\n\n// Retrieve data\nconst data = dataController.getData();\nconsole.log(data);\n"},{"title":"Bad Example","codeFile":"principles/other/separation/bad-example","code":"// Authentication service\nclass AuthenticationService {\n  login(username, password) {\n    // Authentication logic here\n    return true; // Dummy implementation\n  }\n\n  logout() {\n    // Logout logic here\n  }\n}\n\n// Data service\nclass DataService {\n  fetchData() {\n    // Data retrieval logic here\n    return []; // Dummy implementation\n  }\n}\n\n/**\n * - The `CombinedController` class is responsible for both user authentication and data retrieval.\n * - The loginUser method not only handles authentication but also retrieves user data directly\n *   from the `DataService`, violating the Single Responsibility Principle and mixing concerns.\n * - This violates the principle of Separation of Concerns and makes the code harder to maintain, test, and understand.\n */\nclass CombinedController {\n  constructor(authService, dataService) {\n    this.authService = authService;\n    this.dataService = dataService;\n  }\n\n  loginUser(username, password) {\n    // Authentication logic here\n    const isAuthenticated = this.authService.login(username, password);\n    if (isAuthenticated) {\n      // Retrieve user data (mixing concerns)\n      const userData = this.dataService.fetchData();\n      console.log(userData);\n    }\n    return isAuthenticated;\n  }\n\n  logoutUser() {\n    // Logout logic here\n    this.authService.logout();\n  }\n}\n\n// Usage\nconst authService = new AuthenticationService();\nconst dataService = new DataService();\n\nconst combinedController = new CombinedController(authService, dataService);\n\n// Simulate user login/logout\ncombinedController.loginUser(\"username\", \"password\");\ncombinedController.logoutUser();\n"}]}],"principles_proprietary":[{"title":"Dynamic Typing","description":[{"variant":"subtitle1","content":"JavaScript is a loosely typed or a dynamic language. Variables are not directly associated with any particular value type, and any variable can be assigned and re-assigned values of all types.\n"}],"examples":[{"code":"let data = 42; // data is now a number\ndata = 'hello'; // data is now a string\ndata = true; // data is now a boolean\n"}]},{"title":"Prototype-based Object Orientation","description":[{"variant":"subtitle1","content":"Instead of classical inheritance, JavaScript uses prototypes. Each object has a private property which holds a link to another object called its prototype.\n"}],"examples":[{"code":"function Person(firstName) {\n  this.firstName = firstName;\n}\nPerson.prototype.sayHello = function() {\n  return \"Hello, I'm \" + this.firstName;\n};\nconst john = new Person(\"John\");\nconsole.log(john.sayHello()); // \"Hello, I'm John\"\n"}]},{"title":"First-Class Functions","description":[{"variant":"subtitle1","content":"In JavaScript, functions are first-class objects. They can be stored in variables, passed as arguments to other functions, returned from those functions, and have their own properties and methods.\n"}],"examples":[{"code":"function greet() {\n  return \"Hello World!\";\n}\nlet greetMsg = greet; // Assigning function to variable\nconsole.log(greetMsg()); // \"Hello World!\"\n"}]},{"title":"Event-Driven Programming","description":[{"variant":"subtitle1","content":"JavaScript is heavily used in web browsers where the flow of the program is determined by events such as user actions (clicks, keyboard events, etc).\n"}],"examples":[{"code":"document.getElementById(\"myBtn\").addEventListener(\"click\", displayDate);\nfunction displayDate() {\n  document.getElementById(\"demo\").innerHTML = Date();\n}\n"}]},{"title":"Asynchronous Programming","description":[{"variant":"subtitle1","content":"With features like callbacks, promises, and async/await, JavaScript handles asynchronous operations. This is especially useful for operations like fetching data from a server without blocking the main thread.\n"}],"examples":[{"code":"async function fetchData() {\n  let response = await fetch('https://api.example.com/data');\n  let data = await response.json();\n  console.log(data);\n}\nfetchData();\n"}]},{"title":"Closure","description":[{"variant":"subtitle1","content":"Functions in JavaScript form closures. A closure is the combination of a function bundled together (enclosed) with references to its surrounding state (lexical environment).\n"}],"examples":[{"code":"function makeAdder(x) {\n  return function(y) {\n    return x + y;\n  };\n}\nlet add5 = makeAdder(5);\nconsole.log(add5(2));  // 7\n"}]},{"title":"Single-Threaded with Non-blocking I/O","description":[{"variant":"subtitle1","content":"JavaScript is single-threaded, but it uses asynchronous callbacks and an event loop to handle concurrency.\n"}],"examples":[{"code":"console.log('First');\nsetTimeout(function() {\n  console.log('Second');\n}, 0);\nconsole.log('Third');\n// Output: First, Third, Second\n"}]},{"title":"Truthy and Falsy Values","description":[{"variant":"subtitle1","content":"In JavaScript, values are considered either \"truthy\" or \"falsy\", not just true or false. This affects flow control and operations in ways that can be peculiar compared to other languages.\n"}],"examples":[{"code":"if ('') console.log('Falsy!');\nif ('hello') console.log('Truthy!');\n// Output: Truthy!\n"}]},{"title":"Template Literals","description":[{"variant":"subtitle1","content":"JavaScript allows for string interpolation and multi-line strings in a more readable fashion with template literals.\n"}],"examples":[{"code":"const name = \"world\";\nconsole.log(`Hello, ${name}!`); // Hello, world!\n"}]},{"title":"ES6 and Beyond","description":[{"variant":"subtitle1","content":"The ECMAScript 2016 (ES6) and later versions brought many additions and improvements, like classes, enhanced object literals, default parameters, destructuring, spread operator, and more, influencing how JavaScript is written.\n"}],"examples":[{"code":"class Animal {\n  constructor(name) {\n    this.name = name;\n  }\n  speak() {\n    console.log(`${this.name} makes a noise.`);\n  }\n}\nclass Dog extends Animal {\n  speak() {\n    console.log(`${this.name} barks.`);\n  }\n}\nlet dog = new Dog('Rex');\ndog.speak(); // Rex barks.\n"}]}]}}