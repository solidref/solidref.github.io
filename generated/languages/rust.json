{"name":"Rust","code":"rust","ext":"rs","birth":2010,"death":"N/A","inspiredBy":["c++","erlang","haskell","ocaml","ruby","scheme"],"inspiring":["swift","zig","elm"],"description":"Rust is a systems programming language focused on speed, memory safety, and parallelism. It is syntactically similar to C++, but it aims to provide memory safety without using garbage collection. Rust is developed by a diverse community of enthusiasts and is sponsored by Mozilla Research. It features elements like zero-cost abstractions, move semantics, guaranteed memory safety, threads without data races, trait-based generics, pattern matching, and type inference. Rust's rich type system and ownership model guarantee memory-safety and thread-safety â€” enabling developers to write fast, concurrent programs without the usual pitfalls of C and C++. Rust is used in a wide range of applications, from operating systems to game engines, and is gaining popularity for its approach to safe systems programming.\n","patterns":{"patterns_behavioural":[{"title":"Chain Of Responsibility","examples":[{"codeFile":"patterns/behavioural/chain-of-responsibility/example","code":"trait SupportHandler {\n    fn set_next_handler(&mut self, handler: Box<dyn SupportHandler>);\n    fn handle_request(&self, request: &str) -> Option<String>;\n}\n\nstruct Level1Support {\n    next_handler: Option<Box<dyn SupportHandler>>,\n}\n\nimpl Level1Support {\n    fn new() -> Level1Support {\n        Level1Support { next_handler: None }\n    }\n}\n\nimpl SupportHandler for Level1Support {\n    fn set_next_handler(&mut self, handler: Box<dyn SupportHandler>) {\n        self.next_handler = Some(handler);\n    }\n\n    fn handle_request(&self, request: &str) -> Option<String> {\n        if request.contains(\"basic\") {\n            Some(\"Level 1 Support: Issue resolved at basic level.\".to_string())\n        } else if let Some(handler) = &self.next_handler {\n            handler.handle_request(request)\n        } else {\n            None\n        }\n    }\n}\n\nstruct Level2Support {\n    next_handler: Option<Box<dyn SupportHandler>>,\n}\n\nimpl Level2Support {\n    fn new() -> Level2Support {\n        Level2Support { next_handler: None }\n    }\n}\n\nimpl SupportHandler for Level2Support {\n    fn set_next_handler(&mut self, handler: Box<dyn SupportHandler>) {\n        self.next_handler = Some(handler);\n    }\n\n    fn handle_request(&self, request: &str) -> Option<String> {\n        if request.contains(\"advanced\") {\n            Some(\"Level 2 Support: Issue resolved at advanced level.\".to_string())\n        } else if let Some(handler) = &self.next_handler {\n            handler.handle_request(request)\n        } else {\n            None\n        }\n    }\n}\n\nstruct Level3Support;\n\nimpl SupportHandler for Level3Support {\n    fn set_next_handler(&mut self, _: Box<dyn SupportHandler>) {\n        panic!(\"Level 3 Support is the highest level and does not have a next handler.\");\n    }\n\n    fn handle_request(&self, request: &str) -> Option<String> {\n        if request.contains(\"bug\") {\n            Some(\"Level 3 Support: Issue resolved at development level.\".to_string())\n        } else {\n            Some(\"Level 3 Support: Unable to resolve the issue.\".to_string())\n        }\n    }\n}\n\nfn main() {\n    let mut level1 = Level1Support::new();\n    let mut level2 = Level2Support::new();\n    let level3 = Level3Support;\n\n    level1.set_next_handler(Box::new(level2));\n    level2.set_next_handler(Box::new(level3));\n\n    let request1 = \"Fix basic login issue\";\n    let request2 = \"Debug advanced performance problem\";\n    let request3 = \"Investigate bug causing application crash\";\n\n    println!(\"{}\", level1.handle_request(request1).unwrap());\n    println!(\"{}\", level1.handle_request(request2).unwrap());\n    println!(\"{}\", level1.handle_request(request3).unwrap());\n}"}]},{"title":"Command","examples":[{"codeFile":"patterns/behavioural/command/example","code":"trait Command {\n    fn execute(&self);\n}\n\nstruct Light;\n\nimpl Light {\n    fn turn_on(&self) {\n        println!(\"Light is on\");\n    }\n\n    fn turn_off(&self) {\n        println!(\"Light is off\");\n    }\n}\n\nstruct TurnOnCommand {\n    light: Light,\n}\n\nimpl TurnOnCommand {\n    fn new(light: Light) -> Self {\n        Self { light }\n    }\n}\n\nimpl Command for TurnOnCommand {\n    fn execute(&self) {\n        self.light.turn_on();\n    }\n}\n\nstruct TurnOffCommand {\n    light: Light,\n}\n\nimpl TurnOffCommand {\n    fn new(light: Light) -> Self {\n        Self { light }\n    }\n}\n\nimpl Command for TurnOffCommand {\n    fn execute(&self) {\n        self.light.turn_off();\n    }\n}\n\nstruct RemoteControl {\n    commands: Vec<Box<dyn Command>>,\n}\n\nimpl RemoteControl {\n    fn new() -> Self {\n        Self { commands: vec![] }\n    }\n\n    fn add_command(&mut self, command: Box<dyn Command>) {\n        self.commands.push(command);\n    }\n\n    fn execute_commands(&self) {\n        for command in &self.commands {\n            command.execute();\n        }\n    }\n}\n\nfn main() {\n    let light = Light;\n\n    let turn_on_command = TurnOnCommand::new(light);\n    let turn_off_command = TurnOffCommand::new(light);\n\n    let mut remote_control = RemoteControl::new();\n    remote_control.add_command(Box::new(turn_on_command));\n    remote_control.add_command(Box::new(turn_off_command));\n\n    remote_control.execute_commands();\n}\n\n// This code demonstrates how the Command pattern can be used in a remote control\n// system to control a light. The Command trait defines the contract for executing\n// commands, and concrete command structs (TurnOnCommand and TurnOffCommand) encapsulate\n// actions to be performed on the Light receiver object. The RemoteControl acts as\n// the invoker, which holds and triggers the commands. Pressing buttons on the remote\n// control executes the corresponding commands, resulting in the light being turned on\n// and off."}]},{"title":"Iterator","examples":[{"codeFile":"patterns/behavioural/iterator/example","code":"struct Iterator<T> {\n    collection: Vec<T>,\n    index: usize,\n}\n\nimpl<T> Iterator<T> {\n    fn new(collection: Vec<T>) -> Self {\n        Self { collection, index: 0 }\n    }\n\n    fn next(&mut self) -> Option<&T> {\n        if self.index < self.collection.len() {\n            let result = &self.collection[self.index];\n            self.index += 1;\n            Some(result)\n        } else {\n            None\n        }\n    }\n\n    fn has_next(&self) -> bool {\n        self.index < self.collection.len()\n    }\n}\n\nfn main() {\n    let items = vec![1, 'two', 3, 'four', 5];\n    let mut iterator = Iterator::new(items);\n\n    while iterator.has_next() {\n        println!(\"{:?}\", iterator.next());\n    }\n}\n\n// In this Rust version, the Iterator pattern is used to iterate over a collection. Just like in the original example,\n// the Iterator struct defines methods for checking if there are more elements (has_next) and retrieving the next element (next).\n// The main function illustrates how to create an iterator for a mixed collection and use it to iterate through the items, printing each one.\n// This approach demonstrates a common Rust pattern for implementing iterators, leveraging Rust's type system and ownership rules for safety and efficiency."}]},{"title":"Mediator","examples":[{"codeFile":"patterns/behavioural/mediator/example","code":"```rust\ntrait ChatMediator {\n    fn send_message(&self, message: &str, user: &User);\n}\n\nstruct ChatRoom;\nimpl ChatMediator for ChatRoom {\n    fn send_message(&self, message: &str, user: &User) {\n        println!(\"[{}] sends message: {}\", user.get_name(), message);\n    }\n}\n\ntrait User {\n    fn send(&self, message: &str);\n    fn receive(&self, message: &str);\n    fn get_name(&self) -> String;\n}\n\nstruct ChatUser {\n    name: String,\n    mediator: Box<dyn ChatMediator>,\n}\n\nimpl ChatUser {\n    fn new(name: String, mediator: Box<dyn ChatMediator>) -> Self {\n        ChatUser { name, mediator }\n    }\n}\n\nimpl User for ChatUser {\n    fn send(&self, message: &str) {\n        println!(\"[{}] sends message: {}\", self.name, message);\n        self.mediator.send_message(message, self);\n    }\n\n    fn receive(&self, message: &str) {\n        println!(\"[{}] received message: {}\", self.name, message);\n    }\n\n    fn get_name(&self) -> String {\n        self.name.clone()\n    }\n}\n\nfn main() {\n    let chat_mediator: Box<dyn ChatMediator> = Box::new(ChatRoom);\n\n    let user1 = ChatUser::new(\"User1\".to_string(), chat_mediator.clone());\n    let user2 = ChatUser::new(\"User2\".to_string(), chat_mediator.clone());\n\n    user1.send(\"Hello, User2!\");\n    user2.send(\"Hi, User1!\");\n}\n```"}]},{"title":"Memento","examples":[{"codeFile":"patterns/behavioural/memento/example","code":"struct Editor {\n    text: String,\n}\n\nimpl Editor {\n    fn new(text: String) -> Self {\n        Self { text }\n    }\n\n    fn set_text(&mut self, text: String) {\n        self.text = text;\n    }\n\n    fn get_text(&self) -> &str {\n        &self.text\n    }\n\n    fn save(&self) -> Memento {\n        Memento::new(self.text.clone())\n    }\n\n    fn restore(&mut self, memento: Memento) {\n        self.text = memento.get_state();\n    }\n}\n\nstruct Memento {\n    state: String,\n}\n\nimpl Memento {\n    fn new(state: String) -> Self {\n        Self { state }\n    }\n\n    fn get_state(&self) -> String {\n        self.state.clone()\n    }\n}\n\nstruct History {\n    mementos: Vec<Memento>,\n}\n\nimpl History {\n    fn new() -> Self {\n        Self { mementos: Vec::new() }\n    }\n\n    fn add_memento(&mut self, memento: Memento) {\n        self.mementos.push(memento);\n    }\n\n    fn get_latest_memento(&self) -> Option<&Memento> {\n        self.mementos.last()\n    }\n}\n\nfn main() {\n    let mut editor = Editor::new(\"Initial text\".to_string());\n\n    let mut history = History::new();\n\n    history.add_memento(editor.save());\n\n    editor.set_text(\"Modified text\".to_string());\n\n    history.add_memento(editor.save());\n\n    if let Some(latest_memento) = history.get_latest_memento() {\n        editor.restore(latest_memento.clone());\n    }\n\n    println!(\"{}\", editor.get_text());\n}"}]},{"title":"Observer","examples":[{"codeFile":"patterns/behavioural/observer/example","code":"use std::cell::RefCell;\nuse std::rc::{Rc, Weak};\n\ntrait Subject {\n    fn subscribe(&self, observer: Rc<RefCell<dyn Observer>>);\n    fn unsubscribe(&self, observer: Weak<RefCell<dyn Observer>>);\n    fn notify(&self, data: &str);\n}\n\nstruct ConcreteSubject {\n    observers: RefCell<Vec<Weak<RefCell<dyn Observer>>>>,\n}\n\nimpl ConcreteSubject {\n    fn new() -> Self {\n        ConcreteSubject {\n            observers: RefCell::new(Vec::new()),\n        }\n    }\n}\n\nimpl Subject for ConcreteSubject {\n    fn subscribe(&self, observer: Rc<RefCell<dyn Observer>>) {\n        self.observers.borrow_mut().push(Rc::downgrade(&observer));\n    }\n\n    fn unsubscribe(&self, observer: Weak<RefCell<dyn Observer>>) {\n        let mut observers = self.observers.borrow_mut();\n        if let Some(position) = observers.iter().position(|obs| obs.ptr_eq(&observer)) {\n            observers.remove(position);\n        }\n    }\n\n    fn notify(&self, data: &str) {\n        for observer_weak in self.observers.borrow().iter() {\n            if let Some(observer) = observer_weak.upgrade() {\n                observer.borrow().update(data);\n            }\n        }\n    }\n}\n\ntrait Observer {\n    fn update(&self, data: &str);\n}\n\nstruct ConcreteObserver;\n\nimpl Observer for ConcreteObserver {\n    fn update(&self, data: &str) {\n        println!(\"Observer received data: {}\", data);\n    }\n}\n\nfn main() {\n    let subject = Rc::new(ConcreteSubject::new());\n    let observer1 = Rc::new(RefCell::new(ConcreteObserver));\n    let observer2 = Rc::new(RefCell::new(ConcreteObserver));\n\n    subject.subscribe(observer1.clone());\n    subject.subscribe(observer2.clone());\n\n    subject.notify(\"Hello Observers!\");\n\n    subject.unsubscribe(Rc::downgrade(&observer2));\n    subject.notify(\"Goodbye Observers!\");\n\n    // The section below related to Editor, Memento, and History patterns is not part of the Observer pattern example.\n    // However, the description provided in the comment is valuable for understanding those additional patterns.\n}"}]},{"title":"State","examples":[{"codeFile":"patterns/behavioural/state/example","code":"use std::sync::{Arc, Mutex};\nuse std::thread;\nuse std::time::Duration;\n\ntrait TrafficLightState {\n    fn change_state(self: Box<Self>, traffic_light: Arc<Mutex<TrafficLight>>);\n}\n\nstruct RedState;\n\nimpl TrafficLightState for RedState {\n    fn change_state(self: Box<Self>, traffic_light: Arc<Mutex<TrafficLight>>) {\n        println!(\"Traffic light is now RED. Stop!\");\n        // Transition to the next state (Yellow) after a certain duration\n        thread::spawn(move || {\n            thread::sleep(Duration::from_secs(3));\n            let mut traffic_light = traffic_light.lock().unwrap();\n            traffic_light.set_state(Box::new(YellowState));\n        });\n    }\n}\n\nstruct YellowState;\n\nimpl TrafficLightState for YellowState {\n    fn change_state(self: Box<Self>, traffic_light: Arc<Mutex<TrafficLight>>) {\n        println!(\"Traffic light is now YELLOW. Prepare to stop or proceed with caution.\");\n        // Transition to the next state (Green) after a certain duration\n        thread::spawn(move || {\n            thread::sleep(Duration::from_secs(2));\n            let mut traffic_light = traffic_light.lock().unwrap();\n            traffic_light.set_state(Box::new(GreenState));\n        });\n    }\n}\n\nstruct GreenState;\n\nimpl TrafficLightState for GreenState {\n    fn change_state(self: Box<Self>, traffic_light: Arc<Mutex<TrafficLight>>) {\n        println!(\"Traffic light is now GREEN. Go!\");\n        // Transition to the next state (Red) after a certain duration\n        thread::spawn(move || {\n            thread::sleep(Duration::from_secs(4));\n            let mut traffic_light = traffic_light.lock().unwrap();\n            traffic_light.set_state(Box::new(RedState));\n        });\n    }\n}\n\nstruct TrafficLight {\n    state: Box<dyn TrafficLightState>,\n}\n\nimpl TrafficLight {\n    fn new() -> Self {\n        TrafficLight {\n            state: Box::new(RedState),\n        }\n    }\n\n    fn set_state(&mut self, state: Box<dyn TrafficLightState>) {\n        self.state = state;\n        let traffic_light_arc = Arc::new(Mutex::new(self));\n        self.state.change_state(traffic_light_arc.clone());\n    }\n}\n\nfn main() {\n    let traffic_light = Arc::new(Mutex::new(TrafficLight::new()));\n\n    // Simulating the behavior of traffic light by changing its state manually\n    {\n        let mut traffic_light = traffic_light.lock().unwrap();\n        traffic_light.set_state(Box::new(GreenState));\n    }\n\n    // Let the threads complete their tasks (not ideal, just for demonstration)\n    thread::sleep(Duration::from_secs(10));\n}"}]},{"title":"Strategy","examples":[{"codeFile":"patterns/behavioural/strategy/example","code":"trait PaymentStrategy {\n    fn pay(&self, amount: u32);\n}\n\nstruct CreditCardPaymentStrategy {\n    card_number: String,\n    expiry_date: String,\n    cvv: String,\n}\n\nimpl PaymentStrategy for CreditCardPaymentStrategy {\n    fn pay(&self, amount: u32) {\n        println!(\n            \"Processing credit card payment of ${} with card number {}\",\n            amount, self.card_number\n        );\n        // Logic to process payment via credit card\n    }\n}\n\nstruct PayPalPaymentStrategy {\n    email: String,\n    password: String, // In real applications, avoid storing clear-text passwords\n}\n\nimpl PaymentStrategy for PayPalPaymentStrategy {\n    fn pay(&self, amount: u32) {\n        println!(\"Processing PayPal payment of ${} with email {}\", amount, self.email);\n        // Logic to process payment via PayPal\n    }\n}\n\nstruct PaymentProcessor {\n    payment_strategy: Option<Box<dyn PaymentStrategy>>,\n}\n\nimpl PaymentProcessor {\n    fn new() -> PaymentProcessor {\n        PaymentProcessor { payment_strategy: None }\n    }\n\n    fn set_payment_strategy(&mut self, strategy: Box<dyn PaymentStrategy>) {\n        self.payment_strategy = Some(strategy);\n    }\n\n    fn process_payment(&self, amount: u32) {\n        match &self.payment_strategy {\n            Some(strategy) => strategy.pay(amount),\n            None => println!(\"Payment strategy not set. Please select a payment method.\"),\n        }\n    }\n}\n\nfn main() {\n    let mut payment_processor = PaymentProcessor::new();\n\n    // Select a payment method (strategy) dynamically\n    let credit_card_strategy = CreditCardPaymentStrategy {\n        card_number: \"1234 5678 9012 3456\".to_string(),\n        expiry_date: \"12/25\".to_string(),\n        cvv: \"123\".to_string(),\n    };\n    payment_processor.set_payment_strategy(Box::new(credit_card_strategy));\n    payment_processor.process_payment(100);\n\n    // Change payment method (strategy)\n    let pay_pal_strategy = PayPalPaymentStrategy {\n        email: \"example@example.com\".to_string(),\n        password: \"password\".to_string(),\n    };\n    payment_processor.set_payment_strategy(Box::new(pay_pal_strategy));\n    payment_processor.process_payment(50);\n}"}]},{"title":"Template Method","examples":[{"codeFile":"patterns/behavioural/template-method/example","code":"trait Breakfast {\n    // Template method\n    fn prepare(&self) {\n        self.boil_water();\n        self.add_ingredients();\n        self.cook();\n        self.serve();\n    }\n\n    // Abstract methods to be implemented by structs\n    fn add_ingredients(&self);\n    fn cook(&self);\n\n    // Concrete methods\n    fn boil_water(&self) {\n        println!(\"Boiling water...\");\n    }\n\n    fn serve(&self) {\n        println!(\"Breakfast is served!\");\n    }\n}\n\nstruct OmeletteBreakfast;\n\nimpl Breakfast for OmeletteBreakfast {\n    fn add_ingredients(&self) {\n        println!(\"Adding eggs, cheese, and vegetables to the pan.\");\n    }\n\n    fn cook(&self) {\n        println!(\"Cooking the omelette until golden brown.\");\n    }\n}\n\nstruct PancakeBreakfast;\n\nimpl Breakfast for PancakeBreakfast {\n    fn add_ingredients(&self) {\n        println!(\"Mixing flour, eggs, milk, and sugar to make the batter.\");\n    }\n\n    fn cook(&self) {\n        println!(\"Pouring the batter onto the griddle and flipping until cooked.\");\n    }\n}\n\nfn main() {\n    println!(\"Preparing Omelette Breakfast:\");\n    let omelette_breakfast = OmeletteBreakfast;\n    omelette_breakfast.prepare();\n\n    println!(\"\\nPreparing Pancake Breakfast:\");\n    let pancake_breakfast = PancakeBreakfast;\n    pancake_breakfast.prepare();\n}\n\n/*\n * In the translation from the original class-based template method pattern to Rust, \n * we use a trait to define the common behavior (`Breakfast`) for the template method \n * and its default implementations for concrete methods. Structs (`OmeletteBreakfast`, \n * `PancakeBreakfast`) implement this trait to provide specific behaviors for abstract \n * methods (`add_ingredients`, `cook`). This approach maintains the core concept of \n * the template method pattern while adapting it to Rust's trait and struct-based type system.\n */"}]},{"title":"Visitor","examples":[{"codeFile":"patterns/behavioural/visitor/example","code":"trait AnimalVisitor {\n    fn visit_lion(&self, lion: &Lion);\n    fn visit_elephant(&self, elephant: &Elephant);\n    fn visit_giraffe(&self, giraffe: &Giraffe);\n}\n\nstruct AnimalFeeder;\n\nimpl AnimalVisitor for AnimalFeeder {\n    fn visit_lion(&self, lion: &Lion) {\n        println!(\"Feeding meat to {}.\", lion.get_name());\n    }\n\n    fn visit_elephant(&self, elephant: &Elephant) {\n        println!(\"Feeding hay to {}.\", elephant.get_name());\n    }\n\n    fn visit_giraffe(&self, giraffe: &Giraffe) {\n        println!(\"Feeding leaves to {}.\", giraffe.get_name());\n    }\n}\n\ntrait Animal {\n    fn accept(&self, visitor: &dyn AnimalVisitor);\n}\n\nstruct Lion {\n    name: String,\n}\n\nimpl Lion {\n    fn new(name: &str) -> Lion {\n        Lion { name: name.to_string() }\n    }\n\n    fn get_name(&self) -> &str {\n        &self.name\n    }\n}\n\nimpl Animal for Lion {\n    fn accept(&self, visitor: &dyn AnimalVisitor) {\n        visitor.visit_lion(self);\n    }\n}\n\nstruct Elephant {\n    name: String,\n}\n\nimpl Elephant {\n    fn new(name: &str) -> Elephant {\n        Elephant { name: name.to_string() }\n    }\n\n    fn get_name(&self) -> &str {\n        &self.name\n    }\n}\n\nimpl Animal for Elephant {\n    fn accept(&self, visitor: &dyn AnimalVisitor) {\n        visitor.visit_elephant(self);\n    }\n}\n\nstruct Giraffe {\n    name: String,\n}\n\nimpl Giraffe {\n    fn new(name: &str) -> Giraffe {\n        Giraffe { name: name.to_string() }\n    }\n\n    fn get_name(&self) -> &str {\n        &self.name\n    }\n}\n\nimpl Animal for Giraffe {\n    fn accept(&self, visitor: &dyn AnimalVisitor) {\n        visitor.visit_giraffe(self);\n    }\n}\n\nstruct Zoo {\n    animals: Vec<Box<dyn Animal>>,\n}\n\nimpl Zoo {\n    fn new() -> Zoo {\n        Zoo { animals: Vec::new() }\n    }\n\n    fn add_animal(&mut self, animal: Box<dyn Animal>) {\n        self.animals.push(animal);\n    }\n\n    fn perform_operation(&self, visitor: &dyn AnimalVisitor) {\n        for animal in &self.animals {\n            animal.accept(visitor);\n        }\n    }\n}\n\nfn main() {\n    let mut zoo = Zoo::new();\n    zoo.add_animal(Box::new(Lion::new(\"Simba\")));\n    zoo.add_animal(Box::new(Elephant::new(\"Dumbo\")));\n    zoo.add_animal(Box::new(Giraffe::new(\"Melman\")));\n\n    let feeder = AnimalFeeder;\n    zoo.perform_operation(&feeder);\n}"}]}],"patterns_creational":[{"title":"Factory Method","examples":[{"codeFile":"patterns/creational/factory-method/example","code":"trait Vehicle {\n    fn drive(&self);\n}\n\nstruct Car;\n\nimpl Vehicle for Car {\n    fn drive(&self) {\n        println!(\"Driving a car...\");\n    }\n}\n\nstruct Truck;\n\nimpl Vehicle for Truck {\n    fn drive(&self) {\n        println!(\"Driving a truck...\");\n    }\n}\n\ntrait VehicleFactory {\n    fn create_vehicle(&self) -> Box<dyn Vehicle>;\n\n    fn deliver_vehicle(&self) {\n        let vehicle = self.create_vehicle();\n        println!(\"Delivering the vehicle...\");\n        vehicle.drive();\n    }\n}\n\nstruct CarFactory;\n\nimpl VehicleFactory for CarFactory {\n    fn create_vehicle(&self) -> Box<dyn Vehicle> {\n        println!(\"Creating a car...\");\n        Box::new(Car)\n    }\n}\n\nstruct TruckFactory;\n\nimpl VehicleFactory for TruckFactory {\n    fn create_vehicle(&self) -> Box<dyn Vehicle> {\n        println!(\"Creating a truck...\");\n        Box::new(Truck)\n    }\n}\n\nfn main() {\n    let car_factory = CarFactory;\n    car_factory.deliver_vehicle();\n\n    let truck_factory = TruckFactory;\n    truck_factory.deliver_vehicle();\n}"}]},{"title":"Abstract Factory","examples":[{"codeFile":"patterns/creational/abstract-factory/example","code":"trait FurnitureFactory {\n    fn create_chair(&self) -> Box<dyn Chair>;\n    fn create_table(&self) -> Box<dyn Table>;\n}\n\nstruct ModernFurnitureFactory;\n\nimpl FurnitureFactory for ModernFurnitureFactory {\n    fn create_chair(&self) -> Box<dyn Chair> {\n        Box::new(ModernChair {})\n    }\n\n    fn create_table(&self) -> Box<dyn Table> {\n        Box::new(ModernTable {})\n    }\n}\n\nstruct VintageFurnitureFactory;\n\nimpl FurnitureFactory for VintageFurnitureFactory {\n    fn create_chair(&self) -> Box<dyn Chair> {\n        Box::new(VintageChair {})\n    }\n\n    fn create_table(&self) -> Box<dyn Table> {\n        Box::new(VintageTable {})\n    }\n}\n\ntrait Chair {\n    fn sit_on(&self);\n}\n\nstruct ModernChair;\n\nimpl Chair for ModernChair {\n    fn sit_on(&self) {\n        println!(\"Sitting on a modern chair.\");\n    }\n}\n\nstruct VintageChair;\n\nimpl Chair for VintageChair {\n    fn sit_on(&self) {\n        println!(\"Sitting on a vintage chair.\");\n    }\n}\n\ntrait Table {\n    fn put_on(&self);\n}\n\nstruct ModernTable;\n\nimpl Table for ModernTable {\n    fn put_on(&self) {\n        println!(\"Putting something on a modern table.\");\n    }\n}\n\nstruct VintageTable;\n\nimpl Table for VintageTable {\n    fn put_on(&self) {\n        println!(\"Putting something on a vintage table.\");\n    }\n}\n\nfn create_furniture(factory: &dyn FurnitureFactory) {\n    let chair = factory.create_chair();\n    let table = factory.create_table();\n\n    println!(\"Created furniture:\");\n    chair.sit_on();\n    table.put_on();\n}\n\nfn main() {\n    println!(\"Creating modern furniture:\");\n    create_furniture(&ModernFurnitureFactory);\n\n    println!(\"\\nCreating vintage furniture:\");\n    create_furniture(&VintageFurnitureFactory);\n}"}]},{"title":"Builder","examples":[{"codeFile":"patterns/creational/builder/example","code":"struct Computer {\n    cpu: String,\n    ram: u32,\n    storage: u32,\n    gpu: String,\n    screen_size: u32,\n}\n\nimpl Computer {\n    fn new(cpu: String, ram: u32, storage: u32, gpu: String, screen_size: u32) -> Self {\n        Self { cpu, ram, storage, gpu, screen_size }\n    }\n\n    fn display_specs(&self) {\n        println!(\"CPU: {}\", self.cpu);\n        println!(\"RAM: {} GB\", self.ram);\n        println!(\"Storage: {} GB\", self.storage);\n        println!(\"GPU: {}\", self.gpu);\n        println!(\"Screen Size: {} inches\", self.screen_size);\n    }\n}\n\ntrait ComputerBuilder {\n    fn set_cpu(&mut self, cpu: String);\n    fn set_ram(&mut self, ram: u32);\n    fn set_storage(&mut self, storage: u32);\n    fn set_gpu(&mut self, gpu: String);\n    fn set_screen_size(&mut self, screen_size: u32);\n    fn build(&self) -> Computer;\n}\n\nstruct GamingComputerBuilder {\n    computer: Computer,\n}\n\nimpl GamingComputerBuilder {\n    fn new() -> Self {\n        Self {\n            computer: Computer::new(String::new(), 0, 0, String::new(), 0),\n        }\n    }\n}\n\nimpl ComputerBuilder for GamingComputerBuilder {\n    fn set_cpu(&mut self, cpu: String) {\n        self.computer.cpu = cpu;\n    }\n\n    fn set_ram(&mut self, ram: u32) {\n        self.computer.ram = ram;\n    }\n\n    fn set_storage(&mut self, storage: u32) {\n        self.computer.storage = storage;\n    }\n\n    fn set_gpu(&mut self, gpu: String) {\n        self.computer.gpu = gpu;\n    }\n\n    fn set_screen_size(&mut self, screen_size: u32) {\n        self.computer.screen_size = screen_size;\n    }\n\n    fn build(&self) -> Computer {\n        Computer::new(\n            self.computer.cpu.clone(),\n            self.computer.ram,\n            self.computer.storage,\n            self.computer.gpu.clone(),\n            self.computer.screen_size,\n        )\n    }\n}\n\nstruct ComputerBuilderDirector {\n    builder: Box<dyn ComputerBuilder>,\n}\n\nimpl ComputerBuilderDirector {\n    fn construct_gaming_computer(&mut self) {\n        self.builder.set_cpu(\"Intel Core i9\".to_string());\n        self.builder.set_ram(32);\n        self.builder.set_storage(1000);\n        self.builder.set_gpu(\"NVIDIA GeForce RTX 3080\".to_string());\n        self.builder.set_screen_size(27);\n    }\n}\n\nfn main() {\n    let mut gaming_computer_builder = GamingComputerBuilder::new();\n    let mut director = ComputerBuilderDirector {\n        builder: Box::new(gaming_computer_builder),\n    };\n\n    director.construct_gaming_computer();\n    let gaming_computer = director.builder.build();\n    println!(\"Gaming Computer Specifications:\");\n    gaming_computer.display_specs();\n}"}]},{"title":"Prototype","examples":[{"codeFile":"patterns/creational/prototype/example","code":"use std::fmt;\n\n// UserProfile trait: Defines an interface for cloning and customizing the profile, along with a method for displaying the profile\ntrait UserProfile: Clone {\n    fn customize_profile(&mut self, settings: UserProfileSettings);\n    fn display_profile(&self);\n}\n\n// DefaultUserProfile struct: A concrete implementation of the UserProfile trait\n#[derive(Clone)]\nstruct DefaultUserProfile {\n    username: String,\n    bio: String,\n    profile_picture: String,\n}\n\nimpl DefaultUserProfile {\n    fn new(username: String, bio: String, profile_picture: String) -> Self {\n        Self {\n            username,\n            bio,\n            profile_picture,\n        }\n    }\n}\n\nimpl UserProfile for DefaultUserProfile {\n    fn customize_profile(&mut self, settings: UserProfileSettings) {\n        if let Some(username) = settings.username {\n            self.username = username;\n        }\n        if let Some(bio) = settings.bio {\n            self.bio = bio;\n        }\n        if let Some(profile_picture) = settings.profile_picture {\n            self.profile_picture = profile_picture;\n        }\n    }\n\n    fn display_profile(&self) {\n        println!(\"Username: {}\", self.username);\n        println!(\"Bio: {}\", self.bio);\n        println!(\"Profile Picture: {}\", self.profile_picture);\n    }\n}\n\n// UserProfileSettings struct: Represents optional settings for customizing a user profile\nstruct UserProfileSettings {\n    username: Option<String>,\n    bio: Option<String>,\n    profile_picture: Option<String>,\n}\n\nimpl UserProfileSettings {\n    pub fn new(username: Option<String>, bio: Option<String>, profile_picture: Option<String>) -> Self {\n        Self {\n            username,\n            bio,\n            profile_picture,\n        }\n    }\n}\n\nfn main() {\n    // Creating a default user profile\n    let default_profile = DefaultUserProfile::new(\n        \"user123\".into(),\n        \"Welcome to my profile!\".into(),\n        \"default.jpg\".into(),\n    );\n\n    // Cloning the default profile to create a customized profile\n    let mut customized_profile = default_profile.clone();\n    customized_profile.customize_profile(UserProfileSettings::new(\n        None,\n        Some(\"I'm a software developer.\".into()),\n        Some(\"avatar.jpg\".into()),\n    ));\n\n    // Displaying both profiles\n    println!(\"Default Profile:\");\n    default_profile.display_profile();\n\n    println!(\"\\nCustomized Profile:\");\n    customized_profile.display_profile();\n\n    // The use of the Prototype pattern in Rust involves the Clone trait to create a new instance of a struct. \n    // The UserProfile trait and its methods allow for customizing and displaying the profile. The UserProfileSettings \n    // struct replaces the interface for optional settings, illustrating the use of the Prototype pattern to create \n    // and customize objects by cloning existing ones.\n}"}]},{"title":"Singleton","examples":[{"codeFile":"patterns/creational/singleton/example","code":"use std::sync::Mutex;\nuse std::sync::Arc;\nuse once_cell::sync::OnceCell;\n\nstruct Logger {\n    log_history: Mutex<Vec<String>>, // Mutex is used to ensure thread safety\n}\n\nimpl Logger {\n    fn get_instance() -> &'static Arc<Logger> {\n        static INSTANCE: OnceCell<Arc<Logger>> = OnceCell::new();\n        INSTANCE.get_or_init(|| {\n            Arc::new(Logger {\n                log_history: Mutex::new(vec![]),\n            })\n        })\n    }\n\n    fn log(&self, message: &str) {\n        let timestamp = chrono::Utc::now().to_rfc3339();\n        let log_entry = format!(\"[{}] {}\", timestamp, message);\n        \n        let mut log_history = self.log_history.lock().unwrap();\n        log_history.push(log_entry.clone());\n        println!(\"{}\", log_entry);        \n    }\n\n    fn get_log_history(&self) -> Vec<String> {\n        let log_history = self.log_history.lock().unwrap();\n        log_history.clone()\n    }\n}\n\nfn main() {\n    let logger1 = Logger::get_instance();\n    let logger2 = Logger::get_instance();\n\n    println!(\"{}\", Arc::ptr_eq(logger1, logger2)); // Output: true, both Arcs point to the same instance\n\n    logger1.log(\"User logged in\");\n    logger2.log(\"Data saved to database\");\n\n    println!(\"{:?}\", logger1.get_log_history());\n\n    // The Logger struct now uses a static OnceCell to lazy initialize a thread-safe, Arc-wrapped instance.\n    // This ensures that only one instance of Logger is created and shared across the application.\n    // The Mutex inside the Logger struct ensures that log_history can be safely accessed from multiple threads.\n    // The use of Arc and Mutex makes the Logger thread-safe and fits well with Rust's ownership and concurrency model.\n    // The getInstance() method has been renamed to get_instance() to follow Rust's naming conventions.\n    // The log() and get_log_history() methods function similarly to their original counterparts, but are adapted to work with Rust's type system and concurrency model.\n    // In the client code, Arc::ptr_eq function checks if two Arc pointers point to the same instance, confirming the singleton behavior.\n    // Rust's chrono crate is used for timestamp generation to log messages with their creation time.\n    // This translation not only changes the syntax but also adapts the singleton pattern to fit idiomatic Rust, ensuring thread safety and leveraging Rust's powerful concurrency primitives.\n}"}]}],"patterns_structural":[{"title":"Adapter","examples":[{"codeFile":"patterns/structural/adapter/example","code":"struct Mp3Player;\n\nimpl Mp3Player {\n    fn play_mp3(&self, file_name: &str) {\n        println!(\"Playing MP3 file: {}\", file_name);\n    }\n}\n\ntrait AudioPlayer {\n    fn play(&self, file_name: &str);\n}\n\nstruct OggToMp3Adapter {\n    mp3_player: Mp3Player,\n}\n\nimpl OggToMp3Adapter {\n    fn new() -> Self {\n        OggToMp3Adapter {\n            mp3_player: Mp3Player,\n        }\n    }\n\n    fn convert_to_mp3(&self, file_name: &str) -> String {\n        // Simulate conversion process (replace extension)\n        file_name.replace(\".ogg\", \".mp3\")\n    }\n}\n\nimpl AudioPlayer for OggToMp3Adapter {\n    fn play(&self, file_name: &str) {\n        // Convert OGG to MP3 and play using the MP3 player\n        println!(\"Converting OGG file '{}' to MP3 format\", file_name);\n        let mp3_file_name = self.convert_to_mp3(file_name);\n        self.mp3_player.play_mp3(&mp3_file_name);\n    }\n}\n\nfn main() {\n    // Client code\n    let audio_player: Box<dyn AudioPlayer> = Box::new(OggToMp3Adapter::new());\n\n    // Play MP3 file\n    audio_player.play(\"audio1.mp3\");\n\n    // Play OGG file (automatically converted to MP3)\n    audio_player.play(\"audio2.ogg\");\n}"}]},{"title":"Bridge","examples":[{"codeFile":"patterns/structural/bridge/example","code":"trait Workshop {\n    fn work(&self);\n}\n\nstruct PaintWorkshop;\n\nimpl Workshop for PaintWorkshop {\n    fn work(&self) {\n        println!(\"Painting vehicle\");\n    }\n}\n\nstruct RepairWorkshop;\n\nimpl Workshop for RepairWorkshop {\n    fn work(&self) {\n        println!(\"Repairing vehicle\");\n    }\n}\n\n// The Abstraction: Vehicle, now a trait in Rust\ntrait Vehicle {\n    fn manufacture(&self);\n}\n\n// Refined Abstraction: Car, implementing Vehicle\nstruct Car<T: Workshop> {\n    workshop: T,\n}\n\nimpl<T: Workshop> Vehicle for Car<T> {\n    fn manufacture(&self) {\n        println!(\"Manufacturing car.\");\n        self.workshop.work();\n    }\n}\n\n// Refined Abstraction: Truck, implementing Vehicle\nstruct Truck<T: Workshop> {\n    workshop: T,\n}\n\nimpl<T: Workshop> Vehicle for Truck<T> {\n    fn manufacture(&self) {\n        println!(\"Manufacturing truck.\");\n        self.workshop.work();\n    }\n}\n\n// Client code\nfn main() {\n    let car = Car {\n        workshop: PaintWorkshop,\n    };\n    car.manufacture(); // Output: Manufacturing car. Painting vehicle\n\n    let truck = Truck {\n        workshop: RepairWorkshop,\n    };\n    truck.manufacture(); // Output: Manufacturing truck. Repairing vehicle\n\n    // The Vehicle trait represents the abstraction, which is implemented by Car and Truck.\n    //\n    // The Workshop trait represents the implementor, defining the work method.\n    //\n    // PaintWorkshop and RepairWorkshop are concrete implementations of the Workshop trait.\n    //\n    // Each vehicle can be associated with a specific workshop using generic types, and it delegates the work to that workshop.\n}"}]},{"title":"Composite","examples":[{"codeFile":"patterns/structural/composite/example","code":"use std::cell::RefCell;\nuse std::rc::Rc;\n\ntrait Department {\n    fn get_name(&self) -> String;\n    fn get_employees(&self) -> Vec<String>;\n}\n\nstruct IndividualDepartment {\n    name: String,\n    employees: Vec<String>,\n}\n\nimpl IndividualDepartment {\n    fn new(name: String, employees: Vec<String>) -> Self {\n        Self { name, employees }\n    }\n}\n\nimpl Department for IndividualDepartment {\n    fn get_name(&self) -> String {\n        self.name.clone()\n    }\n\n    fn get_employees(&self) -> Vec<String> {\n        self.employees.clone()\n    }\n}\n\nstruct CompositeDepartment {\n    name: String,\n    departments: Vec<Rc<RefCell<dyn Department>>>,\n}\n\nimpl CompositeDepartment {\n    fn new(name: String) -> Self {\n        Self {\n            name,\n            departments: Vec::new(),\n        }\n    }\n\n    fn add_department(&mut self, department: Rc<RefCell<dyn Department>>) {\n        self.departments.push(department);\n    }\n\n    fn remove_department(&mut self, department: &Rc<RefCell<dyn Department>>) {\n        self.departments.retain(|d| !Rc::ptr_eq(d, department));\n    }\n}\n\nimpl Department for CompositeDepartment {\n    fn get_name(&self) -> String {\n        self.name.clone()\n    }\n\n    fn get_employees(&self) -> Vec<String> {\n        self.departments.iter().fold(Vec::new(), |mut employees, department| {\n            employees.extend(department.borrow().get_employees());\n            employees\n        })\n    }\n}\n\nfn main() {\n    let sales_department = Rc::new(RefCell::new(IndividualDepartment::new(\n        \"Sales Department\".to_string(),\n        vec![\"John\".to_string(), \"Alice\".to_string(), \"Bob\".to_string()],\n    )));\n    let marketing_department = Rc::new(RefCell::new(IndividualDepartment::new(\n        \"Marketing Department\".to_string(),\n        vec![\"Emily\".to_string(), \"David\".to_string()],\n    )));\n    let engineering_department = Rc::new(RefCell::new(IndividualDepartment::new(\n        \"Engineering Department\".to_string(),\n        vec![\"Michael\".to_string(), \"Sarah\".to_string(), \"Chris\".to_string()],\n    )));\n\n    let head_department = Rc::new(RefCell::new(CompositeDepartment::new(\"Head Department\".to_string())));\n    head_department.borrow_mut().add_department(sales_department.clone());\n    head_department.borrow_mut().add_department(marketing_department.clone());\n\n    let parent_engineering_department = Rc::new(RefCell::new(CompositeDepartment::new(\"Parent Engineering Department\".to_string())));\n    parent_engineering_department.borrow_mut().add_department(engineering_department.clone());\n\n    let root_department = Rc::new(RefCell::new(CompositeDepartment::new(\"Root Department\".to_string())));\n    root_department.borrow_mut().add_department(head_department.clone());\n    root_department.borrow_mut().add_department(parent_engineering_department.clone());\n\n    println!(\"Employees in the root department:\");\n    for employee in root_department.borrow().get_employees() {\n        println!(\"{}\", employee);\n    }\n}\n// This Rust example adheres to the Composite Design Pattern principles, refining the provided code while keeping the explanatory comments through idiomatic Rust practices."}]},{"title":"Decorator","examples":[{"codeFile":"patterns/structural/decorator/example","code":"trait Notification {\n    fn send(&self) -> String;\n}\n\nstruct BaseNotification;\n\nimpl Notification for BaseNotification {\n    fn send(&self) -> String {\n        \"Base notification: You have a new message!\".to_string()\n    }\n}\n\ntrait NotificationDecorator: Notification {\n    fn new_boxed(notif: Box<dyn Notification>) -> Box<dyn Notification>;\n}\n\nstruct SoundNotificationDecorator {\n    notification: Box<dyn Notification>,\n}\n\nimpl SoundNotificationDecorator {\n    fn new(notification: Box<dyn Notification>) -> Self {\n        SoundNotificationDecorator { notification }\n    }\n}\n\nimpl Notification for SoundNotificationDecorator {\n    fn send(&self) -> String {\n        format!(\"{} (Sound notification: Ding!)\", self.notification.send())\n    }\n}\n\nstruct PriorityNotificationDecorator {\n    notification: Box<dyn Notification>,\n}\n\nimpl PriorityNotificationDecorator {\n    fn new(notification: Box<dyn Notification>) -> Self {\n        PriorityNotificationDecorator { notification }\n    }\n}\n\nimpl Notification for PriorityNotificationDecorator {\n    fn send(&self) -> String {\n        format!(\"{} (Priority notification: High priority!)\", self.notification.send())\n    }\n}\n\nfn main() {\n    let base_notification = Box::new(BaseNotification);\n\n    let sound_notification = Box::new(SoundNotificationDecorator::new(base_notification.clone()));\n    println!(\"{}\", sound_notification.send());\n\n    let priority_notification = Box::new(PriorityNotificationDecorator::new(base_notification.clone()));\n    println!(\"{}\", priority_notification.send());\n\n    let sound_and_priority_notification = Box::new(PriorityNotificationDecorator::new(Box::new(SoundNotificationDecorator::new(base_notification))));\n    println!(\"{}\", sound_and_priority_notification.send());\n}"}]},{"title":"Facade","examples":[{"codeFile":"patterns/structural/facade/example","code":"struct FlightBookingSystem;\n\nimpl FlightBookingSystem {\n    fn book_flight(&self, origin: &str, destination: &str) -> String {\n        format!(\"Flight booked from {} to {}\", origin, destination)\n    }\n}\n\nstruct HotelBookingSystem;\n\nimpl HotelBookingSystem {\n    fn book_hotel(&self, location: &str, check_in_date: &str, check_out_date: &str) -> String {\n        format!(\"Hotel booked at {} from {} to {}\", location, check_in_date, check_out_date)\n    }\n}\n\nstruct CarRentalSystem;\n\nimpl CarRentalSystem {\n    fn rent_car(&self, location: &str, start_date: &str, end_date: &str) -> String {\n        format!(\"Car rented at {} from {} to {}\", location, start_date, end_date)\n    }\n}\n\nstruct TravelFacade {\n    flight_booking_system: FlightBookingSystem,\n    hotel_booking_system: HotelBookingSystem,\n    car_rental_system: CarRentalSystem,\n}\n\nimpl TravelFacade {\n    fn new() -> Self {\n        TravelFacade {\n            flight_booking_system: FlightBookingSystem,\n            hotel_booking_system: HotelBookingSystem,\n            car_rental_system: CarRentalSystem,\n        }\n    }\n\n    fn book_travel(&self, origin: &str, destination: &str, location: &str, check_in_date: &str, check_out_date: &str, start_date: &str, end_date: &str) -> String {\n        let flight_details = self.flight_booking_system.book_flight(origin, destination);\n        let hotel_details = self.hotel_booking_system.book_hotel(location, check_in_date, check_out_date);\n        let car_details = self.car_rental_system.rent_car(location, start_date, end_date);\n\n        format!(\"{}\\n{}\\n{}\", flight_details, hotel_details, car_details)\n    }\n}\n\nfn main() {\n    let travel_facade = TravelFacade::new();\n    let booking_details = travel_facade.book_travel(\"New York\", \"Los Angeles\", \"Hilton\", \"2023-12-15\", \"2023-12-20\", \"2023-12-15\", \"2023-12-20\");\n    println!(\"{}\", booking_details);\n}\n\n// The FlightBookingSystem, HotelBookingSystem, and CarRentalSystem structures represent the\n// subsystems of flight booking, hotel booking, and car rental, respectively.\n//\n// The TravelFacade struct provides a simplified interface for booking a complete travel\n// package. It encapsulates the complexities of interacting with the subsystems.\n//\n// The client code interacts with the TravelFacade to book a complete travel package without\n// directly interacting with the subsystems.\n"}]},{"title":"Flyweight","examples":[{"codeFile":"patterns/structural/flyweight/example","code":"struct Character {\n    character: char,\n}\n\nimpl Character {\n    fn new(character: char) -> Self {\n        Character { character }\n    }\n\n    fn display(&self, font: &str, size: u32) -> String {\n        format!(\"Character: {}, Font: {}, Size: {}\", self.character, font, size)\n    }\n}\n\nstruct CharacterFactory {\n    characters: std::collections::HashMap<char, Character>,\n}\n\nimpl CharacterFactory {\n    fn new() -> Self {\n        CharacterFactory {\n            characters: std::collections::HashMap::new(),\n        }\n    }\n\n    fn get_character(&mut self, character: char) -> &Character {\n        self.characters\n            .entry(character)\n            .or_insert_with(|| Character::new(character))\n    }\n}\n\nfn main() {\n    let mut character_factory = CharacterFactory::new();\n\n    let text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\";\n\n    let rendered_text: Vec<String> = text.chars()\n        .map(|char| {\n            character_factory\n                .get_character(char)\n                .display(\"Arial\", 12) // Assume same font and size for simplicity\n        })\n        .collect();\n\n    println!(\"{}\", rendered_text.join(\"\\n\"));\n}\n\n/*\n * The Character struct represents the flyweight object for a character. It contains intrinsic\n * state (the character itself).\n *\n * The CharacterFactory struct acts as a flyweight factory, creating and managing flyweight\n * objects. It ensures that each character is shared among multiple instances.\n *\n * In the main function, we create a text document and render it using flyweight characters.\n * Instead of creating a new character object for each character in the text, we retrieve\n * existing flyweight characters from the factory, saving memory and improving performance.\n */"}]},{"title":"Proxy","examples":[{"codeFile":"patterns/structural/proxy/example","code":"use std::future::Future;\nuse std::pin::Pin;\n\n// Trait representing the common behavior of RealSubject and Proxy\ntrait IHttpServer {\n    fn request(&self, url: &str) -> Pin<Box<dyn Future<Output = String> + Send + '_>>;\n}\n\n// RealSubject: The actual HTTP server implementation\nstruct HttpServer;\n\nimpl IHttpServer for HttpServer {\n    fn request(&self, url: &str) -> Pin<Box<dyn Future<Output = String> + Send + '_>> {\n        Box::pin(async move {\n            // Simulating HTTP request to the actual server\n            format!(\"Response from server for URL: {}\", url)\n        })\n    }\n}\n\n// Proxy: Proxy server that intercepts requests before forwarding them to the real server\nstruct ProxyServer {\n    http_server: HttpServer,\n}\n\nimpl ProxyServer {\n    fn new() -> Self {\n        ProxyServer {\n            http_server: HttpServer,\n        }\n    }\n}\n\nimpl IHttpServer for ProxyServer {\n    fn request(&self, url: &str) -> Pin<Box<dyn Future<Output = String> + Send + '_>> {\n        Box::pin(async move {\n            // Additional logic can be added here, e.g., caching, access control, logging\n            println!(\"Proxy: Intercepted request for URL: {}\", url);\n\n            // Forward the request to the real server\n            let response = self.http_server.request(url).await;\n\n            // Additional processing on the response can be done here\n\n            response\n        })\n    }\n}\n\n// Client code\nasync fn test_proxy() {\n    let proxy = ProxyServer::new();\n\n    // Client sends a request to the proxy server\n    let response = proxy.request(\"https://example.com\").await;\n\n    println!(\"{}\", response);\n}\n\n#[tokio::main]\nasync fn main() {\n    // Test the proxy\n    test_proxy().await;\n}"}]}]},"principles":{"principles_solid":[{"title":"Single Responsibility Principle (SRP)","examples":[{"title":"Good Example","codeFile":"principles/solid/single-responsibility/good-example","code":"struct Employee {\n    name: String,\n    position: String,\n    salary: u64,\n}\n\nimpl Employee {\n    // Employee struct responsible only for storing employee data\n    fn new(name: &str, position: &str, salary: u64) -> Self {\n        Employee {\n            name: name.to_string(),\n            position: position.to_string(),\n            salary,\n        }\n    }\n\n    fn get_name(&self) -> &String {\n        &self.name\n    }\n\n    fn get_position(&self) -> &String {\n        &self.position\n    }\n\n    fn get_salary(&self) -> u64 {\n        self.salary\n    }\n}\n\nstruct EmployeePrinter;\n\nimpl EmployeePrinter {\n    // Printer struct responsible only for printing employee information\n    fn print(&self, employee: &Employee) {\n        println!(\"Name: {}\", employee.get_name());\n        println!(\"Position: {}\", employee.get_position());\n        println!(\"Salary: {}\", employee.get_salary());\n    }\n}\n\nfn main() {\n    let employee = Employee::new(\"John Doe\", \"Software Engineer\", 50000);\n    let printer = EmployeePrinter {};\n    printer.print(&employee);\n}"},{"title":"Bad Example","codeFile":"principles/solid/single-responsibility/bad-example","code":"struct Employee {\n    name: String,\n    position: String,\n    salary: u32,\n}\n\nimpl Employee {\n    // Constructor method to initialize the Employee struct\n    fn new(name: String, position: String, salary: u32) -> Employee {\n        Employee {\n            name,\n            position,\n            salary,\n        }\n    }\n\n    // Method responsible for printing employee information\n    fn print(&self) {\n        println!(\"Name: {}\", self.name);\n        println!(\"Position: {}\", self.position);\n        println!(\"Salary: {}\", self.salary);\n    }\n}\n\nfn main() {\n    // Usage\n    let employee = Employee::new(\"John Doe\".to_string(), \"Software Engineer\".to_string(), 50000);\n    employee.print();\n}"}]},{"title":"Open/Closed Principle (OCP)","examples":[{"title":"Good Example","codeFile":"principles/solid/open-closed/good-example","code":"trait Shape {\n    // Define a method in the trait, which will be implemented by subclasses\n    fn compute_area(&self) -> f64;\n}\n\nstruct Rectangle {\n    width: f64,\n    height: f64,\n}\n\nimpl Shape for Rectangle {\n    // Implement compute_area for Rectangle\n    fn compute_area(&self) -> f64 {\n        self.width * self.height\n    }\n}\n\nstruct Circle {\n    radius: f64,\n}\n\nimpl Shape for Circle {\n    // Implement compute_area for Circle\n    fn compute_area(&self) -> f64 {\n        std::f64::consts::PI * self.radius * self.radius\n    }\n}"},{"title":"Bad Example","codeFile":"principles/solid/open-closed/bad-example","code":"struct Rectangle {\n    width: f64,\n    height: f64,\n}\n\nstruct Circle {\n    radius: f64,\n}\n\n// Defining a trait for shapes that can have their area computed\ntrait Area {\n    fn compute_area(&self) -> f64;\n}\n\n// Implementing the Area trait for Rectangle\nimpl Area for Rectangle {\n    fn compute_area(&self) -> f64 {\n        self.width * self.height\n    }\n}\n\n// Implementing the Area trait for Circle\nimpl Area for Circle {\n    fn compute_area(&self) -> f64 {\n        std::f64::consts::PI * self.radius * self.radius\n    }\n}\n\n// AreaCalculator is simplified by utilizing polymorphism,\n// which is more idiomatic to Rust through the use of traits.\nstruct AreaCalculator;\n\nimpl AreaCalculator {\n    // compute_area now accepts a reference to something that implements the Area trait\n    fn compute_area<T: Area>(shape: &T) -> f64 {\n        shape.compute_area()\n    }\n}"}]},{"title":"Liskov Substitution Principle (LSP)","examples":[{"title":"Good Example","codeFile":"principles/solid/liskov-substitution/good-example","code":"trait Fly {\n    fn fly(&self);\n}\n\nstruct Bird;\nimpl Fly for Bird {\n    fn fly(&self) {\n        println!(\"Bird is flying\");\n    }\n}\n\nstruct Duck;\nimpl Fly for Duck {\n    fn fly(&self) {\n        println!(\"Bird is flying\");\n    }\n}\nimpl Duck {\n    fn quack(&self) {\n        println!(\"Duck is quacking\");\n    }\n}\n\nstruct Goose;\nimpl Fly for Goose {\n    fn fly(&self) {\n        println!(\"Bird is flying\");\n    }\n}\nimpl Goose {\n    fn swim(&self) {\n        println!(\"Goose is swimming\");\n    }\n}\n\nfn make_bird_fly<T: Fly>(bird: &T) {\n    bird.fly();\n}\n\nfn main() {\n    let duck = Duck;\n    let goose = Goose;\n\n    make_bird_fly(&duck);    // Output: Bird is flying\n    make_bird_fly(&goose);   // Output: Bird is flying\n}"},{"title":"Bad Example","codeFile":"principles/solid/liskov-substitution/bad-example","code":"trait Bird {\n    fn fly(&self);\n}\n\nstruct FlyingBird;\nimpl Bird for FlyingBird {\n    fn fly(&self) {\n        // Implementation for birds that can fly\n    }\n}\n\nstruct Ostrich;\nimpl Bird for Ostrich {\n    fn fly(&self) {\n        panic!(\"Can't fly\"); // Ostrich, being a Bird, should not attempt to implement fly\n    }\n}\n\n// A more idiomatic approach in Rust involves separating the concepts of flying\n// and not flying into different traits or avoiding calling fly on an Ostrich.\n\ntrait Fly {\n    fn fly(&self);\n}\n\nstruct Sparrow; // Sparrow can fly\nimpl Fly for Sparrow {\n    fn fly(&self) {\n        // Implementation for flying\n    }\n}\n\n// Bird now does not require fly method\ntrait Bird {}\n\nimpl Bird for Sparrow {} // Sparrow is a Bird\nimpl Bird for Ostrich {} // Ostrich is also a Bird but does not implement Fly, avoiding the violation of Liskov Substitution Principle."}]},{"title":"Interface Segregation Principle (ISP)","examples":[{"title":"Good Example","codeFile":"principles/solid/interface-segregation/good-example","code":"trait Printer {\n    fn print_document(&self);\n}\n\ntrait Fax {\n    fn fax_document(&self);\n}\n\ntrait Scanner {\n    fn scan_document(&self);\n}\n\nstruct SimplePrinter;\n\nimpl Printer for SimplePrinter {\n    fn print_document(&self) {\n        println!(\"Printing document...\");\n    }\n}\n\nstruct MultifunctionalPrinter;\n\nimpl Printer for MultifunctionalPrinter {\n    fn print_document(&self) {\n        println!(\"Printing document...\");\n    }\n}\n\nimpl Fax for MultifunctionalPrinter {\n    fn fax_document(&self) {\n        println!(\"Faxing document...\");\n    }\n}\n\nimpl Scanner for MultifunctionalPrinter {\n    fn scan_document(&self) {\n        println!(\"Scanning document...\");\n    }\n}"},{"title":"Bad Example","codeFile":"principles/solid/interface-segregation/bad-example","code":"trait Printer {\n    fn print_document(&self);\n}\n\ntrait Fax {\n    fn fax_document(&self);\n}\n\ntrait Scanner {\n    fn scan_document(&self);\n}\n\n// Implementing only the necessary traits for OldPrinter\nstruct OldPrinter;\n\nimpl Printer for OldPrinter {\n    fn print_document(&self) {\n        println!(\"Printing document...\");\n    }\n}\n\n// Example use\nfn main() {\n    let printer = OldPrinter;\n    printer.print_document();\n    // The following lines are commented out because OldPrinter does not implement these actions.\n    //printer.fax_document();\n    //printer.scan_document();\n}"}]},{"title":"Dependency Inversion Principle (DIP)","examples":[{"title":"Good Example","codeFile":"principles/solid/interface-segregation/good-example","code":"trait Printer {\n    fn print_document(&self);\n}\n\ntrait Fax {\n    fn fax_document(&self);\n}\n\ntrait Scanner {\n    fn scan_document(&self);\n}\n\nstruct SimplePrinter;\n\nimpl Printer for SimplePrinter {\n    fn print_document(&self) {\n        println!(\"Printing document...\");\n    }\n}\n\nstruct MultifunctionalPrinter;\n\nimpl Printer for MultifunctionalPrinter {\n    fn print_document(&self) {\n        println!(\"Printing document...\");\n    }\n}\n\nimpl Fax for MultifunctionalPrinter {\n    fn fax_document(&self) {\n        println!(\"Faxing document...\");\n    }\n}\n\nimpl Scanner for MultifunctionalPrinter {\n    fn scan_document(&self) {\n        println!(\"Scanning document...\");\n    }\n}"},{"title":"Bad Example","codeFile":"principles/solid/interface-segregation/bad-example","code":"trait Printer {\n    fn print_document(&self);\n}\n\ntrait Fax {\n    fn fax_document(&self);\n}\n\ntrait Scanner {\n    fn scan_document(&self);\n}\n\n// Implementing only the necessary traits for OldPrinter\nstruct OldPrinter;\n\nimpl Printer for OldPrinter {\n    fn print_document(&self) {\n        println!(\"Printing document...\");\n    }\n}\n\n// Example use\nfn main() {\n    let printer = OldPrinter;\n    printer.print_document();\n    // The following lines are commented out because OldPrinter does not implement these actions.\n    //printer.fax_document();\n    //printer.scan_document();\n}"}]}],"principles_other":[{"title":"Don't Repeat Yourself (DRY)","examples":[{"title":"Good Example","codeFile":"principles/other/dry/good-example","code":"fn add_tax(price: f64, rate: f64) -> f64 {\n    price * (1.0 + rate)\n}\n\nfn main() {\n    // Using a default rate if one is not specified\n    let default_rate = 0.05;\n    let price = 100.0;\n\n    // Example usage with default tax rate\n    let total_price_default_rate = add_tax(price, default_rate);\n    println!(\"Total price with default rate: {}\", total_price_default_rate);\n\n    // Example usage with specified tax rate\n    let specified_rate = 0.10;\n    let total_price_specified_rate = add_tax(price, specified_rate);\n    println!(\"Total price with specified rate: {}\", total_price_specified_rate);\n}"},{"title":"Bad Example","codeFile":"principles/other/dry/bad-example","code":"fn add_tax(price: f32, tax_rate: f32) -> f32 {\n    // Calculate price after tax\n    price + (price * tax_rate)\n}\n\n// Usage\nfn main() {\n    let food_price_with_tax = add_tax(100.0, 0.05); // Adding 5% tax for food\n    let electronics_price_with_tax = add_tax(100.0, 0.05); // Adding 5% tax for electronics\n    \n    println!(\"Food price after tax: {}\", food_price_with_tax);\n    println!(\"Electronics price after tax: {}\", electronics_price_with_tax);\n}"}]},{"title":"Keep It Simple Stupid (KISS)","examples":[{"title":"Good Example","codeFile":"principles/other/kiss/good-example","code":"fn is_even(num: i32) -> bool {\n    // Returns true if num is even\n    num % 2 == 0\n}"},{"title":"Bad Example","codeFile":"principles/other/kiss/bad-example","code":"fn is_even(num: i32) -> bool {\n    // there is no need for absolute value here\n    num % 2 == 0\n}"}]},{"title":"You Aren't Gonna Need It (YAGNI)","examples":[{"codeFile":"principles/other/yagni/bad-example","code":"struct Calculator;\n\nimpl Calculator {\n    fn add(a: i32, b: i32) -> i32 {\n        a + b\n    }\n\n    // Do not define methods unless they are used\n\n    // fn multiply(a: i32, b: i32) -> i32 {\n    //     a * b\n    // }\n\n    // fn divide(a: i32, b: i32) -> i32 {\n    //     if b == 0 {\n    //         panic!(\"Division by zero is not allowed.\");\n    //     }\n    //     a / b\n    // }\n\n    // fn subtract(a: i32, b: i32) -> i32 {\n    //     a - b\n    // }\n}"}]},{"title":"Law of Demeter (Principle of Least Knowledge)","examples":[{"title":"Good Example","codeFile":"principles/other/demeter/good-example","code":"struct Wallet {\n    money: u32,\n}\n\nimpl Wallet {\n    fn new() -> Wallet {\n        Wallet { money: 100 }\n    }\n\n    fn get_amount(&self) -> u32 {\n        self.money\n    }\n}\n\nstruct Person {\n    wallet: Wallet,\n}\n\nimpl Person {\n    fn new() -> Person {\n        Person {\n            wallet: Wallet::new(),\n        }\n    }\n\n    fn get_money_amount(&self) -> u32 {\n        // Following the Law of Demeter by not exposing internals of Wallet\n        self.wallet.get_amount()\n    }\n}\n\nfn purchase(item: &Item, buyer: &Person) {\n    if buyer.get_money_amount() >= item.price {\n        // Process the purchase\n    }\n}\n\nstruct Item {\n    price: u32,\n}"},{"title":"Bad Example","codeFile":"principles/other/demeter/bad-example","code":"struct Wallet {\n    money: Money,\n}\n\nimpl Wallet {\n    fn new() -> Self {\n        Self { money: Money { amount: 100 } }\n    }\n}\n\nstruct Money {\n    amount: i32,\n}\n\nstruct Person {\n    wallet: Wallet,\n}\n\nimpl Person {\n    fn new() -> Self {\n        Self { wallet: Wallet::new() }\n    }\n\n    // Providing a method to abstract away direct access to the 'money' field.\n    fn can_afford(&self, price: i32) -> bool {\n        self.wallet.money.amount >= price\n    }\n}\n\nstruct Item {\n    price: i32,\n}\n\n// Modified function to use Rust idioms and adhere to the Law of Demeter more closely by not directly accessing the wallet's money.\nfn purchase(item: &Item, buyer: &Person) {\n    if buyer.can_afford(item.price) {\n        /* ... */\n    }\n}"}]},{"title":"Separation of Concerns","examples":[{"title":"Good Example","codeFile":"principles/other/separation/good-example","code":"struct AuthenticationService;\n\nimpl AuthenticationService {\n    fn login(&self, _username: &str, _password: &str) -> bool {\n        // Authentication logic here\n        true // Dummy implementation\n    }\n\n    fn logout(&self) {\n        // Logout logic here\n    }\n}\n\nstruct DataService;\n\nimpl DataService {\n    fn fetch_data(&self) -> Vec<()> {\n        // Data retrieval logic here\n        vec![] // Dummy implementation\n    }\n}\n\nstruct UserController {\n    auth_service: AuthenticationService,\n}\n\nimpl UserController {\n    fn new(auth_service: AuthenticationService) -> Self {\n        Self { auth_service }\n    }\n\n    fn login_user(&self, username: &str, password: &str) -> bool {\n        self.auth_service.login(username, password)\n    }\n\n    fn logout_user(&self) {\n        self.auth_service.logout();\n    }\n}\n\nstruct DataController {\n    data_service: DataService,\n}\n\nimpl DataController {\n    fn new(data_service: DataService) -> Self {\n        Self { data_service }\n    }\n\n    fn get_data(&self) -> Vec<()> {\n        self.data_service.fetch_data()\n    }\n}\n\nfn main() {\n    let auth_service = AuthenticationService;\n    let data_service = DataService;\n\n    let user_controller = UserController::new(auth_service);\n    let data_controller = DataController::new(data_service);\n\n    // Simulate user login/logout\n    user_controller.login_user(\"username\", \"password\");\n    user_controller.logout_user();\n\n    // Retrieve data\n    let data = data_controller.get_data();\n    println!(\"{:?}\", data);\n}"},{"title":"Bad Example","codeFile":"principles/other/separation/bad-example","code":"struct AuthenticationService {}\n\nimpl AuthenticationService {\n    fn new() -> Self {\n        AuthenticationService {}\n    }\n\n    fn login(&self, _username: &str, _password: &str) -> bool {\n        // Authentication logic here\n        true // Dummy implementation\n    }\n\n    fn logout(&self) {\n        // Logout logic here\n    }\n}\n\nstruct DataService {}\n\nimpl DataService {\n    fn new() -> Self {\n        DataService {}\n    }\n\n    fn fetch_data(&self) -> Vec<()> {\n        // Data retrieval logic here\n        vec![] // Dummy implementation\n    }\n}\n\n/**\n * - The `CombinedController` struct is responsible for both user authentication and data retrieval.\n * - The `login_user` method not only handles authentication but also retrieves user data directly\n *   from the `DataService`, violating the Single Responsibility Principle and mixing concerns.\n * - This violates the principle of Separation of Concerns and makes the code harder to maintain, test, and understand.\n */\nstruct CombinedController {\n    auth_service: AuthenticationService,\n    data_service: DataService,\n}\n\nimpl CombinedController {\n    fn new(auth_service: AuthenticationService, data_service: DataService) -> Self {\n        CombinedController {\n            auth_service,\n            data_service,\n        }\n    }\n\n    fn login_user(&self, username: &str, password: &str) -> bool {\n        // Authentication logic here\n        let is_authenticated = self.auth_service.login(username, password);\n        if is_authenticated {\n            // Retrieve user data (mixing concerns)\n            let user_data = self.data_service.fetch_data();\n            println!(\"{:?}\", user_data);\n        }\n        is_authenticated\n    }\n\n    fn logout_user(&self) {\n        // Logout logic here\n        self.auth_service.logout();\n    }\n}\n\nfn main() {\n    let auth_service = AuthenticationService::new();\n    let data_service = DataService::new();\n\n    let combined_controller = CombinedController::new(auth_service, data_service);\n\n    // Simulate user login/logout\n    combined_controller.login_user(\"username\", \"password\");\n    combined_controller.logout_user();\n}"}]}]}}