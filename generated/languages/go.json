{"name":"Go (Golang)","code":"go","ext":"go","birth":2009,"death":"N/A","inspiredBy":["c","oberon","pascal","limbo","python","alef"],"inspiring":["rust","nim","crystal"],"description":"Go, often referred to as Golang, is an open-source programming language developed at Google.\nIt is known for its simplicity, efficiency, and reliable concurrency handling. Go is statically\ntyped, compiled, and syntactically similar to C, but with memory safety, garbage collection,\nstructural typing, and CSP-style concurrency features. It's widely used in cloud and network\nservices, command-line tools, and web applications. A notable feature of Go is its efficient\nhandling of concurrent operations, making it a popular choice for building high-performance\napplications. Go's design is focused on simplicity and readability, which has led to its wide\nadoption in software engineering for scalable server-side applications. The language has a\nstrong standard library, robust tooling, and a rapidly growing ecosystem.\n","patterns":{"patterns_behavioural":[{"title":"Chain Of Responsibility","examples":[{"codeFile":"patterns/behavioural/chain-of-responsibility/example","code":"package main\n\nimport (\n\t\"fmt\"\n)\n\n// SupportHandler defines the interface for a support handler\ntype SupportHandler interface {\n\tSetNextHandler(handler SupportHandler)\n\tHandleRequest(request string) string\n}\n\n// Level1Support concrete implementation for Level 1 support\ntype Level1Support struct {\n\tnextHandler SupportHandler\n}\n\nfunc (l *Level1Support) SetNextHandler(handler SupportHandler) {\n\tl.nextHandler = handler\n}\n\nfunc (l *Level1Support) HandleRequest(request string) string {\n\tif request == \"basic\" {\n\t\treturn \"Level 1 Support: Issue resolved at basic level.\"\n\t} else if l.nextHandler != nil {\n\t\treturn l.nextHandler.HandleRequest(request)\n\t}\n\treturn \"\"\n}\n\n// Level2Support concrete implementation for Level 2 support\ntype Level2Support struct {\n\tnextHandler SupportHandler\n}\n\nfunc (l *Level2Support) SetNextHandler(handler SupportHandler) {\n\tl.nextHandler = handler\n}\n\nfunc (l *Level2Support) HandleRequest(request string) string {\n\tif request == \"advanced\" {\n\t\treturn \"Level 2 Support: Issue resolved at advanced level.\"\n\t} else if l.nextHandler != nil {\n\t\treturn l.nextHandler.HandleRequest(request)\n\t}\n\treturn \"\"\n}\n\n// Level3Support concrete implementation for Level 3 support\ntype Level3Support struct{}\n\nfunc (l *Level3Support) SetNextHandler(handler SupportHandler) {\n\t// Level 3 support does not have a next handler\n}\n\nfunc (l *Level3Support) HandleRequest(request string) string {\n\tif request == \"bug\" {\n\t\treturn \"Level 3 Support: Issue resolved at development level.\"\n\t}\n\treturn \"Level 3 Support: Unable to resolve the issue.\"\n}\n\n// main function to simulate client code\nfunc main() {\n\tlevel1 := &Level1Support{}\n\tlevel2 := &Level2Support{}\n\tlevel3 := &Level3Support{}\n\n\t// Chain the handlers\n\tlevel1.SetNextHandler(level2)\n\tlevel2.SetNextHandler(level3)\n\n\t// Simulate support requests\n\trequest1 := \"basic\"\n\trequest2 := \"advanced\"\n\trequest3 := \"bug\"\n\n\tfmt.Println(level1.HandleRequest(request1)) // Output: Level 1 Support: Issue resolved at basic level.\n\tfmt.Println(level1.HandleRequest(request2)) // Output: Level 2 Support: Issue resolved at advanced level.\n\tfmt.Println(level1.HandleRequest(request3)) // Output: Level 3 Support: Issue resolved at development level.\n}\n\n/**\n * This code demonstrates how the Chain of Responsibility pattern can be used in a support\n * ticket system. The SupportHandler interface defines the contract for handling support\n * requests, and concrete implementations (Level1Support, Level2Support, and Level3Support)\n * represent different levels of support. Each handler decides whether it can handle a\n * request or should pass it to the next handler in the chain.\n */"}]},{"title":"Command","examples":[{"codeFile":"patterns/behavioural/command/example","code":"package main\n\nimport \"fmt\"\n\n// Command defines the interface for executing commands\ntype Command interface {\n\tExecute()\n}\n\n// Light represents the receiver class that performs the actual actions\ntype Light struct{}\n\nfunc (l *Light) TurnOn() {\n\tfmt.Println(\"Light is on\")\n}\n\nfunc (l *Light) TurnOff() {\n\tfmt.Println(\"Light is off\")\n}\n\n// TurnOnCommand is a concrete command to turn on the light\ntype TurnOnCommand struct {\n\tlight *Light\n}\n\nfunc NewTurnOnCommand(light *Light) *TurnOnCommand {\n\treturn &TurnOnCommand{light: light}\n}\n\nfunc (c *TurnOnCommand) Execute() {\n\tc.light.TurnOn()\n}\n\n// TurnOffCommand is a concrete command to turn off the light\ntype TurnOffCommand struct {\n\tlight *Light\n}\n\nfunc NewTurnOffCommand(light *Light) *TurnOffCommand {\n\treturn &TurnOffCommand{light: light}\n}\n\nfunc (c *TurnOffCommand) Execute() {\n\tc.light.TurnOff()\n}\n\n// RemoteControl acts as the invoker class that triggers the commands\ntype RemoteControl struct {\n\tcommands []Command\n}\n\nfunc (r *RemoteControl) AddCommand(command Command) {\n\tr.commands = append(r.commands, command)\n}\n\nfunc (r *RemoteControl) ExecuteCommands() {\n\tfor _, command := range r.commands {\n\t\tcommand.Execute()\n\t}\n}\n\n// Main function demonstrating the command design pattern\nfunc main() {\n\tlight := &Light{}\n\n\tturnOnCommand := NewTurnOnCommand(light)\n\tturnOffCommand := NewTurnOffCommand(light)\n\n\tremoteControl := &RemoteControl{}\n\tremoteControl.AddCommand(turnOnCommand)\n\tremoteControl.AddCommand(turnOffCommand)\n\n\tremoteControl.ExecuteCommands()\n}\n\n/*\nThis code demonstrates how the Command pattern can be used in a remote control\nsystem to control a light. The Command interface defines the contract for executing\ncommands, and concrete command classes (TurnOnCommand and TurnOffCommand) encapsulate\nthe actions to be performed on the Light receiver object. The RemoteControl acts as\nthe invoker, which holds and triggers the commands. Pressing buttons on the remote\ncontrol executes the corresponding commands, resulting in the light being turned on\nand off.\n*/"}]},{"title":"Iterator","examples":[{"codeFile":"patterns/behavioural/iterator/example","code":"package main\n\nimport \"fmt\"\n\ntype Iterator[T any] struct {\n\tcollection []T\n\tindex      int\n}\n\nfunc NewIterator[T any](collection []T) *Iterator[T] {\n\treturn &Iterator[T]{collection: collection, index: 0}\n}\n\n// Next returns the next element in the collection and advances the index\nfunc (it *Iterator[T]) Next() (T, bool) {\n\tif it.index < len(it.collection) {\n\t\tvalue := it.collection[it.index]\n\t\tit.index++\n\t\treturn value, true\n\t}\n\tvar zeroValue T // Represents the zero value of T\n\treturn zeroValue, false\n}\n\n// HasNext checks if the collection has more elements\nfunc (it *Iterator[T]) HasNext() bool {\n\treturn it.index < len(it.collection)\n}\n\n// Client code\nfunc main() {\n\titems := []interface{}{1, \"two\", 3, \"four\", 5}\n\titerator := NewIterator(items)\n\n\tfor iterator.HasNext() {\n\t\titem, _ := iterator.Next()\n\t\tfmt.Println(item)\n\t}\n\n\t/**\n\t * In this example, the Iterator pattern is used to iterate over a collection of books\n\t * stored in a BookCollection. The Iterator interface defines methods for checking if\n\t * there are more elements (hasNext) and retrieving the next element (next). The\n\t * ArrayIterator class provides a concrete implementation of the iterator for an array\n\t * of books. The BookCollection class implements the Iterable interface, which allows\n\t * it to create iterators for iterating over its collection of books. Finally, in the\n\t * client code, we create a BookCollection, add books to it, and iterate over the\n\t * collection using the iterator, printing each book's name.\n\t */\n}"}]},{"title":"Mediator","examples":[{"codeFile":"patterns/behavioural/mediator/example","code":"package main\n\nimport \"fmt\"\n\n// ChatMediator defines the interface for sending messages\ntype ChatMediator interface {\n\tSendMessage(message string, user User)\n}\n\n// ChatRoom is a concrete mediator for managing chat messages\ntype ChatRoom struct{}\n\nfunc (c *ChatRoom) SendMessage(message string, user User) {\n\tfmt.Printf(\"[%s] sends message: %s\\n\", user.GetName(), message)\n}\n\n// User defines the interface for participants in the chat\ntype User interface {\n\tSend(message string)\n\tReceive(message string)\n\tGetName() string\n}\n\n// ChatUser is a concrete colleague for a chat participant\ntype ChatUser struct {\n\tname     string\n\tmediator ChatMediator\n}\n\nfunc NewChatUser(name string, mediator ChatMediator) *ChatUser {\n\treturn &ChatUser{\n\t\tname:     name,\n\t\tmediator: mediator,\n\t}\n}\n\nfunc (u *ChatUser) Send(message string) {\n\tfmt.Printf(\"[%s] sends message: %s\\n\", u.name, message)\n\tu.mediator.SendMessage(message, u)\n}\n\nfunc (u *ChatUser) Receive(message string) {\n\tfmt.Printf(\"[%s] received message: %s\\n\", u.name, message)\n}\n\nfunc (u *ChatUser) GetName() string {\n\treturn u.name\n}\n\nfunc main() {\n\t// Create a chat room mediator\n\tchatMediator := &ChatRoom{}\n\n\t// Create chat users\n\tuser1 := NewChatUser(\"User1\", chatMediator)\n\tuser2 := NewChatUser(\"User2\", chatMediator)\n\n\t// Send messages between users\n\tuser1.Send(\"Hello, User2!\")\n\tuser2.Send(\"Hi, User1!\")\n}\n\n/*\nIn this Go example, the Mediator pattern is used to facilitate communication between\nusers in a chat room. The ChatMediator interface defines a method SendMessage for\nsending messages to users. The ChatRoom struct provides a concrete implementation\nof the mediator for managing communication between users in the chat room.\n\nThe User interface defines methods Send and Receive for sending and receiving messages,\nrespectively, as well as a method GetName for obtaining the user's name. The ChatUser\nstruct implements the User interface and interacts with the mediator to send and\nreceive messages.\n\nIn the client code, we create a chat room mediator and two chat users. Users can send\nmessages to each other by calling the Send method, which delegates the message sending\nto the mediator. When a message is received, the mediator distributes it to the\nappropriate user's Receive method.\n*/"}]},{"title":"Memento","examples":[{"codeFile":"patterns/behavioural/memento/example","code":"package main\n\nimport \"fmt\"\n\n// Editor represents the object whose state needs to be saved and restored\ntype Editor struct {\n\ttext string\n}\n\n// setText updates the Editor's text\nfunc (e *Editor) setText(text string) {\n\te.text = text\n}\n\n// getText returns the Editor's text\nfunc (e *Editor) getText() string {\n\treturn e.text\n}\n\n// save creates a memento containing the current state of the Editor\nfunc (e *Editor) save() *Memento {\n\treturn &Memento{state: e.text}\n}\n\n// restore sets the Editor's state from a memento\nfunc (e *Editor) restore(m *Memento) {\n\te.text = m.getState()\n}\n\n// Memento represents the stored state of the Editor\ntype Memento struct {\n\tstate string\n}\n\n// getState returns the state of the Memento\nfunc (m *Memento) getState() string {\n\treturn m.state\n}\n\n// History is responsible for keeping track of multiple mementos\ntype History struct {\n\tmementos []*Memento\n}\n\n// addMemento adds a memento to the history\nfunc (h *History) addMemento(m *Memento) {\n\th.mementos = append(h.mementos, m)\n}\n\n// getLatestMemento retrieves the most recent memento from the history\nfunc (h *History) getLatestMemento() *Memento {\n\tif len(h.mementos) == 0 {\n\t\tpanic(\"No mementos available\")\n\t}\n\treturn h.mementos[len(h.mementos)-1]\n}\n\nfunc main() {\n\teditor := &Editor{text: \"Initial text\"}\n\thistory := &History{}\n\n\t// Create a history to store mementos\n\thistory.addMemento(editor.save())\n\n\t// Modify the text\n\teditor.setText(\"Modified text\")\n\n\t// Add another memento to the history\n\thistory.addMemento(editor.save())\n\n\t// Restore the editor's state to a previous memento\n\teditor.restore(history.getLatestMemento())\n\n\tfmt.Println(editor.getText()) // Output: Modified text (restored from the previous state)\n}\n\n// This Go code is a translation and adaptation of the Memento design pattern example. \n// The Editor class, which manages an object's state that needs to be saved and restored, is represented by the Editor struct.\n// The Memento struct represents the saved state of the Editor at a particular point in time.\n// The History struct is responsible for managing a list of mementos, offering methods to add a memento to the history and retrieve the most recent one.\n// The client code demonstrates creating an editor and history object, modifying the editor's state, saving states to mementos, and restoring the editor's state from a memento."}]},{"title":"Observer","examples":[{"codeFile":"patterns/behavioural/observer/example","code":"package main\n\nimport \"fmt\"\n\n// Subject interface\ntype Subject interface {\n    Subscribe(observer Observer)\n    Unsubscribe(observer Observer)\n    Notify(data interface{})\n}\n\n// ConcreteSubject struct implements Subject interface\ntype ConcreteSubject struct {\n    observers []Observer\n}\n\nfunc (cs *ConcreteSubject) Subscribe(observer Observer) {\n    cs.observers = append(cs.observers, observer)\n}\n\nfunc (cs *ConcreteSubject) Unsubscribe(observer Observer) {\n    for i, obs := range cs.observers {\n        if obs == observer {\n            cs.observers = append(cs.observers[:i], cs.observers[i+1:]...)\n            break\n        }\n    }\n}\n\nfunc (cs *ConcreteSubject) Notify(data interface{}) {\n    for _, observer := range cs.observers {\n        observer.Update(data)\n    }\n}\n\n// Observer interface\ntype Observer interface {\n    Update(data interface{})\n}\n\n// ConcreteObserver struct implements Observer interface\ntype ConcreteObserver struct{}\n\nfunc (co *ConcreteObserver) Update(data interface{}) {\n    fmt.Printf(\"Observer received data: %v\\n\", data)\n}\n\n// Client code\nfunc main() {\n    subject := &ConcreteSubject{}\n\n    observer1 := &ConcreteObserver{}\n    observer2 := &ConcreteObserver{}\n\n    subject.Subscribe(observer1)\n    subject.Subscribe(observer2)\n\n    subject.Notify(\"Hello Observers!\")\n\n    subject.Unsubscribe(observer2)\n    subject.Notify(\"Goodbye Observers!\")\n}\n\n/**\n * In the modified example for Golang, the ConcreteSubject type implements the Subject interface,\n * managing a slice of Observer instances. It provides Subscribe and Unsubscribe methods to manage\n * its observers and a Notify method to update them. The ConcreteObserver type implements the Observer\n * interface with an Update method that prints data it received.\n *\n * The main function demonstrates creating a ConcreteSubject and two ConcreteObserver instances, simulating \n * a subscriber mechanism. It showcases subscribing observers to the subject, notifying them with data, \n * unsubscribing one, and notifying the remaining observer.\n *\n * Notably, idiomatic Go does not use exceptions or the same level of encapsulation as might be typical in \n * object-oriented patterns found in languages like Java or TypeScript. Therefore, the Go version uses slices \n * for management of observers and simple interface method calls for notification and observer update mechanism. \n */"}]},{"title":"State","examples":[{"codeFile":"patterns/behavioural/state/example","code":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\ntype TrafficLightState interface {\n\tChangeState(trafficLight *TrafficLight)\n}\n\ntype RedState struct{}\n\nfunc (s *RedState) ChangeState(trafficLight *TrafficLight) {\n\tfmt.Println(\"Traffic light is now RED. Stop!\")\n\ttime.AfterFunc(3*time.Second, func() { \n\t\ttrafficLight.SetState(&YellowState{}) \n\t})\n}\n\ntype YellowState struct{}\n\nfunc (s *YellowState) ChangeState(trafficLight *TrafficLight) {\n\tfmt.Println(\"Traffic light is now YELLOW. Prepare to stop or proceed with caution.\")\n\ttime.AfterFunc(2*time.Second, func() { \n\t\ttrafficLight.SetState(&GreenState{})\n\t})\n}\n\ntype GreenState struct{}\n\nfunc (s *GreenState) ChangeState(trafficLight *TrafficLight) {\n\tfmt.Println(\"Traffic light is now GREEN. Go!\")\n\ttime.AfterFunc(4*time.Second, func() { \n\t\ttrafficLight.SetState(&RedState{})\n\t})\n}\n\ntype TrafficLight struct {\n\tstate TrafficLightState\n}\n\nfunc (t *TrafficLight) SetState(state TrafficLightState) {\n\tt.state = state\n\tstate.ChangeState(t)\n}\n\nfunc NewTrafficLight() *TrafficLight {\n\treturn &TrafficLight{\n\t\tstate: &RedState{}, // Initial state is Red\n\t}\n}\n\n// Main function simulating traffic light behavior\nfunc main() {\n\ttrafficLight := NewTrafficLight()\n\n\t// Change to green state to see the transition\n\ttrafficLight.SetState(&GreenState{})\n\n\t// Keep the program running to observe state transitions\n\tselect {}\n}"}]},{"title":"Strategy","examples":[{"codeFile":"patterns/behavioural/strategy/example","code":"package main\n\nimport \"fmt\"\n\n// PaymentStrategy defines the common behavior for all payment strategies\ntype PaymentStrategy interface {\n  Pay(amount float64)\n}\n\n// CreditCardPaymentStrategy is a concrete strategy for processing payments via credit card\ntype CreditCardPaymentStrategy struct {\n  CardNumber string\n  ExpiryDate string\n  CVV        string\n}\n\nfunc (c *CreditCardPaymentStrategy) Pay(amount float64) {\n  fmt.Printf(\"Processing credit card payment of $%.2f with card number %s\\n\", amount, c.CardNumber)\n  // Logic to process payment via credit card\n}\n\n// PayPalPaymentStrategy is a concrete strategy for processing payments via PayPal\ntype PayPalPaymentStrategy struct {\n  Email    string\n  Password string\n}\n\nfunc (p *PayPalPaymentStrategy) Pay(amount float64) {\n  fmt.Printf(\"Processing PayPal payment of $%.2f with email %s\\n\", amount, p.Email)\n  // Logic to process payment via PayPal\n}\n\n// PaymentProcessor represents the payment processor (Context)\ntype PaymentProcessor struct {\n  PaymentStrategy PaymentStrategy\n}\n\n// SetPaymentStrategy sets the payment strategy dynamically\nfunc (p *PaymentProcessor) SetPaymentStrategy(strategy PaymentStrategy) {\n  p.PaymentStrategy = strategy\n}\n\n// ProcessPayment processes payment using the selected strategy\nfunc (p *PaymentProcessor) ProcessPayment(amount float64) {\n  if p.PaymentStrategy != nil {\n    p.PaymentStrategy.Pay(amount)\n  } else {\n    fmt.Println(\"Payment strategy not set. Please select a payment method.\")\n  }\n}\n\nfunc main() {\n  paymentProcessor := PaymentProcessor{}\n\n  // Select a payment method (strategy) dynamically\n  creditCardStrategy := &CreditCardPaymentStrategy{\"1234 5678 9012 3456\", \"12/25\", \"123\"}\n  paymentProcessor.SetPaymentStrategy(creditCardStrategy)\n  paymentProcessor.ProcessPayment(100)\n\n  // Change payment method (strategy)\n  payPalStrategy := &PayPalPaymentStrategy{\"example@example.com\", \"password\"}\n  paymentProcessor.SetPaymentStrategy(payPalStrategy)\n  paymentProcessor.ProcessPayment(50)\n}"}]},{"title":"Template Method","examples":[{"codeFile":"patterns/behavioural/template-method/example","code":"package main\n\nimport \"fmt\"\n\n// Breakfast interface defines the template method and the steps required.\ntype Breakfast interface {\n\tPrepare()\n\taddIngredients()\n\tcook()\n\tboilWater()\n\tserve()\n}\n\n// BaseBreakfast provides default implementations of some steps.\ntype BaseBreakfast struct{}\n\nfunc (b *BaseBreakfast) boilWater() {\n\tfmt.Println(\"Boiling water...\")\n}\n\nfunc (b *BaseBreakfast) serve() {\n\tfmt.Println(\"Breakfast is served!\")\n}\n\n// OmeletteBreakfast represents a breakfast of type omelette.\ntype OmeletteBreakfast struct {\n\tBaseBreakfast\n}\n\nfunc (o *OmeletteBreakfast) addIngredients() {\n\tfmt.Println(\"Adding eggs, cheese, and vegetables to the pan.\")\n}\n\nfunc (o *OmeletteBreakfast) cook() {\n\tfmt.Println(\"Cooking the omelette until golden brown.\")\n}\n\nfunc (o *OmeletteBreakfast) Prepare() {\n\to.boilWater()\n\to.addIngredients()\n\to.cook()\n\to.serve()\n}\n\n// PancakeBreakfast represents a breakfast of type pancake.\ntype PancakeBreakfast struct {\n\tBaseBreakfast\n}\n\nfunc (p *PancakeBreakfast) addIngredients() {\n\tfmt.Println(\"Mixing flour, eggs, milk, and sugar to make the batter.\")\n}\n\nfunc (p *PancakeBreakfast) cook() {\n\tfmt.Println(\"Pouring the batter onto the griddle and flipping until cooked.\")\n}\n\nfunc (p *PancakeBreakfast) Prepare() {\n\tp.boilWater()\n\tp.addIngredients()\n\tp.cook()\n\tp.serve()\n}\n\n// Client code to demonstrate the Template Method pattern in Go.\nfunc main() {\n\tfmt.Println(\"Preparing Omelette Breakfast:\")\n\tomelette := OmeletteBreakfast{}\n\tomelette.Prepare()\n\n\tfmt.Println(\"\\nPreparing Pancake Breakfast:\")\n\tpancake := PancakeBreakfast{}\n\tpancake.Prepare()\n}\n\n/*\nIn this Go example, we've adopted the template method design pattern to define\na sequence of steps for preparing breakfast. The interface Breakfast and the struct BaseBreakfast\nabstract the common steps and provide default implementations respectively. Each specific breakfast,\nsuch as OmeletteBreakfast and PancakeBreakfast, embeds BaseBreakfast and implements the necessary steps.\n\nThis design encapsulates the algorithm for preparing breakfast, ensuring that the high-level\nsequence of steps is preserved while allowing subclasses to provide the specific details\nof certain steps.\n*/"}]},{"title":"Visitor","examples":[{"codeFile":"patterns/behavioural/visitor/example","code":"package main\n\nimport \"fmt\"\n\n// AnimalVisitor interface\ntype AnimalVisitor interface {\n\tVisitLion(lion *Lion)\n\tVisitElephant(elephant *Elephant)\n\tVisitGiraffe(giraffe *Giraffe)\n}\n\n// AnimalFeeder is a concrete visitor implementing the operations on animals\ntype AnimalFeeder struct{}\n\nfunc (af *AnimalFeeder) VisitLion(lion *Lion) {\n\tfmt.Printf(\"Feeding meat to %s.\\n\", lion.GetName())\n}\n\nfunc (af *AnimalFeeder) VisitElephant(elephant *Elephant) {\n\tfmt.Printf(\"Feeding hay to %s.\\n\", elephant.GetName())\n}\n\nfunc (af *AnimalFeeder) VisitGiraffe(giraffe *Giraffe) {\n\tfmt.Printf(\"Feeding leaves to %s.\\n\", giraffe.GetName())\n}\n\n// Animal interface representing animals\ntype Animal interface {\n\tAccept(visitor AnimalVisitor)\n}\n\n// Lion is a concrete element representing a lion\ntype Lion struct {\n\tname string\n}\n\nfunc NewLion(name string) *Lion {\n\treturn &Lion{name: name}\n}\n\nfunc (l *Lion) GetName() string {\n\treturn l.name\n}\n\nfunc (l *Lion) Accept(visitor AnimalVisitor) {\n\tvisitor.VisitLion(l)\n}\n\n// Elephant is a concrete element representing an elephant\ntype Elephant struct {\n\tname string\n}\n\nfunc NewElephant(name string) *Elephant {\n\treturn &Elephant{name: name}\n}\n\nfunc (e *Elephant) GetName() string {\n\treturn e.name\n}\n\nfunc (e *Elephant) Accept(visitor AnimalVisitor) {\n\tvisitor.VisitElephant(e)\n}\n\n// Giraffe is a concrete element representing a giraffe\ntype Giraffe struct {\n\tname string\n}\n\nfunc NewGiraffe(name string) *Giraffe {\n\treturn &Giraffe{name: name}\n}\n\nfunc (g *Giraffe) GetName() string {\n\treturn g.name\n}\n\nfunc (g *Giraffe) Accept(visitor AnimalVisitor) {\n\tvisitor.VisitGiraffe(g)\n}\n\n// Zoo represents the object structure containing a collection of animals\ntype Zoo struct {\n\tanimals []Animal\n}\n\nfunc (z *Zoo) AddAnimal(animal Animal) {\n\tz.animals = append(z.animals, animal)\n}\n\n// PerformOperation performs the operation defined by the visitor on each animal\nfunc (z *Zoo) PerformOperation(visitor AnimalVisitor) {\n\tfor _, animal := range z.animals {\n\t\tanimal.Accept(visitor)\n\t}\n}\n\n// Client code\nfunc main() {\n\tzoo := &Zoo{}\n\tzoo.AddAnimal(NewLion(\"Simba\"))\n\tzoo.AddAnimal(NewElephant(\"Dumbo\"))\n\tzoo.AddAnimal(NewGiraffe(\"Melman\"))\n\n\tfeeder := &AnimalFeeder{}\n\tzoo.PerformOperation(feeder)\n}"}]}],"patterns_creational":[{"title":"Factory Method","examples":[{"codeFile":"patterns/creational/factory-method/example","code":"package main\n\nimport \"fmt\"\n\n// Vehicle interface that all vehicles will implement\ntype Vehicle interface {\n\tDrive()\n}\n\n// Car type that implements the Vehicle interface\ntype Car struct{}\n\nfunc (c *Car) Drive() {\n\tfmt.Println(\"Driving a car...\")\n}\n\n// Truck type that implements the Vehicle interface\ntype Truck struct{}\n\nfunc (truck *Truck) Drive() {\n\tfmt.Println(\"Driving a truck...\")\n}\n\n// VehicleFactory interface defines the method that all concrete factories must implement\ntype VehicleFactory interface {\n\tCreateVehicle() Vehicle\n}\n\n// CarFactory type that implements the VehicleFactory interface\ntype CarFactory struct{}\n\nfunc (cf *CarFactory) CreateVehicle() Vehicle {\n\tfmt.Println(\"Creating a car...\")\n\treturn new(Car)\n}\n\n// TruckFactory type that implements the VehicleFactory interface\ntype TruckFactory struct{}\n\nfunc (tf *TruckFactory) CreateVehicle() Vehicle {\n\tfmt.Println(\"Creating a truck...\")\n\treturn new(Truck)\n}\n\n// DeliverVehicle takes a VehicleFactory, creates a Vehicle, and delivers it\nfunc DeliverVehicle(factory VehicleFactory) {\n\tfmt.Println(\"Delivering the vehicle...\")\n\tvehicle := factory.CreateVehicle()\n\tvehicle.Drive()\n}\n\n// Main function demonstrating the Factory Method pattern\nfunc main() {\n\tcarFactory := &CarFactory{}\n\tDeliverVehicle(carFactory)\n\n\ttruckFactory := &TruckFactory{}\n\tDeliverVehicle(truckFactory)\n}\n\n/*\nThe Vehicle interface defines a common interface for all vehicles, which includes a Drive() method.\n\nThe Car and Truck structs are concrete implementations of the Vehicle interface.\n\nThe VehicleFactory interface represents a creator, declaring the CreateVehicle() method, which serves as the Factory Method for creating vehicles.\n\nThe CarFactory and TruckFactory structs are concrete implementations of the VehicleFactory interface. They implement the CreateVehicle() method to create specific types of vehicles (i.e., cars and trucks).\n\nThe DeliverVehicle function represents an operation that uses the Factory Method to create and deliver a vehicle. It demonstrates the use of the Factory Method pattern in a Go idiomatic way.\n*/"}]},{"title":"Abstract Factory","examples":[{"codeFile":"patterns/creational/abstract-factory/example","code":"package main\n\nimport \"fmt\"\n\n// FurnitureFactory interface\ntype FurnitureFactory interface {\n    CreateChair() Chair\n    CreateTable() Table\n}\n\n// ModernFurnitureFactory concrete factory\ntype ModernFurnitureFactory struct{}\n\nfunc (m *ModernFurnitureFactory) CreateChair() Chair {\n    return &ModernChair{}\n}\n\nfunc (m *ModernFurnitureFactory) CreateTable() Table {\n    return &ModernTable{}\n}\n\n// VintageFurnitureFactory concrete factory\ntype VintageFurnitureFactory struct{}\n\nfunc (v *VintageFurnitureFactory) CreateChair() Chair {\n    return &VintageChair{}\n}\n\nfunc (v *VintageFurnitureFactory) CreateTable() Table {\n    return &VintageTable{}\n}\n\n// Chair interface\ntype Chair interface {\n    SitOn()\n}\n\n// ModernChair concrete product\ntype ModernChair struct{}\n\nfunc (mc *ModernChair) SitOn() {\n    fmt.Println(\"Sitting on a modern chair.\")\n}\n\n// VintageChair concrete product\ntype VintageChair struct{}\n\nfunc (vc *VintageChair) SitOn() {\n    fmt.Println(\"Sitting on a vintage chair.\")\n}\n\n// Table interface\ntype Table interface {\n    PutOn()\n}\n\n// ModernTable concrete product\ntype ModernTable struct{}\n\nfunc (mt *ModernTable) PutOn() {\n    fmt.Println(\"Putting something on a modern table.\")\n}\n\n// VintageTable concrete product\ntype VintageTable struct{}\n\nfunc (vt *VintageTable) PutOn() {\n    fmt.Println(\"Putting something on a vintage table.\")\n}\n\n// createFurniture client function\nfunc createFurniture(factory FurnitureFactory) {\n    chair := factory.CreateChair()\n    table := factory.CreateTable()\n\n    fmt.Println(\"Created furniture:\")\n    chair.SitOn()\n    table.PutOn()\n}\n\nfunc main() {\n    fmt.Println(\"Creating modern furniture:\")\n    createFurniture(&ModernFurnitureFactory{})\n\n    fmt.Println(\"\\nCreating vintage furniture:\")\n    createFurniture(&VintageFurnitureFactory{})\n}"}]},{"title":"Builder","examples":[{"codeFile":"patterns/creational/builder/example","code":"package main\n\nimport \"fmt\"\n\n// Computer represents the product we want to build.\ntype Computer struct {\n\tcpu        string\n\tram        int\n\tstorage    int\n\tgpu        string\n\tscreenSize int\n}\n\n// NewComputer is a constructor for Computer.\nfunc NewComputer(cpu string, ram int, storage int, gpu string, screenSize int) *Computer {\n\treturn &Computer{cpu: cpu, ram: ram, storage: storage, gpu: gpu, screenSize: screenSize}\n}\n\n// DisplaySpecs prints the specifications of the computer.\nfunc (c *Computer) DisplaySpecs() {\n\tfmt.Printf(\"CPU: %s\\n\", c.cpu)\n\tfmt.Printf(\"RAM: %d GB\\n\", c.ram)\n\tfmt.Printf(\"Storage: %d GB\\n\", c.storage)\n\tfmt.Printf(\"GPU: %s\\n\", c.gpu)\n\tfmt.Printf(\"Screen Size: %d inches\\n\", c.screenSize)\n}\n\n// ComputerBuilder defines methods for setting each component of the computer.\ntype ComputerBuilder interface {\n\tSetCPU(cpu string)\n\tSetRAM(ram int)\n\tSetStorage(storage int)\n\tSetGPU(gpu string)\n\tSetScreenSize(screenSize int)\n\tGetResult() *Computer\n}\n\n// GamingComputerBuilder is a concrete builder for a gaming computer.\ntype GamingComputerBuilder struct {\n\tcomputer *Computer\n}\n\n// NewGamingComputerBuilder is the constructor for GamingComputerBuilder, initializing with default values.\nfunc NewGamingComputerBuilder() *GamingComputerBuilder {\n\treturn &GamingComputerBuilder{computer: NewComputer(\"\", 0, 0, \"\", 0)}\n}\n\nfunc (b *GamingComputerBuilder) SetCPU(cpu string) {\n\tb.computer.cpu = cpu\n}\n\nfunc (b *GamingComputerBuilder) SetRAM(ram int) {\n\tb.computer.ram = ram\n}\n\nfunc (b *GamingComputerBuilder) SetStorage(storage int) {\n\tb.computer.storage = storage\n}\n\nfunc (b *GamingComputerBuilder) SetGPU(gpu string) {\n\tb.computer.gpu = gpu\n}\n\nfunc (b *GamingComputerBuilder) SetScreenSize(screenSize int) {\n\tb.computer.screenSize = screenSize\n}\n\nfunc (b *GamingComputerBuilder) GetResult() *Computer {\n\treturn b.computer\n}\n\n// ComputerBuilderDirector is responsible for the construction process.\ntype ComputerBuilderDirector struct {\n\tbuilder ComputerBuilder\n}\n\nfunc NewComputerBuilderDirector(builder ComputerBuilder) *ComputerBuilderDirector {\n\treturn &ComputerBuilderDirector{builder: builder}\n}\n\nfunc (d *ComputerBuilderDirector) ConstructGamingComputer() {\n\td.builder.SetCPU(\"Intel Core i9\")\n\td.builder.SetRAM(32)\n\td.builder.SetStorage(1000)\n\td.builder.SetGPU(\"NVIDIA GeForce RTX 3080\")\n\td.builder.SetScreenSize(27)\n}\n\n// main function to use the builder\nfunc main() {\n\tgamingComputerBuilder := NewGamingComputerBuilder()\n\tdirector := NewComputerBuilderDirector(gamingComputerBuilder)\n\tdirector.ConstructGamingComputer()\n\tgamingComputer := gamingComputerBuilder.GetResult()\n\tfmt.Println(\"Gaming Computer Specifications:\")\n\tgamingComputer.DisplaySpecs()\n}"}]},{"title":"Prototype","examples":[{"codeFile":"patterns/creational/prototype/example","code":"package main\n\nimport (\n\t\"fmt\"\n)\n\n// UserProfile provides methods for cloning a profile,\n// customizing profile settings, and displaying the profile.\ntype UserProfile interface {\n\tClone() UserProfile\n\tCustomizeProfile(settings UserProfileSettings)\n\tDisplayProfile()\n}\n\n// DefaultUserProfile represents the default user profile with properties like username,\n// bio, and profile picture. It is a concrete implementation of the UserProfile interface.\ntype DefaultUserProfile struct {\n\tusername      string\n\tbio           string\n\tprofilePicture string\n}\n\nfunc NewDefaultUserProfile(username, bio, profilePicture string) *DefaultUserProfile {\n\treturn &DefaultUserProfile{\n\t\tusername:       username,\n\t\tbio:            bio,\n\t\tprofilePicture: profilePicture,\n\t}\n}\n\nfunc (dup *DefaultUserProfile) Clone() UserProfile {\n\treturn NewDefaultUserProfile(dup.username, dup.bio, dup.profilePicture)\n}\n\nfunc (dup *DefaultUserProfile) CustomizeProfile(settings UserProfileSettings) {\n\tif settings.Username != \"\" {\n\t\tdup.username = settings.Username\n\t}\n\tif settings.Bio != \"\" {\n\t\tdup.bio = settings.Bio\n\t}\n\tif settings.ProfilePicture != \"\" {\n\t\tdup.profilePicture = settings.ProfilePicture\n\t}\n}\n\nfunc (dup *DefaultUserProfile) DisplayProfile() {\n\tfmt.Println(\"Username:\", dup.username)\n\tfmt.Println(\"Bio:\", dup.bio)\n\tfmt.Println(\"Profile Picture:\", dup.profilePicture)\n}\n\n// UserProfileSettings defines optional settings that can be customized in a user profile.\ntype UserProfileSettings struct {\n\tUsername       string\n\tBio            string\n\tProfilePicture string\n}\n\nfunc main() {\n\t// Create a default user profile\n\tdefaultProfile := NewDefaultUserProfile(\"user123\", \"Welcome to my profile!\", \"default.jpg\")\n\n\t// Clone the default profile to create a customized profile\n\tcustomizedProfile := defaultProfile.Clone()\n\tcustomizedProfile.CustomizeProfile(UserProfileSettings{Bio: \"I'm a software developer.\", ProfilePicture: \"avatar.jpg\"})\n\n\t// Display both profiles\n\tfmt.Println(\"Default Profile:\")\n\tdefaultProfile.DisplayProfile()\n\n\tfmt.Println(\"\\nCustomized Profile:\")\n\tcustomizedProfile.DisplayProfile()\n}\n\n/**\n * In this Go implementation, the Prototype pattern is used to create new objects by copying existing ones.\n * The UserProfile interface and DefaultUserProfile struct implement the clone, customize profile, and display profile\n * functionalities, adhering closely to the original example's structure and behavior. The UserProfileSettings struct\n * replaces the settings interface from the TypeScript example, providing a way to specify optional customizations\n * for a user profile. The main function demonstrates creating a default and customized profile, showcasing the\n * versatility of the Prototype pattern.\n */"}]},{"title":"Singleton","examples":[{"codeFile":"patterns/creational/singleton/example","code":"package main\n\nimport (\n\t\"fmt\"\n\t\"sync\"\n\t\"time\"\n)\n\n// Logger defines the structure for logging messages.\n// It has a private logHistory slice to store log messages.\ntype Logger struct {\n\tlogHistory []string\n}\n\nvar instance *Logger\nvar once sync.Once\n\n// GetInstance returns the singleton instance of the Logger.\n// Utilizes sync.Once to ensure that the Logger is instantiated only once.\nfunc GetInstance() *Logger {\n\tonce.Do(func() {\n\t\tinstance = &Logger{}\n\t})\n\treturn instance\n}\n\n// Log logs a message with a timestamp. It stores the message in logHistory and prints it.\nfunc (l *Logger) Log(message string) {\n\ttimestamp := time.Now().Format(time.RFC3339)\n\tlogEntry := fmt.Sprintf(\"[%s] %s\", timestamp, message)\n\tl.logHistory = append(l.logHistory, logEntry)\n\tfmt.Println(logEntry)\n}\n\n// GetLogHistory returns the log history.\nfunc (l *Logger) GetLogHistory() []string {\n\treturn l.logHistory\n}\n\nfunc main() {\n\tlogger1 := GetInstance()\n\tlogger2 := GetInstance()\n\n\tfmt.Println(logger1 == logger2) // Output: true, both references point to the same instance\n\n\tlogger1.Log(\"User logged in\")\n\tlogger2.Log(\"Data saved to database\")\n\n\tfmt.Println(logger1.GetLogHistory())\n\n\t// The Logger struct holds a singleton instance of the logger, ensured by the sync.Once in GetInstance().\n\t// The constructor equivalent (GetInstance method) checks if an instance already exists; if not, it creates one.\n\t// This ensures a single instance of Logger is created and used throughout the application.\n\t// The Log method allows adding messages with the current timestamp to the logHistory slice and prints them.\n\t// The GetLogHistory method returns the slice containing all the log entries.\n\t// In the main function, logger1 and logger2 demonstrate that both variables reference the same Logger instance.\n\t// Logging messages using either logger1 or logger2 and retrieving the log history show consistent and expected behavior.\n}"}]}],"patterns_structural":[{"title":"Adapter","examples":[{"codeFile":"patterns/structural/adapter/example","code":"package main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\n// Mp3Player represents the existing audio player that can play MP3 files.\ntype Mp3Player struct{}\n\nfunc (mp *Mp3Player) playMp3(fileName string) {\n\tfmt.Println(\"Playing MP3 file:\", fileName)\n}\n\n// AudioPlayer is the target interface that defines the unified interface expected by the\n// client application for playing audio files.\ntype AudioPlayer interface {\n\tplay(fileName string)\n}\n\n// OggToMp3Adapter is the adapter class that implements the AudioPlayer interface. It internally\n// uses the Mp3Player to play MP3 files but converts OGG files to MP3 format before delegating to\n// the Mp3Player.\ntype OggToMp3Adapter struct {\n\tmp3Player Mp3Player\n}\n\nfunc NewOggToMp3Adapter() *OggToMp3Adapter {\n\treturn &OggToMp3Adapter{\n\t\tmp3Player: Mp3Player{},\n\t}\n}\n\nfunc (adapter *OggToMp3Adapter) play(fileName string) {\n\t// Convert OGG to MP3 and play using the MP3 player\n\tfmt.Printf(\"Converting OGG file '%s' to MP3 format\\n\", fileName)\n\tmp3FileName := adapter.convertToMp3(fileName)\n\tadapter.mp3Player.playMp3(mp3FileName)\n}\n\nfunc (adapter *OggToMp3Adapter) convertToMp3(fileName string) string {\n\t// Simulate conversion process (replace extension)\n\treturn strings.Replace(fileName, \".ogg\", \".mp3\", -1)\n}\n\n// Client code demonstrates the usage of the adapter.\nfunc main() {\n\taudioPlayer := NewOggToMp3Adapter()\n\n\t// Play MP3 file\n\taudioPlayer.play(\"audio1.mp3\")\n\n\t// Play OGG file (automatically converted to MP3)\n\taudioPlayer.play(\"audio2.ogg\")\n}"}]},{"title":"Bridge","examples":[{"codeFile":"patterns/structural/bridge/example","code":"package main\n\nimport \"fmt\"\n\n// Workshop interface representing the Implementor.\ntype Workshop interface {\n\twork()\n}\n\n// PaintWorkshop is a Concrete Implementor.\ntype PaintWorkshop struct{}\n\nfunc (p *PaintWorkshop) work() {\n\tfmt.Println(\"Painting vehicle\")\n}\n\n// RepairWorkshop is another Concrete Implementor.\ntype RepairWorkshop struct{}\n\nfunc (r *RepairWorkshop) work() {\n\tfmt.Println(\"Repairing vehicle\")\n}\n\n// Vehicle acts as the Abstraction.\ntype Vehicle struct {\n\tworkshop Workshop // Composition over Workshop interface.\n}\n\nfunc (v *Vehicle) manufacture() {} // Defined to fulfill Vehicle's role as an interface.\n\n// Car is a Refined Abstraction of Vehicle.\ntype Car struct {\n\tVehicle\n}\n\nfunc NewCar(workshop Workshop) *Car {\n\treturn &Car{Vehicle{workshop: workshop}}\n}\n\nfunc (c *Car) manufacture() {\n\tfmt.Println(\"Manufacturing car.\")\n\tc.workshop.work()\n}\n\n// Truck is another Refined Abstraction of Vehicle.\ntype Truck struct {\n\tVehicle\n}\n\nfunc NewTruck(workshop Workshop) *Truck {\n\treturn &Truck{Vehicle{workshop: workshop}}\n}\n\nfunc (t *Truck) manufacture() {\n\tfmt.Println(\"Manufacturing truck.\")\n\tt.workshop.work()\n}\n\n// Main function demonstrating client code\nfunc main() {\n\tcar := NewCar(&PaintWorkshop{})\n\tcar.manufacture() // Output: Manufacturing car. Painting vehicle\n\n\ttruck := NewTruck(&RepairWorkshop{})\n\ttruck.manufacture() // Output: Manufacturing truck. Repairing vehicle\n\n\t/*\n\t  The Vehicle struct represents the abstraction, extended by Car and Truck through composition.\n\n\t  The Workshop interface acts as the implementor, which is concretely implemented by PaintWorkshop and RepairWorkshop.\n\n\t  Each vehicle type (Car, Truck) can be associated with a specific workshop (PaintWorkshop, RepairWorkshop) using composition, delegating the work to the workshop.\n\t*/\n}"}]},{"title":"Composite","examples":[{"codeFile":"patterns/structural/composite/example","code":"package main\n\nimport \"fmt\"\n\n// Department interface outlines methods for both simple and composite departments\ntype Department interface {\n\tGetName() string\n\tGetEmployees() []string\n}\n\n// IndividualDepartment represents a basic, single department with a name and employees.\ntype IndividualDepartment struct {\n\tname      string\n\temployees []string\n}\n\nfunc NewIndividualDepartment(name string, employees []string) *IndividualDepartment {\n\treturn &IndividualDepartment{name: name, employees: employees}\n}\n\nfunc (d *IndividualDepartment) GetName() string {\n\treturn d.name\n}\n\nfunc (d *IndividualDepartment) GetEmployees() []string {\n\treturn d.employees\n}\n\n// CompositeDepartment can hold both IndividualDepartments and other CompositeDepartments.\ntype CompositeDepartment struct {\n\tname         string\n\tdepartments  []Department\n}\n\nfunc NewCompositeDepartment(name string) *CompositeDepartment {\n\treturn &CompositeDepartment{name: name, departments: []Department{}}\n}\n\nfunc (cd *CompositeDepartment) GetName() string {\n\treturn cd.name\n}\n\nfunc (cd *CompositeDepartment) AddDepartment(department Department) {\n\tcd.departments = append(cd.departments, department)\n}\n\nfunc (cd *CompositeDepartment) RemoveDepartment(department Department) {\n\tfor i, d := range cd.departments {\n\t\tif d == department {\n\t\t\tcd.departments = append(cd.departments[:i], cd.departments[i+1:]...)\n\t\t\tbreak\n\t\t}\n\t}\n}\n\nfunc (cd *CompositeDepartment) GetEmployees() []string {\n\tvar employees []string\n\tfor _, department := range cd.departments {\n\t\temployees = append(employees, department.GetEmployees()...)\n\t}\n\treturn employees\n}\n\nfunc main() {\n\tsalesDepartment := NewIndividualDepartment(\"Sales Department\", []string{\"John\", \"Alice\", \"Bob\"})\n\tmarketingDepartment := NewIndividualDepartment(\"Marketing Department\", []string{\"Emily\", \"David\"})\n\tengineeringDepartment := NewIndividualDepartment(\"Engineering Department\", []string{\"Michael\", \"Sarah\", \"Chris\"})\n\n\theadDepartment := NewCompositeDepartment(\"Head Department\")\n\theadDepartment.AddDepartment(salesDepartment)\n\theadDepartment.AddDepartment(marketingDepartment)\n\n\tparentEngineeringDepartment := NewCompositeDepartment(\"Parent Engineering Department\")\n\tparentEngineeringDepartment.AddDepartment(engineeringDepartment)\n\n\trootDepartment := NewCompositeDepartment(\"Root Department\")\n\trootDepartment.AddDepartment(headDepartment)\n\trootDepartment.AddDepartment(parentEngineeringDepartment)\n\n\t// Display all employees in the root department\n\tfmt.Println(\"Employees in the root department:\")\n\tfmt.Println(rootDepartment.GetEmployees())\n}"}]},{"title":"Decorator","examples":[{"codeFile":"patterns/structural/decorator/example","code":"package main\n\nimport (\n\t\"fmt\"\n)\n\n// Notification interface defines the common method for sending notifications.\ntype Notification interface {\n\tSend() string\n}\n\n// BaseNotification represents the base notification without any additional features.\ntype BaseNotification struct{}\n\nfunc (bn *BaseNotification) Send() string {\n\treturn \"Base notification: You have a new message!\"\n}\n\n// NotificationDecorator serves as the base struct for concrete decorators.\n// It holds a reference to the wrapped notification.\ntype NotificationDecorator struct {\n\tnotification Notification\n}\n\nfunc (nd *NotificationDecorator) Send() string {\n\treturn nd.notification.Send()\n}\n\n// SoundNotificationDecorator adds sound notification functionality to the base notification.\ntype SoundNotificationDecorator struct {\n\tNotificationDecorator\n}\n\nfunc NewSoundNotificationDecorator(notification Notification) *SoundNotificationDecorator {\n\treturn &SoundNotificationDecorator{NotificationDecorator{notification: notification}}\n}\n\nfunc (snd *SoundNotificationDecorator) Send() string {\n\treturn fmt.Sprintf(\"%s (Sound notification: Ding!)\", snd.notification.Send())\n}\n\n// PriorityNotificationDecorator adds priority notification functionality to the base notification.\ntype PriorityNotificationDecorator struct {\n\tNotificationDecorator\n}\n\nfunc NewPriorityNotificationDecorator(notification Notification) *PriorityNotificationDecorator {\n\treturn &PriorityNotificationDecorator{NotificationDecorator{notification: notification}}\n}\n\nfunc (pnd *PriorityNotificationDecorator) Send() string {\n\treturn fmt.Sprintf(\"%s (Priority notification: High priority!)\", pnd.notification.Send())\n}\n\n// Client code demonstrating how we can dynamically add sound notification,\n// priority notification, or both to the base notification.\nfunc main() {\n\tbaseNotification := &BaseNotification{}\n\tfmt.Println(baseNotification.Send())\n\n\tsoundNotification := NewSoundNotificationDecorator(baseNotification)\n\tfmt.Println(soundNotification.Send())\n\n\tpriorityNotification := NewPriorityNotificationDecorator(baseNotification)\n\tfmt.Println(priorityNotification.Send())\n\n\tsoundAndPriorityNotification := NewPriorityNotificationDecorator(NewSoundNotificationDecorator(baseNotification))\n\tfmt.Println(soundAndPriorityNotification.Send())\n}"}]},{"title":"Facade","examples":[{"codeFile":"patterns/structural/facade/example","code":"package main\n\nimport (\n\t\"fmt\"\n\t\"time\"\n)\n\n// FlightBookingSystem represents the subsystem for flight booking.\ntype FlightBookingSystem struct{}\n\nfunc (fbs *FlightBookingSystem) BookFlight(origin string, destination string) string {\n\treturn fmt.Sprintf(\"Flight booked from %s to %s\", origin, destination)\n}\n\n// HotelBookingSystem represents the subsystem for hotel booking.\ntype HotelBookingSystem struct{}\n\nfunc (hbs *HotelBookingSystem) BookHotel(location string, checkInDate time.Time, checkOutDate time.Time) string {\n\treturn fmt.Sprintf(\"Hotel booked at %s from %s to %s\", location, checkInDate.Format(\"2006-01-02\"), checkOutDate.Format(\"2006-01-02\"))\n}\n\n// CarRentalSystem represents the subsystem for car rental.\ntype CarRentalSystem struct{}\n\nfunc (crs *CarRentalSystem) RentCar(location string, startDate time.Time, endDate time.Time) string {\n\treturn fmt.Sprintf(\"Car rented at %s from %s to %s\", location, startDate.Format(\"2006-01-02\"), endDate.Format(\"2006-01-02\"))\n}\n\n// TravelFacade provides a simplified interface for booking a complete travel package.\ntype TravelFacade struct {\n\tflightBookingSystem FlightBookingSystem\n\thotelBookingSystem  HotelBookingSystem\n\tcarRentalSystem     CarRentalSystem\n}\n\nfunc NewTravelFacade() *TravelFacade {\n\treturn &TravelFacade{\n\t\tflightBookingSystem: FlightBookingSystem{},\n\t\thotelBookingSystem:  HotelBookingSystem{},\n\t\tcarRentalSystem:     CarRentalSystem{},\n\t}\n}\n\nfunc (tf *TravelFacade) BookTravel(origin, destination, location string, checkInDate, checkOutDate, startDate, endDate time.Time) string {\n\tflightDetails := tf.flightBookingSystem.BookFlight(origin, destination)\n\thotelDetails := tf.hotelBookingSystem.BookHotel(location, checkInDate, checkOutDate)\n\tcarDetails := tf.carRentalSystem.RentCar(location, startDate, endDate)\n\n\treturn fmt.Sprintf(\"%s\\n%s\\n%s\", flightDetails, hotelDetails, carDetails)\n}\n\n// main function to simulate client code\nfunc main() {\n\ttravelFacade := NewTravelFacade()\n\tbookingDetails := travelFacade.BookTravel(\"New York\", \"Los Angeles\", \"Hilton\", time.Date(2023, 12, 15, 0, 0, 0, 0, time.UTC), time.Date(2023, 12, 20, 0, 0, 0, 0, time.UTC), time.Date(2023, 12, 15, 0, 0, 0, 0, time.UTC), time.Date(2023, 12, 20, 0, 0, 0, 0, time.UTC))\n\tfmt.Println(bookingDetails)\n}\n\n/*\nThe FlightBookingSystem, HotelBookingSystem, and CarRentalSystem structs represent the subsystems of flight booking, hotel booking, and car rental, respectively.\n\nThe TravelFacade struct provides a simplified interface for booking a complete travel package. It encapsulates the complexities of interacting with the subsystems.\n\nThe main function simulates client code that interacts with the TravelFacade to book a complete travel package without directly interacting with the subsystems.\n*/"}]},{"title":"Flyweight","examples":[{"codeFile":"patterns/structural/flyweight/example","code":"package main\n\nimport \"fmt\"\n\n// Character represents the flyweight object for a character.\ntype Character struct {\n\tcharacter string\n}\n\n// Display method for a Character\nfunc (c *Character) Display(font string, size int) string {\n\treturn fmt.Sprintf(\"Character: %s, Font: %s, Size: %d\", c.character, font, size)\n}\n\n// CharacterFactory acts as a flyweight factory.\ntype CharacterFactory struct {\n\tcharacters map[string]*Character\n}\n\n// NewCharacterFactory creates a new instance of CharacterFactory\nfunc NewCharacterFactory() *CharacterFactory {\n\treturn &CharacterFactory{characters: make(map[string]*Character)}\n}\n\n// GetCharacter retrieves or creates an instance of a Character.\nfunc (f *CharacterFactory) GetCharacter(character string) *Character {\n\tif _, exists := f.characters[character]; !exists {\n\t\tf.characters[character] = &Character{character}\n\t}\n\treturn f.characters[character]\n}\n\nfunc main() {\n\tcharacterFactory := NewCharacterFactory()\n\n\t// Text document\n\ttext := \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\"\n\n\t// Rendering text with flyweight characters\n\tvar renderedText []string\n\n\tfor _, char := range text {\n\t\tcharacter := characterFactory.GetCharacter(string(char))\n\t\trenderedText = append(renderedText, character.Display(\"Arial\", 12)) // Assume same font and size for simplicity\n\t}\n\n\t// Displaying rendered text\n\tfmt.Println(renderedText)\n}\n\n/**\n* The Character struct represents the flyweight object for a character. It contains intrinsic\n* state (the character itself).\n*\n* The CharacterFactory struct acts as a flyweight factory, creating and managing flyweight\n* objects. It ensures that each character is shared among multiple instances.\n*\n* In the main function, we create a text document and render it using flyweight characters.\n* Instead of creating a new character object for each character in the text, we retrieve\n* existing flyweight characters from the factory, saving memory and improving performance.\n*/"}]},{"title":"Proxy","examples":[{"codeFile":"patterns/structural/proxy/example","code":"package main\n\nimport (\n\t\"fmt\"\n)\n\n// IHttpServer represents the common behavior of RealSubject and Proxy\ntype IHttpServer interface {\n\trequest(url string) (string, error)\n}\n\n// HttpServer is the actual HTTP server implementation\ntype HttpServer struct{}\n\n// request simulates an HTTP request to the actual server\nfunc (h *HttpServer) request(url string) (string, error) {\n\treturn fmt.Sprintf(\"Response from server for URL: %s\", url), nil\n}\n\n// ProxyServer is a proxy server that intercepts requests before forwarding them to the real server\ntype ProxyServer struct {\n\thttpServer *HttpServer\n}\n\n// NewProxyServer creates a new instance of ProxyServer\nfunc NewProxyServer() *ProxyServer {\n\treturn &ProxyServer{\n\t\thttpServer: &HttpServer{},\n\t}\n}\n\n// request performs additional logic before forwarding the request to the real server\nfunc (p *ProxyServer) request(url string) (string, error) {\n\t// Additional logic can be added here, e.g., caching, access control, logging\n\tfmt.Printf(\"Proxy: Intercepted request for URL: %s\\n\", url)\n\n\t// Forward the request to the real server\n\tresponse, err := p.httpServer.request(url)\n\tif err != nil {\n\t\treturn \"\", err\n\t}\n\n\t// Additional processing on the response can be done here\n\n\treturn response, nil\n}\n\n// testProxy is the client code that sends a request to the proxy server\nfunc testProxy() {\n\tproxy := NewProxyServer()\n\n\t// Client sends a request to the proxy server\n\tresponse, err := proxy.request(\"https://example.com\")\n\tif err != nil {\n\t\tfmt.Println(\"Error:\", err)\n\t\treturn\n\t}\n\n\tfmt.Println(response)\n}\n\nfunc main() {\n\t// Test the proxy\n\ttestProxy()\n}\n\n// Explanation:\n//\n// The IHttpServer interface defines the common behavior for both the HttpServer and ProxyServer structs.\n//\n// The HttpServer struct represents the real HTTP server implementation. It implements the request method\n// to simulate sending HTTP requests to an actual server.\n//\n// The ProxyServer struct acts as a proxy server. It intercepts requests before forwarding them to the real\n// server. The request method of the proxy performs additional tasks such as logging, caching, or access\n// control before delegating the request to the real server.\n//\n// In the client code, we instantiate a ProxyServer object and send a request to it. The proxy intercepts\n// the request, performs any necessary processing, and then forwards the request to the real server.\n// Finally, it returns the response to the client."}]}]},"principles":{"principles_solid":[{"title":"Single Responsibility Principle (SRP)","examples":[{"title":"Good Example","codeFile":"principles/solid/single-responsibility/good-example","code":"package main\n\nimport (\n\t\"fmt\"\n)\n\n// Employee struct responsible only for storing employee data\ntype Employee struct {\n\tname     string\n\tposition string\n\tsalary   int\n}\n\n// NewEmployee is a constructor for creating a new Employee\nfunc NewEmployee(name, position string, salary int) *Employee {\n\treturn &Employee{name: name, position: position, salary: salary}\n}\n\nfunc (e *Employee) GetName() string {\n\treturn e.name\n}\n\nfunc (e *Employee) GetPosition() string {\n\treturn e.position\n}\n\nfunc (e *Employee) GetSalary() int {\n\treturn e.salary\n}\n\n// EmployeePrinter struct responsible only for printing employee information\ntype EmployeePrinter struct{}\n\nfunc (p *EmployeePrinter) Print(employee *Employee) {\n\tfmt.Printf(\"Name: %s\\n\", employee.GetName())\n\tfmt.Printf(\"Position: %s\\n\", employee.GetPosition())\n\tfmt.Printf(\"Salary: %d\\n\", employee.GetSalary())\n}\n\nfunc main() {\n\t// Usage\n\temployee := NewEmployee(\"John Doe\", \"Software Engineer\", 50000)\n\tprinter := EmployeePrinter{}\n\tprinter.Print(employee)\n}"},{"title":"Bad Example","codeFile":"principles/solid/single-responsibility/bad-example","code":"package main\n\nimport \"fmt\"\n\ntype Employee struct {\n\tname     string\n\tposition string\n\tsalary   int\n}\n\n// Constructor for Employee\nfunc NewEmployee(name string, position string, salary int) *Employee {\n\treturn &Employee{name: name, position: position, salary: salary}\n}\n\n// Method responsible for printing employee information\nfunc (e *Employee) Print() {\n\tfmt.Printf(\"Name: %s\\n\", e.name)\n\tfmt.Printf(\"Position: %s\\n\", e.position)\n\tfmt.Printf(\"Salary: %d\\n\", e.salary)\n}\n\nfunc main() {\n\temployee := NewEmployee(\"John Doe\", \"Software Engineer\", 50000)\n\temployee.Print()\n}"}]},{"title":"Open/Closed Principle (OCP)","examples":[{"title":"Good Example","codeFile":"principles/solid/open-closed/good-example","code":"package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\n// Shape - a base type that others will conform to.\n// Using an interface to demonstrate Open-Closed Principle.\ntype Shape interface {\n    ComputeArea() float64\n}\n\n// Rectangle - a concrete Shape.\ntype Rectangle struct {\n    Width, Height float64\n}\n\n// ComputeArea calculates area of the Rectangle, a method making Rectangle conform to Shape.\nfunc (r Rectangle) ComputeArea() float64 {\n    return r.Width * r.Height\n}\n\n// Circle - another concrete Shape.\ntype Circle struct {\n    Radius float64\n}\n\n// ComputeArea calculates area of the Circle, a method making Circle conform to Shape.\nfunc (c Circle) ComputeArea() float64 {\n    return math.Pi * c.Radius * c.Radius\n}\n\n// main function to demonstrate use\nfunc main() {\n    var shapes []Shape = []Shape{\n        Rectangle{Width: 10, Height: 5},\n        Circle{Radius: 7},\n    }\n\n    for _, shape := range shapes {\n        fmt.Println(shape.ComputeArea())\n    }\n}"},{"title":"Bad Example","codeFile":"principles/solid/open-closed/bad-example","code":"package main\n\nimport (\n\t\"math\"\n)\n\n// Define a Shape interface with a method area\ntype Shape interface {\n\tarea() float64\n}\n\n// Rectangle struct adhering to the Shape interface\ntype Rectangle struct {\n\twidth, height float64\n}\n\n// Rectangle's area method\nfunc (r Rectangle) area() float64 {\n\treturn r.width * r.height // Compute area for Rectangle\n}\n\n// Circle struct adhering to the Shape interface\ntype Circle struct {\n\tradius float64\n}\n\n// Circle's area method\nfunc (c Circle) area() float64 {\n\treturn math.Pi * c.radius * c.radius // Compute area for Circle\n}\n\n// AreaCalculator struct is now simplified\ntype AreaCalculator struct{}\n\n// computeArea takes in a shape and utilizes the area method of the Shape interface\nfunc (ac AreaCalculator) computeArea(shape Shape) float64 {\n\treturn shape.area() // Dynamically computes area based on shape type\n}\n\n// Usage example within main function\nfunc main() {\n\t// You can define shapes like this\n\trect := Rectangle{width: 5, height: 10}\n\tcircle := Circle{radius: 7}\n\n\tcalculator := AreaCalculator{}\n\n\t// Now it's simple to compute area for both shapes\n\t// without modifying or adding new functionality directly inside AreaCalculator\n\t// This adheres to the open-closed principle\n\trectArea := calculator.computeArea(rect)\n\tcircleArea := calculator.computeArea(circle)\n\n\t// Outputs can be used or displayed as needed\n\tprintln(\"Rectangle Area:\", rectArea)\n\tprintln(\"Circle Area:\", circleArea)\n}"}]},{"title":"Liskov Substitution Principle (LSP)","examples":[{"title":"Good Example","codeFile":"principles/solid/liskov-substitution/good-example","code":"package main\n\nimport \"fmt\"\n\n// Bird interface that defines a fly method\ntype Bird interface {\n  Fly()\n}\n\n// Duck struct implements Bird interface\ntype Duck struct{}\n\n// Fly method for Duck\nfunc (d Duck) Fly() {\n  fmt.Println(\"Bird is flying\")\n}\n\n// Quack method for Duck\nfunc (d Duck) Quack() {\n  fmt.Println(\"Duck is quacking\")\n}\n\n// Goose struct implements Bird interface\ntype Goose struct{}\n\n// Fly method for Goose\nfunc (g Goose) Fly() {\n  fmt.Println(\"Bird is flying\")\n}\n\n// Swim method for Goose\nfunc (g Goose) Swim() {\n  fmt.Println(\"Goose is swimming\")\n}\n\n// makeBirdFly takes a Bird interface and calls its Fly method\nfunc makeBirdFly(bird Bird) {\n  bird.Fly()\n}\n\nfunc main() {\n  duck := Duck{}\n  goose := Goose{}\n\n  makeBirdFly(duck)    // Output: Bird is flying\n  makeBirdFly(goose)   // Output: Bird is flying\n}"},{"title":"Bad Example","codeFile":"principles/solid/liskov-substitution/bad-example","code":"package main\n\nimport (\n\t\"fmt\"\n)\n\ntype Bird interface {\n\tFly() error\n}\n\n// Implement Fly method for each specific type of Bird\ntype GenericBird struct{}\n\nfunc (gb GenericBird) Fly() error {\n\t// Implement generic bird flying behavior\n\tfmt.Println(\"This bird is flying.\")\n\treturn nil\n}\n\ntype Ostrich struct{}\n\nfunc (o Ostrich) Fly() error {\n\t// Ostrich, being a Bird, overrides Fly but it doesn't actually fly, indicating a violation of Liskov Substitution Principle.\n\treturn fmt.Errorf(\"can't fly\")\n}\n\n// A better approach adheres to Liskov Substitution Principle by avoiding unexpected behavior from the Fly method.\n// We refactor our design to accommodate birds that can't fly without breaking the principle.\n\ntype NonFlyingBird struct{}\n\nfunc (nfb NonFlyingBird) Run() {\n\t// Specific behavior for non-flying birds\n\tfmt.Println(\"This bird runs instead of flies.\")\n}\n\nfunc main() {\n\t// Example usage\n\tvar bird Bird = GenericBird{}\n\tbird.Fly()\n\n\tvar ostrich Bird = Ostrich{}\n\terr := ostrich.Fly()\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\n\t// Using the refined structure\n\tvar nonFlyingBird NonFlyingBird = NonFlyingBird{}\n\tnonFlyingBird.Run()\n}"}]},{"title":"Interface Segregation Principle (ISP)","examples":[{"title":"Good Example","codeFile":"principles/solid/interface-segregation/good-example","code":"package main\n\nimport \"fmt\"\n\n// Printer interface\ntype Printer interface {\n    PrintDocument()\n}\n\n// Fax interface\ntype Fax interface {\n    FaxDocument()\n}\n\n// Scanner interface\ntype Scanner interface {\n    ScanDocument()\n}\n\n// SimplePrinter struct implements Printer\ntype SimplePrinter struct{}\n\nfunc (p SimplePrinter) PrintDocument() {\n    fmt.Println(\"Printing document...\")\n}\n\n// MultifunctionalPrinter struct implements Printer, Fax, and Scanner\ntype MultifunctionalPrinter struct{}\n\nfunc (m MultifunctionalPrinter) PrintDocument() {\n    fmt.Println(\"Printing document...\")\n}\n\nfunc (m MultifunctionalPrinter) FaxDocument() {\n    fmt.Println(\"Faxing document...\")\n}\n\nfunc (m MultifunctionalPrinter) ScanDocument() {\n    fmt.Println(\"Scanning document...\")\n}\n\n// Example usage\nfunc main() {\n    var printer Printer = SimplePrinter{}\n    printer.PrintDocument()\n\n    var mfp Printer = MultifunctionalPrinter{}\n    mfp.PrintDocument()\n    // For faxing and scanning, we need to assert the MultifunctionalPrinter type\n    (mfp.(MultifunctionalPrinter)).FaxDocument()\n    (mfp.(MultifunctionalPrinter)).ScanDocument()\n}"},{"title":"Bad Example","codeFile":"principles/solid/interface-segregation/bad-example","code":"package main\n\nimport \"fmt\"\n\n// Machine interface that includes too many operations\ntype Machine interface {\n\tPrintDocument()\n\tFaxDocument()\n\tScanDocument()\n}\n\n// OldPrinter struct which does not support faxing or scanning\ntype OldPrinter struct{}\n\n// PrintDocument method for OldPrinter\nfunc (p OldPrinter) PrintDocument() {\n\tfmt.Println(\"Printing document...\")\n}\n\n// FaxDocument method for OldPrinter, which it can't perform\nfunc (p OldPrinter) FaxDocument() {\n\tpanic(\"This printer cannot fax documents.\")\n}\n\n// ScanDocument method for OldPrinter, which it can't perform\nfunc (p OldPrinter) ScanDocument() {\n\tpanic(\"This printer cannot scan documents.\")\n}\n\n// To adhere to the Interface Segregation Principle, we refactor our interfaces\n\n// Printer interface for devices that can print\ntype Printer interface {\n\tPrintDocument()\n}\n\n// Scanner interface for devices that can scan\ntype Scanner interface {\n\tScanDocument()\n}\n\n// FaxMachine interface for devices that can fax\ntype FaxMachine interface {\n\tFaxDocument()\n}\n\n// BetterOldPrinter struct implementing only the Printer interface\ntype BetterOldPrinter struct{}\n\n// PrintDocument method for BetterOldPrinter\nfunc (p BetterOldPrinter) PrintDocument() {\n\tfmt.Println(\"Printing document...\")\n}\n\nfunc main() {\n\t// Demonstrating using the OldPrinter\n\top := OldPrinter{}\n\top.PrintDocument()\n\t// op.FaxDocument() // This will panic\n\t// op.ScanDocument() // This will panic\n\n\t// Demonstrating using the BetterOldPrinter\n\tbop := BetterOldPrinter{}\n\tbop.PrintDocument()\n}"}]},{"title":"Dependency Inversion Principle (DIP)","examples":[{"title":"Good Example","codeFile":"principles/solid/interface-segregation/good-example","code":"package main\n\nimport \"fmt\"\n\n// Printer interface\ntype Printer interface {\n    PrintDocument()\n}\n\n// Fax interface\ntype Fax interface {\n    FaxDocument()\n}\n\n// Scanner interface\ntype Scanner interface {\n    ScanDocument()\n}\n\n// SimplePrinter struct implements Printer\ntype SimplePrinter struct{}\n\nfunc (p SimplePrinter) PrintDocument() {\n    fmt.Println(\"Printing document...\")\n}\n\n// MultifunctionalPrinter struct implements Printer, Fax, and Scanner\ntype MultifunctionalPrinter struct{}\n\nfunc (m MultifunctionalPrinter) PrintDocument() {\n    fmt.Println(\"Printing document...\")\n}\n\nfunc (m MultifunctionalPrinter) FaxDocument() {\n    fmt.Println(\"Faxing document...\")\n}\n\nfunc (m MultifunctionalPrinter) ScanDocument() {\n    fmt.Println(\"Scanning document...\")\n}\n\n// Example usage\nfunc main() {\n    var printer Printer = SimplePrinter{}\n    printer.PrintDocument()\n\n    var mfp Printer = MultifunctionalPrinter{}\n    mfp.PrintDocument()\n    // For faxing and scanning, we need to assert the MultifunctionalPrinter type\n    (mfp.(MultifunctionalPrinter)).FaxDocument()\n    (mfp.(MultifunctionalPrinter)).ScanDocument()\n}"},{"title":"Bad Example","codeFile":"principles/solid/interface-segregation/bad-example","code":"package main\n\nimport \"fmt\"\n\n// Machine interface that includes too many operations\ntype Machine interface {\n\tPrintDocument()\n\tFaxDocument()\n\tScanDocument()\n}\n\n// OldPrinter struct which does not support faxing or scanning\ntype OldPrinter struct{}\n\n// PrintDocument method for OldPrinter\nfunc (p OldPrinter) PrintDocument() {\n\tfmt.Println(\"Printing document...\")\n}\n\n// FaxDocument method for OldPrinter, which it can't perform\nfunc (p OldPrinter) FaxDocument() {\n\tpanic(\"This printer cannot fax documents.\")\n}\n\n// ScanDocument method for OldPrinter, which it can't perform\nfunc (p OldPrinter) ScanDocument() {\n\tpanic(\"This printer cannot scan documents.\")\n}\n\n// To adhere to the Interface Segregation Principle, we refactor our interfaces\n\n// Printer interface for devices that can print\ntype Printer interface {\n\tPrintDocument()\n}\n\n// Scanner interface for devices that can scan\ntype Scanner interface {\n\tScanDocument()\n}\n\n// FaxMachine interface for devices that can fax\ntype FaxMachine interface {\n\tFaxDocument()\n}\n\n// BetterOldPrinter struct implementing only the Printer interface\ntype BetterOldPrinter struct{}\n\n// PrintDocument method for BetterOldPrinter\nfunc (p BetterOldPrinter) PrintDocument() {\n\tfmt.Println(\"Printing document...\")\n}\n\nfunc main() {\n\t// Demonstrating using the OldPrinter\n\top := OldPrinter{}\n\top.PrintDocument()\n\t// op.FaxDocument() // This will panic\n\t// op.ScanDocument() // This will panic\n\n\t// Demonstrating using the BetterOldPrinter\n\tbop := BetterOldPrinter{}\n\tbop.PrintDocument()\n}"}]}],"principles_other":[{"title":"Don't Repeat Yourself (DRY)","examples":[{"title":"Good Example","codeFile":"principles/other/dry/good-example","code":"package main\n\nimport (\n\t\"fmt\"\n)\n\n// addTax adds tax to a price. If no rate is provided, a default of 5% is used.\nfunc addTax(price float64, rate ...float64) float64 {\n\tdefaultRate := 0.05\n\tif len(rate) > 0 {\n\t\treturn price + (price * rate[0])\n\t}\n\treturn price + (price * defaultRate)\n}\n\nfunc main() {\n\tfmt.Println(addTax(100))       // Using default tax rate\n\tfmt.Println(addTax(100, 0.10)) // Using custom tax rate\n}"},{"title":"Bad Example","codeFile":"principles/other/dry/bad-example","code":"package main\n\nimport \"fmt\"\n\n// AddTax adds a 5% tax to the given price.\nfunc AddTax(price float64) float64 {\n    return price + (price * 0.05)\n}\n\nfunc main() {\n    foodPrice := AddTax(100)\n    electronicsPrice := AddTax(200)\n    fmt.Println(\"Food price with tax:\", foodPrice)\n    fmt.Println(\"Electronics price with tax:\", electronicsPrice)\n}"}]},{"title":"Keep It Simple Stupid (KISS)","examples":[{"title":"Good Example","codeFile":"principles/other/kiss/good-example","code":"package main\n\nimport (\n    \"fmt\"\n)\n\n// Check if a number is even\nfunc isEven(num int) bool {\n    return num%2 == 0\n}\n\nfunc main() {\n    fmt.Println(isEven(4)) // Should print true\n    fmt.Println(isEven(5)) // Should print false\n}"},{"title":"Bad Example","codeFile":"principles/other/kiss/bad-example","code":"package main\n\nimport (\n\t\"fmt\"\n)\n\n// there is no need for absolute value here\nfunc isEven(num int) bool {\n\treturn num%2 == 0\n}\n\nfunc main() {\n\tfmt.Println(isEven(4)) // Should print true\n\tfmt.Println(isEven(3)) // Should print false\n}"}]},{"title":"You Aren't Gonna Need It (YAGNI)","examples":[{"codeFile":"principles/other/yagni/bad-example","code":"package main\n\nimport (\n\t\"fmt\"\n\t\"errors\"\n)\n\ntype Calculator struct{}\n\nfunc (c Calculator) Add(a, b int) int {\n\treturn a + b\n}\n\n// Do not define methods unless they are used\n\nfunc main() {\n\tcalc := Calculator{}\n\tfmt.Println(calc.Add(1, 2))\n}"}]},{"title":"Law of Demeter (Principle of Least Knowledge)","examples":[{"title":"Good Example","codeFile":"principles/other/demeter/good-example","code":"package main\n\ntype Wallet struct {\n\tmoney int\n}\n\nfunc NewWallet() *Wallet {\n\treturn &Wallet{money: 100} // Constructor replacement\n}\n\nfunc (w *Wallet) GetAmount() int {\n\treturn w.money // Accessor method\n}\n\ntype Person struct {\n\twallet *Wallet\n}\n\nfunc NewPerson() *Person {\n\treturn &Person{wallet: NewWallet()} // Composition over inheritance, using a factory method\n}\n\nfunc (p *Person) GetMoneyAmount() int {\n\treturn p.wallet.GetAmount() // Delegating method calls rather than exposing internal structure\n}\n\nfunc purchase(item struct{ price int }, buyer *Person) {\n\tif buyer.GetMoneyAmount() >= item.price {\n\t\t// Purchase logic here\n\t}\n}"},{"title":"Bad Example","codeFile":"principles/other/demeter/bad-example","code":"package main\n\ntype Wallet struct {\n    amount float64\n}\n\n// Constructor for Wallet\nfunc NewWallet() *Wallet {\n    return &Wallet{amount: 100}\n}\n\nfunc (w *Wallet) CanAfford(price float64) bool {\n    return w.amount >= price\n}\n\ntype Person struct {\n    wallet *Wallet\n}\n\n// Constructor for Person\nfunc NewPerson() *Person {\n    return &Person{wallet: NewWallet()}\n}\n\nfunc purchase(itemPrice float64, buyer *Person) {\n    if buyer.wallet.CanAfford(itemPrice) {\n        // Purchase logic...\n    }\n}"}]},{"title":"Separation of Concerns","examples":[{"title":"Good Example","codeFile":"principles/other/separation/good-example","code":"package main\n\nimport \"fmt\"\n\n// AuthenticationService - Authentication service\ntype AuthenticationService struct{}\n\nfunc (a AuthenticationService) Login(username, password string) bool {\n    // Authentication logic here\n    return true // Dummy implementation\n}\n\nfunc (a AuthenticationService) Logout() {\n    // Logout logic here\n}\n\n// DataService - Data service\ntype DataService struct{}\n\nfunc (d DataService) FetchData() []interface{} {\n    // Data retrieval logic here\n    return make([]interface{}, 0) // Dummy implementation\n}\n\n// UserController handles user actions\ntype UserController struct {\n    authService AuthenticationService\n}\n\nfunc NewUserController(authService AuthenticationService) *UserController {\n    return &UserController{authService: authService}\n}\n\nfunc (uc UserController) LoginUser(username, password string) bool {\n    return uc.authService.Login(username, password)\n}\n\nfunc (uc UserController) LogoutUser() {\n    uc.authService.Logout()\n}\n\n// DataController handles data actions\ntype DataController struct {\n    dataService DataService\n}\n\nfunc NewDataController(dataService DataService) *DataController {\n    return &DataController{dataService: dataService}\n}\n\nfunc (dc DataController) GetData() []interface{} {\n    return dc.dataService.FetchData()\n}\n\nfunc main() {\n    authService := AuthenticationService{}\n    dataService := DataService{}\n\n    userController := NewUserController(authService)\n    dataController := NewDataController(dataService)\n\n    // Simulate user login/logout\n    userController.LoginUser(\"username\", \"password\")\n    userController.LogoutUser()\n\n    // Retrieve data\n    data := dataController.GetData()\n    fmt.Println(data)\n}"},{"title":"Bad Example","codeFile":"principles/other/separation/bad-example","code":"package main\n\nimport \"fmt\"\n\n// AuthenticationService handles user authentication\ntype AuthenticationService struct{}\n\nfunc (as *AuthenticationService) Login(username, password string) bool {\n    // Authentication logic here\n    return true // Dummy implementation\n}\n\nfunc (as *AuthenticationService) Logout() {\n    // Logout logic here\n}\n\n// DataService handles data retrieval\ntype DataService struct{}\n\nfunc (ds *DataService) FetchData() []interface{} {\n    // Data retrieval logic here\n    return make([]interface{}, 0) // Dummy implementation\n}\n\n// Separated to respect the Single Responsibility Principle\n// AuthenticationController handles user authentication\ntype AuthenticationController struct {\n    authService *AuthenticationService\n}\n\nfunc NewAuthenticationController(authService *AuthenticationService) *AuthenticationController {\n    return &AuthenticationController{authService: authService}\n}\n\nfunc (ac *AuthenticationController) LoginUser(username, password string) bool {\n    // Authentication logic here\n    return ac.authService.Login(username, password)\n}\n\nfunc (ac *AuthenticationController) LogoutUser() {\n    // Logout logic here\n    ac.authService.Logout()\n}\n\n// DataController handles data retrieval\ntype DataController struct {\n    dataService *DataService\n}\n\nfunc NewDataController(dataService *DataService) *DataController {\n    return &DataController{dataService: dataService}\n}\n\nfunc (dc *DataController) FetchUserdata(isAuthenticated bool) {\n    if isAuthenticated {\n        // Retrieve user data\n        userData := dc.dataService.FetchData()\n        fmt.Println(userData)\n    }\n}\n\nfunc main() {\n    authService := &AuthenticationService{}\n    dataService := &DataService{}\n\n    authController := NewAuthenticationController(authService)\n    dataController := NewDataController(dataService)\n\n    // Simulate user login/logout\n    isAuthenticated := authController.LoginUser(\"username\", \"password\")\n    dataController.FetchUserdata(isAuthenticated)\n    authController.LogoutUser()\n}"}]}],"principles_proprietary":[{"title":"Static Typing","description":[{"variant":"subtitle1","content":"Go is a statically typed language, meaning variables are explicitly typed, and their types are checked at compile time. This helps catch type-related errors early in the development process.\n"}],"examples":[{"code":"var data int = 42 // data is explicitly typed as an integer\n// data = 'hello' // This would result in a compile-time error\n"}]},{"title":"Structs Instead of Classes","description":[{"variant":"subtitle1","content":"Go uses structs instead of classes for structuring code. Methods can be associated with structs to provide behavior.\n"}],"examples":[{"code":"type Person struct {\n    FirstName string\n}\n\nfunc (p Person) SayHello() string {\n    return \"Hello, I'm \" + p.FirstName\n}\n\nvar john = Person{\"John\"}\nfmt.Println(john.SayHello()) // \"Hello, I'm John\"\n"}]},{"title":"Interfaces for Polymorphism","description":[{"variant":"subtitle1","content":"Go uses interfaces to achieve polymorphism. An interface type is defined by a set of method signatures, and any type that implements those methods satisfies the interface.\n"}],"examples":[{"code":"type Greeter interface {\n    Greet() string\n}\n\ntype EnglishSpeaker struct{}\n\nfunc (EnglishSpeaker) Greet() string {\n    return \"Hello!\"\n}\n\ntype SpanishSpeaker struct{}\n\nfunc (SpanishSpeaker) Greet() string {\n    return \"Hola!\"\n}\n"}]},{"title":"Concurrency with Goroutines and Channels","description":[{"variant":"subtitle1","content":"Go provides built-in support for concurrency with goroutines and channels. Goroutines are functions that can run concurrently, and channels are used for communication between them.\n"}],"examples":[{"code":"func say(s string) {\n    for i := 0; i < 5; i++ {\n        fmt.Println(s)\n    }\n}\n\nfunc main() {\n    go say(\"world\")\n    say(\"hello\")\n}\n"}]},{"title":"Error Handling","description":[{"variant":"subtitle1","content":"Go handles errors explicitly using error values, rather than exceptions. Functions often return an error value, and calling code checks this error before proceeding.\n"}],"examples":[{"code":"func divide(a, b float64) (float64, error) {\n    if b == 0.0 {\n        return 0.0, errors.New(\"division by zero\")\n    }\n    return a / b, nil\n}\n"}]},{"title":"Package System","description":[{"variant":"subtitle1","content":"Go's package system organizes code into reusable components. Each package serves as a namespace for its identifiers and can be imported by other packages.\n"}],"examples":[{"code":"package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc main() {\n    fmt.Println(math.Sqrt(16))\n}\n"}]},{"title":"Composition over Inheritance","description":[{"variant":"subtitle1","content":"Go favors composition over inheritance, allowing types to be composed using smaller pieces of functionality.\n"}],"examples":[{"code":"type Engine interface {\n    Start()\n    Stop()\n}\n\ntype Car struct {\n    Engine\n}\n"}]},{"title":"Type Assertions and Type Switches","description":[{"variant":"subtitle1","content":"Go allows for type assertions and type switches to handle dynamic types safely at runtime, particularly when working with interfaces.\n"}],"examples":[{"code":"var i interface{} = \"hello\"\ns := i.(string)\nfmt.Println(s)\n"}]},{"title":"Deferred Function Calls","description":[{"variant":"subtitle1","content":"Go allows functions to be deferred until the surrounding function completes. This is often used for cleanup activities.\n"}],"examples":[{"code":"func main() {\n    defer fmt.Println(\"world\")\n    fmt.Println(\"hello\")\n}\n"}]},{"title":"Go Routines and Select Statement","description":[{"variant":"subtitle1","content":"Go's select statement lets a goroutine wait on multiple communication operations, facilitating complex concurrency patterns.\n"}],"examples":[{"code":"select {\ncase msg1 := <-channel1:\n    fmt.Println(\"Received\", msg1)\ncase msg2 := <-channel2:\n    fmt.Println(\"Received\", msg2)\n}\n"}]}]}}