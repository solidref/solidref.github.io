{"name":"Go (Golang)","code":"go","birth":2009,"death":"N/A","inspiredBy":["c","oberon","pascal","limbo","python","alef"],"inspiring":["rust","nim","crystal"],"description":"Go, often referred to as Golang, is an open-source programming language developed at Google.\nIt is known for its simplicity, efficiency, and reliable concurrency handling. Go is statically\ntyped, compiled, and syntactically similar to C, but with memory safety, garbage collection,\nstructural typing, and CSP-style concurrency features. It's widely used in cloud and network\nservices, command-line tools, and web applications. A notable feature of Go is its efficient\nhandling of concurrent operations, making it a popular choice for building high-performance\napplications. Go's design is focused on simplicity and readability, which has led to its wide\nadoption in software engineering for scalable server-side applications. The language has a\nstrong standard library, robust tooling, and a rapidly growing ecosystem.\n","patterns":{"patterns_behavioural":[{"title":"Chain Of Responsibility","examples":[{"code":"package main\n\nimport \"fmt\"\n\ntype Handler interface {\n    Handle(request string) string\n}\n\ntype BaseHandler struct {\n    next Handler\n}\n\nfunc (h *BaseHandler) SetNext(next Handler) {\n    h.next = next\n}\n\ntype ConcreteHandler1 struct {\n    BaseHandler\n}\n\nfunc (h *ConcreteHandler1) Handle(request string) string {\n    if request == \"handle1\" {\n        return \"Handled by ConcreteHandler1\"\n    }\n    return h.BaseHandler.Handle(request)\n}\n\ntype ConcreteHandler2 struct {\n    BaseHandler\n}\n\nfunc (h *ConcreteHandler2) Handle(request string) string {\n    if request == \"handle2\" {\n        return \"Handled by ConcreteHandler2\"\n    }\n    return h.BaseHandler.Handle(request)\n}\n\nfunc main() {\n    handler1 := &ConcreteHandler1{}\n    handler2 := &ConcreteHandler2{}\n    handler1.SetNext(handler2)\n\n    fmt.Println(handler1.Handle(\"handle2\"))\n    fmt.Println(handler1.Handle(\"handle1\"))\n}\n"}]},{"title":"Command","examples":[{"code":"package main\n\nimport \"fmt\"\n\ntype Command interface {\n    Execute()\n}\n\ntype Light struct{}\n\nfunc (l *Light) On() {\n    fmt.Println(\"Light is on\")\n}\n\nfunc (l *Light) Off() {\n    fmt.Println(\"Light is off\")\n}\n\ntype LightOnCommand struct {\n    light *Light\n}\n\nfunc (c *LightOnCommand) Execute() {\n    c.light.On()\n}\n\ntype LightOffCommand struct {\n    light *Light\n}\n\nfunc (c *LightOffCommand) Execute() {\n    c.light.Off()\n}\n\ntype RemoteControl struct {\n    command Command\n}\n\nfunc (r *RemoteControl) SetCommand(command Command) {\n    r.command = command\n}\n\nfunc (r *RemoteControl) PressButton() {\n    r.command.Execute()\n}\n\nfunc main() {\n    light := &Light{}\n    lightOnCommand := &LightOnCommand{light: light}\n    lightOffCommand := &LightOffCommand{light: light}\n    remote := RemoteControl{}\n\n    remote.SetCommand(lightOnCommand)\n    remote.PressButton()\n\n    remote.SetCommand(lightOffCommand)\n    remote.PressButton()\n}\n"}]},{"title":"Interpreter","description":[{"content":"The Interpreter pattern provides a way to evaluate language grammar or expression. This pattern involves implementing an expression interface which tells to interpret a particular context. It is used in SQL parsing, symbol processing engine, etc.","variant":"subtitle1"}],"examples":[{"code":"package main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\n// Expression interface used to interpret expressions\ntype Expression interface {\n    Interpret(context string) bool\n}\n\n// TerminalExpression\ntype TerminalExpression struct {\n    data string\n}\n\nfunc (t *TerminalExpression) Interpret(context string) bool {\n    if strings.Contains(context, t.data) {\n        return true\n    }\n    return false\n}\n\n// OrExpression\ntype OrExpression struct {\n    expr1 Expression\n    expr2 Expression\n}\n\nfunc (o *OrExpression) Interpret(context string) bool {\n    return o.expr1.Interpret(context) || o.expr2.Interpret(context)\n}\n\n// AndExpression\ntype AndExpression struct {\n    expr1 Expression\n    expr2 Expression\n}\n\nfunc (a *AndExpression) Interpret(context string) bool {\n    return a.expr1.Interpret(context) && a.expr2.Interpret(context)\n}\n\n// main function\nfunc main() {\n    // Rule: Robert and John are male\n    isMale := getMaleExpression()\n    // Rule: Julie is a married woman\n    isMarriedWoman := getMarriedWomanExpression()\n\n    fmt.Println(\"John is male? \", isMale.Interpret(\"John\"))\n    fmt.Println(\"Julie is a married woman? \", isMarriedWoman.Interpret(\"Married Julie\"))\n}\n\nfunc getMaleExpression() Expression {\n    robert := &TerminalExpression{\"Robert\"}\n    john := &TerminalExpression{\"John\"}\n    return &OrExpression{robert, john}\n}\n\nfunc getMarriedWomanExpression() Expression {\n    julie := &TerminalExpression{\"Julie\"}\n    married := &TerminalExpression{\"Married\"}\n    return &AndExpression{julie, married}\n}\n","language":"Go"}]},{"title":"Iterator","examples":[{"code":"package main\n\nimport \"fmt\"\n\ntype Iterator interface {\n    HasNext() bool\n    Next() interface{}\n}\n\ntype Collection interface {\n    CreateIterator() Iterator\n}\n\ntype ConcreteCollection struct {\n    items []interface{}\n}\n\nfunc (c *ConcreteCollection) CreateIterator() Iterator {\n    return &ConcreteIterator{\n        collection: c,\n        index:      0,\n    }\n}\n\nfunc (c *ConcreteCollection) Add(item interface{}) {\n    c.items = append(c.items, item)\n}\n\ntype ConcreteIterator struct {\n    collection *ConcreteCollection\n    index      int\n}\n\nfunc (i *ConcreteIterator) HasNext() bool {\n    return i.index < len(i.collection.items)\n}\n\nfunc (i *ConcreteIterator) Next() interface{} {\n    if i.HasNext() {\n        item := i.collection.items[i.index]\n        i.index++\n        return item\n    }\n    return nil\n}\n\nfunc main() {\n    collection := &ConcreteCollection{}\n    collection.Add(\"Item 1\")\n    collection.Add(\"Item 2\")\n    collection.Add(\"Item 3\")\n\n    iterator := collection.CreateIterator()\n\n    for iterator.HasNext() {\n        fmt.Println(iterator.Next())\n    }\n}\n"}]},{"title":"Mediator","examples":[{"code":"package main\n\nimport \"fmt\"\n\ntype Mediator interface {\n    CanArrive(Train) bool\n    NotifyAboutDeparture()\n}\n\ntype StationManager struct {\n    isPlatformFree bool\n    trainQueue     []Train\n}\n\nfunc NewStationManager() *StationManager {\n    return &StationManager{isPlatformFree: true}\n}\n\nfunc (s *StationManager) CanArrive(train Train) bool {\n    if s.isPlatformFree {\n        s.isPlatformFree = false\n        return true\n    }\n    s.trainQueue = append(s.trainQueue, train)\n    return false\n}\n\nfunc (s *StationManager) NotifyAboutDeparture() {\n    if !s.isPlatformFree {\n        s.isPlatformFree = true\n    }\n    if len(s.trainQueue) > 0 {\n        firstTrain := s.trainQueue[0]\n        s.trainQueue = s.trainQueue[1:]\n        firstTrain.PermitArrival()\n    }\n}\n\ntype Train interface {\n    Arrive()\n    Depart()\n    PermitArrival()\n}\n\ntype PassengerTrain struct {\n    mediator Mediator\n}\n\nfunc (p *PassengerTrain) Arrive() {\n    if p.mediator.CanArrive(p) {\n        fmt.Println(\"PassengerTrain: Arrival permitted. Arriving\")\n    } else {\n        fmt.Println(\"PassengerTrain: Arrival blocked. Waiting\")\n    }\n}\n\nfunc (p *PassengerTrain) Depart() {\n    fmt.Println(\"PassengerTrain: Leaving\")\n    p.mediator.NotifyAboutDeparture()\n}\n\nfunc (p *PassengerTrain) PermitArrival() {\n    fmt.Println(\"PassengerTrain: Arrival permitted\")\n    p.Arrive()\n}\n\ntype FreightTrain struct {\n    mediator Mediator\n}\n\nfunc (f *FreightTrain) Arrive() {\n    if f.mediator.CanArrive(f) {\n        fmt.Println(\"FreightTrain: Arrival permitted. Arriving\")\n    } else {\n        fmt.Println(\"FreightTrain: Arrival blocked. Waiting\")\n    }\n}\n\nfunc (f *FreightTrain) Depart() {\n    fmt.Println(\"FreightTrain: Leaving\")\n    f.mediator.NotifyAboutDeparture()\n}\n\nfunc (f *FreightTrain) PermitArrival() {\n    fmt.Println(\"FreightTrain: Arrival permitted\")\n    f.Arrive()\n}\n\nfunc main() {\n    stationManager := NewStationManager()\n    passengerTrain := &PassengerTrain{mediator: stationManager}\n    freightTrain := &FreightTrain{mediator: stationManager}\n\n    passengerTrain.Arrive()\n    freightTrain.Arrive()\n    passengerTrain.Depart()\n    freightTrain.Depart()\n}\n"}]},{"title":"Memento","examples":[{"code":"package main\n\nimport \"fmt\"\n\ntype Memento interface {\n    GetName() string\n    GetState() string\n}\n\ntype ConcreteMemento struct {\n    state string\n    name  string\n}\n\nfunc (c *ConcreteMemento) GetState() string {\n    return c.state\n}\n\nfunc (c *ConcreteMemento) GetName() string {\n    return c.name\n}\n\ntype Originator struct {\n    state string\n}\n\nfunc (o *Originator) Save() Memento {\n    return &ConcreteMemento{\n        state: o.state,\n        name:  \"Snapshot_\" + o.state,\n    }\n}\n\nfunc (o *Originator) Restore(m Memento) {\n    o.state = m.GetState()\n}\n\nfunc (o *Originator) SetState(state string) {\n    o.state = state\n}\n\nfunc (o *Originator) GetState() string {\n    return o.state\n}\n\ntype Caretaker struct {\n    mementos []Memento\n    originator *Originator\n}\n\nfunc (c *Caretaker) Backup() {\n    fmt.Println(\"Caretaker: Saving Originator's state...\")\n    c.mementos = append(c.mementos, c.originator.Save())\n}\n\nfunc (c *Caretaker) Undo() {\n    if len(c.mementos) == 0 {\n        return\n    }\n    memento := c.mementos[len(c.mementos)-1]\n    c.mementos = c.mementos[:len(c.mementos)-1]\n    fmt.Printf(\"Caretaker: Restoring state to: %s\\n\", memento.GetName())\n    c.originator.Restore(memento)\n}\n\nfunc main() {\n    originator := &Originator{}\n    caretaker := &Caretaker{originator: originator}\n\n    originator.SetState(\"State #1\")\n    caretaker.Backup()\n\n    originator.SetState(\"State #2\")\n    caretaker.Backup()\n\n    originator.SetState(\"State #3\")\n    caretaker.Undo()\n\n    fmt.Println(\"Current State:\", originator.GetState())\n}\n"}]},{"title":"Observer","examples":[{"code":"package main\n\nimport \"fmt\"\n\ntype Observer interface {\n    Update(string)\n}\n\ntype Subject interface {\n    RegisterObserver(Observer)\n    RemoveObserver(Observer)\n    NotifyObservers()\n}\n\ntype Item struct {\n    observerList []Observer\n    name         string\n    inStock      bool\n}\n\nfunc NewItem(name string) *Item {\n    return &Item{\n        name: name,\n    }\n}\n\nfunc (i *Item) UpdateAvailability() {\n    fmt.Printf(\"Item %s is now in stock\\n\", i.name)\n    i.inStock = true\n    i.NotifyObservers()\n}\n\nfunc (i *Item) RegisterObserver(o Observer) {\n    i.observerList = append(i.observerList, o)\n}\n\nfunc (i *Item) RemoveObserver(o Observer) {\n    i.observerList = removeFromslice(i.observerList, o)\n}\n\nfunc (i *Item) NotifyObservers() {\n    for _, observer := range i.observerList {\n        observer.Update(i.name)\n    }\n}\n\ntype Customer struct {\n    id string\n}\n\nfunc (c *Customer) Update(itemName string) {\n    fmt.Printf(\"Sending email to customer %s for item %s\\n\", c.id, itemName)\n}\n\nfunc main() {\n    shirtItem := NewItem(\"Nike Shirt\")\n    observer1 := &Customer{id: \"abc123\"}\n    observer2 := &Customer{id: \"xyz987\"}\n\n    shirtItem.RegisterObserver(observer1)\n    shirtItem.RegisterObserver(observer2)\n\n    shirtItem.UpdateAvailability()\n}\n\nfunc removeFromslice(observerList []Observer, observerToRemove Observer) []Observer {\n    for i, observer := range observerList {\n        if observer == observerToRemove {\n            return append(observerList[:i], observerList[i+1:]...)\n        }\n    }\n    return observerList\n}\n"}]},{"title":"State","examples":[{"code":"package main\n\nimport \"fmt\"\n\ntype State interface {\n    DoAction(context *Context)\n}\n\ntype StartState struct{}\n\nfunc (s *StartState) DoAction(context *Context) {\n    fmt.Println(\"Player is in start state\")\n    context.SetState(s)\n}\n\nfunc (s *StartState) ToString() string {\n    return \"Start State\"\n}\n\ntype StopState struct{}\n\nfunc (s *StopState) DoAction(context *Context) {\n    fmt.Println(\"Player is in stop state\")\n    context.SetState(s)\n}\n\nfunc (s *StopState) ToString() string {\n    return \"Stop State\"\n}\n\ntype Context struct {\n    state State\n}\n\nfunc NewContext() *Context {\n    return &Context{}\n}\n\nfunc (c *Context) SetState(state State) {\n    c.state = state\n}\n\nfunc (c *Context) GetState() State {\n    return c.state\n}\n\nfunc main() {\n    context := NewContext()\n\n    startState := &StartState{}\n    startState.DoAction(context)\n\n    fmt.Println(context.GetState().ToString())\n\n    stopState := &StopState{}\n    stopState.DoAction(context)\n\n    fmt.Println(context.GetState().ToString())\n}\n"}]},{"title":"Strategy","examples":[{"code":"package main\n\nimport \"fmt\"\n\ntype Strategy interface {\n    Execute(int, int) int\n}\n\ntype Add struct{}\n\nfunc (a *Add) Execute(a int, b int) int {\n    return a + b\n}\n\ntype Subtract struct{}\n\nfunc (s *Subtract) Execute(a int, b int) int {\n    return a - b\n}\n\ntype Multiply struct{}\n\nfunc (m *Multiply) Execute(a int, b int) int {\n    return a * b\n}\n\ntype Context struct {\n    strategy Strategy\n}\n\nfunc NewContext(strategy Strategy) *Context {\n    return &Context{\n        strategy: strategy,\n    }\n}\n\nfunc (c *Context) ExecuteStrategy(a int, b int) int {\n    return c.strategy.Execute(a, b)\n}\n\nfunc main() {\n    addStrategy := &Add{}\n    context := NewContext(addStrategy)\n    fmt.Println(\"10 + 5 =\", context.ExecuteStrategy(10, 5))\n\n    subtractStrategy := &Subtract{}\n    context.strategy = subtractStrategy\n    fmt.Println(\"10 - 5 =\", context.ExecuteStrategy(10, 5))\n\n    multiplyStrategy := &Multiply{}\n    context.strategy = multiplyStrategy\n    fmt.Println(\"10 * 5 =\", context.ExecuteStrategy(10, 5))\n}\n"}]},{"title":"Template Method","examples":[{"code":"package main\n\nimport \"fmt\"\n\ntype Game interface {\n    Start()\n    Play()\n    End()\n}\n\nfunc PlayGame(g Game) {\n    g.Start()\n    g.Play()\n    g.End()\n}\n\ntype Football struct{}\n\nfunc (f *Football) Start() {\n    fmt.Println(\"Football Game Started. Welcome to the game!\")\n}\n\nfunc (f *Football) Play() {\n    fmt.Println(\"Football Game Playing. Enjoy the game!\")\n}\n\nfunc (f *Football) End() {\n    fmt.Println(\"Football Game Finished!\")\n}\n\ntype Cricket struct{}\n\nfunc (c *Cricket) Start() {\n    fmt.Println(\"Cricket Game Started. Welcome to the game!\")\n}\n\nfunc (c *Cricket) Play() {\n    fmt.Println(\"Cricket Game Playing. Enjoy the game!\")\n}\n\nfunc (c *Cricket) End() {\n    fmt.Println(\"Cricket Game Finished!\")\n}\n\nfunc main() {\n    football := &Football{}\n    PlayGame(football)\n\n    cricket := &Cricket{}\n    PlayGame(cricket)\n}\n"}]},{"title":"Visitor","examples":[{"code":"package main\n\nimport \"fmt\"\n\ntype ComputerPart interface {\n    Accept(ComputerPartVisitor)\n}\n\ntype ComputerPartVisitor interface {\n    VisitComputer(*Computer)\n    VisitMouse(*Mouse)\n    VisitKeyboard(*Keyboard)\n    VisitMonitor(*Monitor)\n}\n\ntype Computer struct{}\ntype Mouse struct{}\ntype Keyboard struct{}\ntype Monitor struct{}\n\nfunc (c *Computer) Accept(visitor ComputerPartVisitor) {\n    visitor.VisitComputer(c)\n}\n\nfunc (m *Mouse) Accept(visitor ComputerPartVisitor) {\n    visitor.VisitMouse(m)\n}\n\nfunc (k *Keyboard) Accept(visitor ComputerPartVisitor) {\n    visitor.VisitKeyboard(k)\n}\n\nfunc (mo *Monitor) Accept(visitor ComputerPartVisitor) {\n    visitor.VisitMonitor(mo)\n}\n\ntype ComputerPartDisplayVisitor struct{}\n\nfunc (cpdv *ComputerPartDisplayVisitor) VisitComputer(c *Computer) {\n    fmt.Println(\"Displaying Computer.\")\n}\n\nfunc (cpdv *ComputerPartDisplayVisitor) VisitMouse(m *Mouse) {\n    fmt.Println(\"Displaying Mouse.\")\n}\n\nfunc (cpdv *ComputerPartDisplayVisitor) VisitKeyboard(k *Keyboard) {\n    fmt.Println(\"Displaying Keyboard.\")\n}\n\nfunc (cpdv *ComputerPartDisplayVisitor) VisitMonitor(mo *Monitor) {\n    fmt.Println(\"Displaying Monitor.\")\n}\n\nfunc main() {\n    computer := &Computer{}\n    computer.Accept(new(ComputerPartDisplayVisitor))\n}\n"}]}],"patterns_creational":[{"title":"Factory Method","examples":[{"code":"package main\n\nimport \"fmt\"\n\n// Product defines the interface of objects the factory method creates.\ntype Product interface {\n    Use() string\n}\n\n// ConcreteProduct1 represents a concrete product created by the concrete creator.\ntype ConcreteProduct1 struct{}\n\nfunc (p *ConcreteProduct1) Use() string {\n    return \"Result of ConcreteProduct1\"\n}\n\n// ConcreteProduct2 represents another concrete product created by the concrete creator.\ntype ConcreteProduct2 struct{}\n\nfunc (p *ConcreteProduct2) Use() string {\n    return \"Result of ConcreteProduct2\"\n}\n\n// Creator provides the factory method interface.\ntype Creator interface {\n    FactoryMethod() Product\n}\n\n// ConcreteCreator1 implements the Creator interface to create ConcreteProduct1.\ntype ConcreteCreator1 struct{}\n\nfunc (c *ConcreteCreator1) FactoryMethod() Product {\n    return &ConcreteProduct1{}\n}\n\n// ConcreteCreator2 implements the Creator interface to create ConcreteProduct2.\ntype ConcreteCreator2 struct{}\n\nfunc (c *ConcreteCreator2) FactoryMethod() Product {\n    return &ConcreteProduct2{}\n}\n\n// Client code function that demonstrates creation of products.\nfunc clientCode(creator Creator) {\n    product := creator.FactoryMethod()\n    fmt.Println(\"Client: I'm not aware of the creator's class, but it still works.\", product.Use())\n}\n\nfunc main() {\n    fmt.Println(\"App: Launched with the ConcreteCreator1.\")\n    clientCode(&ConcreteCreator1{})\n    fmt.Println(\"\\nApp: Launched with the ConcreteCreator2.\")\n    clientCode(&ConcreteCreator2{})\n}\n"}]},{"title":"Abstract Factory","examples":[{"code":"package main\n\nimport \"fmt\"\n\n// AbstractFactory provides an interface for creating families of related or dependent objects.\ntype AbstractFactory interface {\n    CreateProductA() AbstractProductA\n    CreateProductB() AbstractProductB\n}\n\n// ConcreteFactory1 implements the AbstractFactory interface.\ntype ConcreteFactory1 struct{}\n\nfunc (f *ConcreteFactory1) CreateProductA() AbstractProductA {\n    return &ConcreteProductA1{}\n}\n\nfunc (f *ConcreteFactory1) CreateProductB() AbstractProductB {\n    return &ConcreteProductB1{}\n}\n\n// ConcreteFactory2 implements the AbstractFactory interface.\ntype ConcreteFactory2 struct{}\n\nfunc (f *ConcreteFactory2) CreateProductA() AbstractProductA {\n    return &ConcreteProductA2{}\n}\n\nfunc (f *ConcreteFactory2) CreateProductB() AbstractProductB {\n    return &ConcreteProductB2{}\n}\n\n// AbstractProductA and AbstractProductB declare interfaces for a type of product object.\ntype AbstractProductA interface {\n    UsefulFunctionA() string\n}\n\ntype AbstractProductB interface {\n    UsefulFunctionB() string\n    AnotherUsefulFunctionB(collaborator AbstractProductA) string\n}\n\n// ConcreteProductA1 and ConcreteProductA2 define products to be created by the corresponding factories.\ntype ConcreteProductA1 struct{}\nfunc (p *ConcreteProductA1) UsefulFunctionA() string {\n    return \"The result of the product A1.\"\n}\n\ntype ConcreteProductA2 struct{}\nfunc (p *ConcreteProductA2) UsefulFunctionA() string {\n    return \"The result of the product A2.\"\n}\n\n// ConcreteProductB1 and ConcreteProductB2 define products to be created by the corresponding factories.\ntype ConcreteProductB1 struct{}\nfunc (p *ConcreteProductB1) UsefulFunctionB() string {\n    return \"The result of the product B1.\"\n}\nfunc (p *ConcreteProductB1) AnotherUsefulFunctionB(collaborator AbstractProductA) string {\n    result := collaborator.UsefulFunctionA()\n    return fmt.Sprintf(\"The result of the B1 collaborating with the (%s)\", result)\n}\n\ntype ConcreteProductB2 struct{}\nfunc (p *ConcreteProductB2) UsefulFunctionB() string {\n    return \"The result of the product B2.\"\n}\nfunc (p *ConcreteProductB2) AnotherUsefulFunctionB(collaborator AbstractProductA) string {\n    result := collaborator.UsefulFunctionA()\n    return fmt.Sprintf(\"The result of the B2 collaborating with the (%s)\", result)\n}\n\n// Client code\nfunc clientCode(factory AbstractFactory) {\n    productA := factory.CreateProductA()\n    productB := factory.CreateProductB()\n\n    fmt.Println(productB.UsefulFunctionB())\n    fmt.Println(productB.AnotherUsefulFunctionB(productA))\n}\n\nfunc main() {\n    fmt.Println(\"Client: Testing client code with the first factory type:\")\n    clientCode(&ConcreteFactory1{})\n\n    fmt.Println()\n\n    fmt.Println(\"Client: Testing client code with the second factory type:\")\n    clientCode(&ConcreteFactory2{})\n}\n"}]},{"title":"Builder","examples":[{"code":"package main\n\nimport \"fmt\"\n\n// Builder interface specifies methods for creating the different parts of Product objects.\ntype Builder interface {\n    ProducePartA()\n    ProducePartB()\n    ProducePartC()\n}\n\n// ConcreteBuilder implements the Builder interface.\ntype ConcreteBuilder struct {\n    product *Product\n}\n\nfunc NewConcreteBuilder() *ConcreteBuilder {\n    return &ConcreteBuilder{product: &Product{}}\n}\n\nfunc (b *ConcreteBuilder) ProducePartA() {\n    b.product.Add(\"PartA\")\n}\n\nfunc (b *ConcreteBuilder) ProducePartB() {\n    b.product.Add(\"PartB\")\n}\n\nfunc (b *ConcreteBuilder) ProducePartC() {\n    b.product.Add(\"PartC\")\n}\n\nfunc (b *ConcreteBuilder) GetProduct() *Product {\n    result := b.product\n    b.Reset()\n    return result\n}\n\nfunc (b *ConcreteBuilder) Reset() {\n    b.product = &Product{}\n}\n\n// Product represents the complex object being built.\ntype Product struct {\n    parts []string\n}\n\nfunc (p *Product) Add(part string) {\n    p.parts = append(p.parts, part)\n}\n\nfunc (p *Product) ListParts() {\n    fmt.Printf(\"Product parts: %s\\n\", p.parts)\n}\n\n// Director is responsible for managing the correct sequence of object construction.\ntype Director struct {\n    builder Builder\n}\n\nfunc NewDirector(b Builder) *Director {\n    return &Director{\n        builder: b,\n    }\n}\n\nfunc (d *Director) Construct() {\n    d.builder.ProducePartA()\n    d.builder.ProducePartB()\n    d.builder.ProducePartC()\n}\n\n// Client code\nfunc main() {\n    builder := NewConcreteBuilder()\n    director := NewDirector(builder)\n\n    fmt.Println(\"Standard basic product:\")\n    director.Construct()\n    builder.GetProduct().ListParts()\n\n    fmt.Println(\"Custom product without part C:\")\n    builder.ProducePartA()\n    builder.ProducePartB()\n    builder.GetProduct().ListParts()\n}\n"}]},{"title":"Prototype","examples":[{"code":"package main\n\nimport (\n    \"fmt\"\n)\n\n// Clonable is the prototype interface that declares the cloning method.\ntype Clonable interface {\n    Clone() Clonable\n}\n\n// ConcretePrototype struct represents a concrete prototype that can be cloned.\ntype ConcretePrototype struct {\n    Field1 string\n    Field2 int\n}\n\n// Clone method creates a new ConcretePrototype based on the current instance.\nfunc (p *ConcretePrototype) Clone() Clonable {\n    // Create a shallow copy.\n    // For deep copying complex objects, consider using a library or manually\n    // duplicating nested objects.\n    result := *p\n    return &result\n}\n\nfunc main() {\n    prototype := ConcretePrototype{Field1: \"Value1\", Field2: 42}\n    clone := prototype.Clone().(*ConcretePrototype)\n\n    fmt.Println(\"Original object:\", prototype)\n    fmt.Println(\"Cloned object:  \", clone)\n\n    // Modify clone to show that it is independent of the original.\n    clone.Field1 = \"Modified Value\"\n    fmt.Println(\"\\nAfter modification:\")\n    fmt.Println(\"Original object:\", prototype)\n    fmt.Println(\"Cloned object:  \", clone)\n}\n"}]},{"title":"Singleton","examples":[{"code":"package main\n\nimport (\n    \"fmt\"\n    \"sync\"\n)\n\n// Singleton represents the singleton class.\ntype Singleton struct{}\n\nvar (\n    instance *Singleton\n    once     sync.Once\n)\n\n// GetInstance uses sync.Once to ensure that only one instance is created,\n// even in the presence of concurrent access.\nfunc GetInstance() *Singleton {\n    once.Do(func() {\n        instance = &Singleton{}\n    })\n    return instance\n}\n\n// SomeBusinessLogic is a placeholder for some functionalities of the singleton.\nfunc (s *Singleton) SomeBusinessLogic() {}\n\n// Client code demonstrating the use of the Singleton.\nfunc main() {\n    s1 := GetInstance()\n    s2 := GetInstance()\n\n    fmt.Println(\"Are s1 and s2 the same instance?\", s1 == s2)\n}\n"}]}],"patterns_structural":[{"title":"Adapter","examples":[{"code":"package main\n\nimport \"fmt\"\n\ntype Target interface {\n    Request() string\n}\n\ntype Adaptee struct {}\n\nfunc (a *Adaptee) SpecificRequest() string {\n    return \"Specific request.\"\n}\n\ntype Adapter struct {\n    adaptee *Adaptee\n}\n\nfunc NewAdapter(adaptee *Adaptee) *Adapter {\n    return &Adapter{adaptee: adaptee}\n}\n\nfunc (a *Adapter) Request() string {\n    return \"Adapter: \" + a.adaptee.SpecificRequest()\n}\n\nfunc main() {\n    adaptee := &Adaptee{}\n    adapter := NewAdapter(adaptee)\n    fmt.Println(adapter.Request())\n}\n"}]},{"title":"Bridge","examples":[{"code":"package main\n\nimport \"fmt\"\n\ntype Implementor interface {\n    OperationImpl() string\n}\n\ntype Abstraction struct {\n    implementor Implementor\n}\n\nfunc (a *Abstraction) Operation() string {\n    return \"Abstraction: \" + a.implementor.OperationImpl()\n}\n\ntype ConcreteImplementorA struct {}\nfunc (c *ConcreteImplementorA) OperationImpl() string {\n    return \"ConcreteImplementorA Operation\"\n}\n\ntype ConcreteImplementorB struct {}\nfunc (c *ConcreteImplementorB) OperationImpl() string {\n    return \"ConcreteImplementorB Operation\"\n}\n\nfunc main() {\n    var implementor Implementor = &ConcreteImplementorA{}\n    abstraction := &Abstraction{implementor: implementor}\n    fmt.Println(abstraction.Operation())\n\n    implementor = &ConcreteImplementorB{}\n    abstraction = &Abstraction{implementor: implementor}\n    fmt.Println(abstraction.Operation())\n}\n"}]},{"title":"Composite","examples":[{"code":"package main\n\nimport \"fmt\"\n\ntype Component interface {\n    Operation() string\n}\n\ntype Leaf struct {\n    name string\n}\n\nfunc (l *Leaf) Operation() string {\n    return l.name\n}\n\ntype Composite struct {\n    children []Component\n}\n\nfunc (c *Composite) Add(child Component) {\n    c.children = append(c.children, child)\n}\n\nfunc (c *Composite) Operation() string {\n    result := \"Branch(\"\n    for _, child := range c.children {\n        result += child.Operation() + \" \"\n    }\n    result += \")\"\n    return result\n}\n\nfunc main() {\n    leaf1 := &Leaf{\"Leaf1\"}\n    leaf2 := &Leaf{\"Leaf2\"}\n    composite := &Composite{}\n    composite.Add(leaf1)\n    composite.Add(leaf2)\n    fmt.Println(composite.Operation())\n}\n"}]},{"title":"Decorator","examples":[{"code":"package main\n\nimport \"fmt\"\n\ntype Component interface {\n    Operation() string\n}\n\ntype ConcreteComponent struct {}\n\nfunc (c *ConcreteComponent) Operation() string {\n    return \"ConcreteComponent\"\n}\n\ntype Decorator struct {\n    component Component\n}\n\nfunc NewDecorator(component Component) *Decorator {\n    return &Decorator{component: component}\n}\n\nfunc (d *Decorator) Operation() string {\n    return \"Decorator(\" + d.component.Operation() + \")\"\n}\n\nfunc main() {\n    component := &ConcreteComponent{}\n    decorator := NewDecorator(component)\n    fmt.Println(decorator.Operation())\n}\n"}]},{"title":"Facade","examples":[{"code":"package main\n\nimport \"fmt\"\n\ntype SubsystemOne struct {}\nfunc (s *SubsystemOne) OperationOne() string {\n    return \"SubsystemOne: Operation\"\n}\n\ntype SubsystemTwo struct {}\nfunc (s *SubsystemTwo) OperationTwo() string {\n    return \"SubsystemTwo: Operation\"\n}\n\ntype Facade struct {\n    one *SubsystemOne\n    two *SubsystemTwo\n}\n\nfunc NewFacade() *Facade {\n    return &Facade{\n        one: &SubsystemOne{},\n        two: &SubsystemTwo{},\n    }\n}\n\nfunc (f *Facade) Operation() string {\n    result := \"Facade initializes subsystems:\\n\"\n    result += f.one.OperationOne() + \"\\n\"\n    result += f.two.OperationTwo()\n    return result\n}\n\nfunc main() {\n    facade := NewFacade()\n    fmt.Println(facade.Operation())\n}\n"}]},{"title":"Flyweight","examples":[{"code":"package main\n\nimport \"fmt\"\n\ntype Flyweight struct {\n    sharedState string\n}\n\nfunc (f *Flyweight) Operation(uniqueState string) {\n    fmt.Printf(\"Flyweight with sharedState %s and uniqueState %s.\\n\", f.sharedState, uniqueState)\n}\n\ntype FlyweightFactory struct {\n    flyweights map[string]*Flyweight\n}\n\nfunc NewFlyweightFactory(initialStates []string) *FlyweightFactory {\n    factory := &FlyweightFactory{flyweights: make(map[string]*Flyweight)}\n    for _, state := range initialStates {\n        factory.flyweights[state] = &Flyweight{sharedState: state}\n    }\n    return factory\n}\n\nfunc (f *FlyweightFactory) GetFlyweight(sharedState string) *Flyweight {\n    if _, ok := f.flyweights[sharedState]; !ok {\n        fmt.Println(\"FlyweightFactory: Can't find a flyweight, creating new one.\")\n        f.flyweights[sharedState] = &Flyweight{sharedState: sharedState}\n    }\n    return f.flyweights[sharedState]\n}\n\nfunc main() {\n    factory := NewFlyweightFactory([]string{\"state1\", \"state2\"})\n    flyweight := factory.GetFlyweight(\"state1\")\n    flyweight.Operation(\"uniqueState1\")\n}\n"}]},{"title":"Proxy","examples":[{"code":"package main\n\nimport \"fmt\"\n\ntype Subject interface {\n    Request() string\n}\n\ntype RealSubject struct {}\n\nfunc (r *RealSubject) Request() string {\n    return \"RealSubject: Handling request.\"\n}\n\ntype Proxy struct {\n    realSubject *RealSubject\n}\n\nfunc NewProxy(realSubject *RealSubject) *Proxy {\n    return &Proxy{realSubject: realSubject}\n}\n\nfunc (p *Proxy) Request() string {\n    if p.checkAccess() {\n        result := p.realSubject.Request()\n        p.logAccess()\n        return \"Proxy: Call to \" + result\n    }\n    return \"Proxy: Access denied\"\n}\n\nfunc (p *Proxy) checkAccess() bool {\n    // Suppose there are some real checks here\n    fmt.Println(\"Proxy: Checking access prior to firing a real request.\")\n    return true\n}\n\nfunc (p *Proxy) logAccess() {\n    fmt.Println(\"Proxy: Logging the time of request.\")\n}\n\nfunc main() {\n    realSubject := &RealSubject{}\n    proxy := NewProxy(realSubject)\n    fmt.Println(proxy.Request())\n}\n"}]}]},"principles":{"principles_solid":[{"title":"Single Responsibility","examples":[{"title":"Good Example","code":"package main\n\ntype UserDataManager struct{}\n\nfunc (udm *UserDataManager) SaveUserData() {\n    // save user data\n}\n\ntype UserNotification struct{}\n\nfunc (un *UserNotification) SendNotification() {\n    // send notification\n}\n"},{"title":"Bad Example","code":"package main\n\ntype User struct{}\n\nfunc (u *User) SaveUserData() {\n    // save user data\n}\n\nfunc (u *User) SendNotification() {\n    // send notification\n}\n"}]},{"title":"Open-Closed","examples":[{"title":"Good Example","code":"package main\n\ntype Shape interface {\n    ComputeArea() float64\n}\n\ntype Rectangle struct {\n    Width, Height float64\n}\n\nfunc (r Rectangle) ComputeArea() float64 {\n    return r.Width * r.Height\n}\n\ntype Circle struct {\n    Radius float64\n}\n\nfunc (c Circle) ComputeArea() float64 {\n    return 3.14 * c.Radius * c.Radius\n}\n"},{"title":"Bad Example","code":"package main\n\ntype AreaCalculator struct{}\n\nfunc (ac *AreaCalculator) ComputeArea(shape interface{}) float64 {\n    // type assertion to determine shape and compute area\n    // violates open-closed principle\n}\n"}]},{"title":"Liskov Substitution","examples":[{"title":"Good Example","code":"package main\n\ntype Bird interface {\n    Fly()\n}\n\ntype Sparrow struct{}\n\nfunc (s *Sparrow) Fly() {\n    // implementation for sparrow flying\n}\n\ntype Ostrich struct{}\n\nfunc (o *Ostrich) Walk() {\n    // ostrich can't fly, so we don't implement Fly()\n}\n"},{"title":"Bad Example","code":"package main\n\ntype Bird struct{}\n\nfunc (b *Bird) Fly() {\n    // assumed all birds can fly\n}\n\n// Ostrich inherits from Bird but can't fly, violating LSP\n"}]},{"title":"Interface Segregation","examples":[{"title":"Good Example","code":"package main\n\ntype Worker interface {\n    Work()\n}\n\ntype Eater interface {\n    Eat()\n}\n\ntype Human struct{}\n\nfunc (h Human) Work() {\n    // human working\n}\n\nfunc (h Human) Eat() {\n    // human eating\n}\n\ntype Robot struct{}\n\nfunc (r Robot) Work() {\n    // robot working\n}\n\n// Robot does not implement Eater, adhering to ISP\n"},{"title":"Bad Example","code":"package main\n\ntype Worker struct{}\n\nfunc (w *Worker) Work() {\n    // work implementation\n}\n\nfunc (w *Worker) Eat() {\n    // not all workers eat, violating ISP\n"}]},{"title":"Dependency Inversion","examples":[{"title":"Good Example","code":"package main\n\ntype Switchable interface {\n    TurnOn()\n}\n\ntype Switch struct {\n    Device Switchable\n}\n\nfunc (s *Switch) Operate() {\n    s.Device.TurnOn()\n}\n\ntype LightBulb struct{}\n\nfunc (lb *LightBulb) TurnOn() {\n    // light bulb turning on\n}\n"},{"title":"Bad Example","code":"package main\n\ntype LightBulb struct{}\n\nfunc (lb *LightBulb) TurnOn() {\n    // light bulb turning on\n}\n\ntype Switch struct {\n    Bulb LightBulb\n}\n\nfunc (s *Switch) Operate() {\n    s.Bulb.TurnOn()\n}\n"}]}],"principles_other":[{"title":"Don't Repeat Yourself (DRY)","examples":[{"title":"Good Example","code":"// Good example: Using a function to avoid duplicated logic\nfunc addTax(price, rate float64) float64 {\n    if rate == 0 {\n        rate = 0.05\n    }\n    return price + (price * rate)\n}\n"},{"title":"Bad Example","code":"// Bad example: Repeated logic in separate functions\nfunc addTaxForFood(price float64) float64 {\n    return price + (price * 0.05)\n}\n\nfunc addTaxForElectronics(price float64) float64 {\n    return price + (price * 0.05)\n}\n"}]},{"title":"Keep It Simple Stupid (KISS)","examples":[{"title":"Good Example","code":"// Good example: Simplified approach\nfunc isEven(num int) bool {\n    return num%2 == 0\n}\n"},{"title":"Bad Example","code":"// Bad example: Overcomplicated way to check even numbers\nfunc isEven(num int) bool {\n    return num % int(math.Abs(2)) == 0\n}\n"}]},{"title":"You Aren't Gonna Need It (YAGNI)","examples":[{"title":"Good Example","code":"// Good example: Implementing only the needed functionality\ntype Car struct{}\n\nfunc (c Car) Drive() {\n    // Driving logic\n}\n"},{"title":"Bad Example","code":"// Bad example: Adding unnecessary features\ntype Car struct{}\n\nfunc (c Car) Drive() {\n    // Driving logic\n}\n\nfunc (c Car) Fly() {\n    // Flying logic - Cars don't fly!\n}\n"}]},{"title":"Law of Demeter (Principle of Least Knowledge)","examples":[{"title":"Good Example","code":"// Good example: Using methods for encapsulation\ntype Wallet struct {\n    money int\n}\n\nfunc (w *Wallet) GetAmount() int {\n    return w.money\n}\n\ntype Person struct {\n    wallet Wallet\n}\n\nfunc (p *Person) GetMoneyAmount() int {\n    return p.wallet.GetAmount()\n}\n\nfunc purchase(itemPrice int, buyer *Person) {\n    if buyer.GetMoneyAmount() >= itemPrice {\n        // Purchase logic\n    }\n}\n"},{"title":"Bad Example","code":"// Bad example: Accessing nested structures directly\ntype Wallet struct {\n    Money int\n}\n\ntype Person struct {\n    Wallet Wallet\n}\n\nfunc purchase(itemPrice int, buyer *Person) {\n    if buyer.Wallet.Money >= itemPrice {\n        // Purchase logic\n    }\n}\n"}]},{"title":"Separation of Concerns","examples":[{"title":"Good Example","code":"// Good example: Separating concerns into different types and functions\ntype UserDataService struct{}\n\nfunc (uds *UserDataService) FetchUserData() {\n    // Fetch user data\n}\n\ntype UserLogic struct{}\n\nfunc (ul *UserLogic) CalculateAge() {\n    // Calculate age\n}\n\ntype UserComponent struct{}\n\nfunc (uc *UserComponent) Render() {\n    // Render logic\n}\n"},{"title":"Bad Example","code":"// Bad example: Mixing concerns in one type\ntype UserComponent struct{}\n\nfunc (uc *UserComponent) FetchUserData() {\n    // Fetch data\n}\n\nfunc (uc *UserComponent) Render() {\n    // Render logic\n}\n\nfunc (uc *UserComponent) CalculateAge() {\n    // Calculate age\n}\n"}]}],"principles_proprietary":[{"title":"Static Typing","description":[{"variant":"subtitle1","content":"Go is a statically typed language, meaning variables are explicitly typed, and their types are checked at compile time. This helps catch type-related errors early in the development process.\n"}],"examples":[{"title":"Static Typing Example","code":"var data int = 42 // data is explicitly typed as an integer\n// data = 'hello' // This would result in a compile-time error\n"}]},{"title":"Structs Instead of Classes","description":[{"variant":"subtitle1","content":"Go uses structs instead of classes for structuring code. Methods can be associated with structs to provide behavior.\n"}],"examples":[{"title":"Structs and Methods Example","code":"type Person struct {\n    FirstName string\n}\n\nfunc (p Person) SayHello() string {\n    return \"Hello, I'm \" + p.FirstName\n}\n\nvar john = Person{\"John\"}\nfmt.Println(john.SayHello()) // \"Hello, I'm John\"\n"}]},{"title":"Interfaces for Polymorphism","description":[{"variant":"subtitle1","content":"Go uses interfaces to achieve polymorphism. An interface type is defined by a set of method signatures, and any type that implements those methods satisfies the interface.\n"}],"examples":[{"title":"Interfaces Example","code":"type Greeter interface {\n    Greet() string\n}\n\ntype EnglishSpeaker struct{}\n\nfunc (EnglishSpeaker) Greet() string {\n    return \"Hello!\"\n}\n\ntype SpanishSpeaker struct{}\n\nfunc (SpanishSpeaker) Greet() string {\n    return \"¡Hola!\"\n}\n"}]},{"title":"Concurrency with Goroutines and Channels","description":[{"variant":"subtitle1","content":"Go provides built-in support for concurrency with goroutines and channels. Goroutines are functions that can run concurrently, and channels are used for communication between them.\n"}],"examples":[{"title":"Concurrency Example","code":"func say(s string) {\n    for i := 0; i < 5; i++ {\n        fmt.Println(s)\n    }\n}\n\nfunc main() {\n    go say(\"world\")\n    say(\"hello\")\n}\n"}]},{"title":"Error Handling","description":[{"variant":"subtitle1","content":"Go handles errors explicitly using error values, rather than exceptions. Functions often return an error value, and calling code checks this error before proceeding.\n"}],"examples":[{"title":"Error Handling Example","code":"func divide(a, b float64) (float64, error) {\n    if b == 0.0 {\n        return 0.0, errors.New(\"division by zero\")\n    }\n    return a / b, nil\n}\n"}]},{"title":"Package System","description":[{"variant":"subtitle1","content":"Go's package system organizes code into reusable components. Each package serves as a namespace for its identifiers and can be imported by other packages.\n"}],"examples":[{"title":"Package Example","code":"package main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc main() {\n    fmt.Println(math.Sqrt(16))\n}\n"}]},{"title":"Composition over Inheritance","description":[{"variant":"subtitle1","content":"Go favors composition over inheritance, allowing types to be composed using smaller pieces of functionality.\n"}],"examples":[{"title":"Composition Example","code":"type Engine interface {\n    Start()\n    Stop()\n}\n\ntype Car struct {\n    Engine\n}\n"}]},{"title":"Type Assertions and Type Switches","description":[{"variant":"subtitle1","content":"Go allows for type assertions and type switches to handle dynamic types safely at runtime, particularly when working with interfaces.\n"}],"examples":[{"title":"Type Assertion Example","code":"var i interface{} = \"hello\"\ns := i.(string)\nfmt.Println(s)\n"}]},{"title":"Deferred Function Calls","description":[{"variant":"subtitle1","content":"Go allows functions to be deferred until the surrounding function completes. This is often used for cleanup activities.\n"}],"examples":[{"title":"Deferred Calls Example","code":"func main() {\n    defer fmt.Println(\"world\")\n    fmt.Println(\"hello\")\n}\n"}]},{"title":"Go Routines and Select Statement","description":[{"variant":"subtitle1","content":"Go's select statement lets a goroutine wait on multiple communication operations, facilitating complex concurrency patterns.\n"}],"examples":[{"title":"Select Statement Example","code":"select {\ncase msg1 := <-channel1:\n    fmt.Println(\"Received\", msg1)\ncase msg2 := <-channel2:\n    fmt.Println(\"Received\", msg2)\n}\n"}]}]}}