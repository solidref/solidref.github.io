{"name":"TypeScript","code":"typescript","birth":2012,"death":"N/A","inspiredBy":["javascript","c#","java","php","python","ruby","scala"],"inspiring":["javascript"],"description":"TypeScript is a superset of JavaScript that adds static typing and other features to the language.\nIt was developed by Microsoft and is widely used for building large-scale applications,\nparticularly in the realm of web development. TypeScript compiles to plain JavaScript and can be\nused in both front-end and back-end development. It offers features like static typing,\ninterfaces, generics, and advanced tooling support through tools like Visual Studio Code.\nTypeScript provides developers with increased type safety and helps catch errors at compile time,\nleading to more robust and maintainable codebases.\n","patterns":{"patterns_behavioural":[{"title":"Chain Of Responsibility","examples":[{"code":"abstract class Handler {\n    protected nextHandler: Handler | null = null;\n\n    constructor(nextHandler: Handler | null = null) {\n        this.nextHandler = nextHandler;\n    }\n\n    handle(request: string): string | null {\n        if (this.nextHandler) {\n            return this.nextHandler.handle(request);\n        }\n\n        return null;\n    }\n}\n\n// Concrete Handlers\nclass ConcreteHandler1 extends Handler {\n    handle(request: string): string | null {\n        if (request === 'handle1') {\n            return 'Handled by ConcreteHandler1';\n        }\n        return super.handle(request);\n    }\n}\n\nclass ConcreteHandler2 extends Handler {\n    handle(request: string): string | null {\n        if (request === 'handle2') {\n            return 'Handled by ConcreteHandler2';\n        }\n        return super.handle(request);\n    }\n}\n\n// Client code\nconst handler1 = new ConcreteHandler1();\nconst handler2 = new ConcreteHandler2(handler1);\n\nconsole.log(handler2.handle('handle2'));\nconsole.log(handler2.handle('handle1'));\n"}]},{"title":"Command","examples":[{"code":"interface Command {\n    execute(): void;\n}\n\nclass Light {\n    turnOn() {\n        console.log('Light turned on');\n    }\n\n    turnOff() {\n        console.log('Light turned off');\n    }\n}\n\nclass TurnOnCommand implements Command {\n    private light: Light;\n\n    constructor(light: Light) {\n        this.light = light;\n    }\n\n    execute() {\n        this.light.turnOn();\n    }\n}\n\nclass TurnOffCommand implements Command {\n    private light: Light;\n\n    constructor(light: Light) {\n        this.light = light;\n    }\n\n    execute() {\n        this.light.turnOff();\n    }\n}\n\n// Invoker\nclass RemoteControl {\n    submit(command: Command) {\n        command.execute();\n    }\n}\n\n// Client code\nconst light = new Light();\nconst turnOnCommand = new TurnOnCommand(light);\nconst turnOffCommand = new TurnOffCommand(light);\nconst remote = new RemoteControl();\n\nremote.submit(turnOnCommand);\nremote.submit(turnOffCommand);\n"}]},{"title":"Iterator","examples":[{"code":"class Iterator<T> {\n    private collection: T[];\n    private index: number;\n\n    constructor(collection: T[]) {\n        this.collection = collection;\n        this.index = 0;\n    }\n\n    next(): T | undefined {\n        return this.collection[this.index++];\n    }\n\n    hasNext(): boolean {\n        return this.index < this.collection.length;\n    }\n}\n\n// Client code\nconst items = [1, 'two', 3, 'four', 5];\nconst iterator = new Iterator(items);\n\nwhile (iterator.hasNext()) {\n    console.log(iterator.next());\n}\n"}]},{"title":"Mediator","examples":[{"code":"interface Mediator {\n    send(message: string, colleague: Colleague): void;\n}\n\nabstract class Colleague {\n    protected mediator: Mediator | null = null;\n\n    setMediator(mediator: Mediator) {\n        this.mediator = mediator;\n    }\n\n    send(message: string) {\n        if (this.mediator) {\n            this.mediator.send(message, this);\n        }\n    }\n\n    abstract receive(message: string): void;\n}\n\n// Concrete Colleagues\nclass ConcreteColleague1 extends Colleague {\n    receive(message: string) {\n        console.log(`${this.constructor.name} received message: ${message}`);\n    }\n}\n\nclass ConcreteColleague2 extends Colleague {\n    receive(message: string) {\n        console.log(`${this.constructor.name} received message: ${message}`);\n    }\n}\n\n// Concrete Mediator\nclass ConcreteMediator implements Mediator {\n    private colleagues: Colleague[] = [];\n\n    register(colleague: Colleague) {\n        this.colleagues.push(colleague);\n        colleague.setMediator(this);\n    }\n\n    send(message: string, sender: Colleague) {\n        this.colleagues.forEach(colleague => {\n            if (colleague !== sender) {\n                colleague.receive(message);\n            }\n        });\n    }\n}\n\n// Client code\nconst mediator = new ConcreteMediator();\nconst colleague1 = new ConcreteColleague1();\nconst colleague2 = new ConcreteColleague2();\n\nmediator.register(colleague1);\nmediator.register(colleague2);\n\ncolleague1.send('Hello from Colleague 1');\ncolleague2.send('Hello from Colleague 2');\n"}]},{"title":"Memento","examples":[{"code":"class Memento {\n    private state: string;\n\n    constructor(state: string) {\n        this.state = state;\n    }\n\n    getState(): string {\n        return this.state;\n    }\n}\n\nclass Originator {\n    private state: string = '';\n\n    setState(state: string) {\n        this.state = state;\n    }\n\n    getState(): string {\n        return this.state;\n    }\n\n    save(): Memento {\n        return new Memento(this.state);\n    }\n\n    restore(memento: Memento) {\n        this.state = memento.getState();\n    }\n}\n\nclass Caretaker {\n    private mementos: Memento[] = [];\n\n    addMemento(memento: Memento) {\n        this.mementos.push(memento);\n    }\n\n    getMemento(index: number): Memento | undefined {\n        return this.mementos[index];\n    }\n}\n\n// Client code\nconst originator = new Originator();\nconst caretaker = new Caretaker();\n\noriginator.setState('State #1');\ncaretaker.addMemento(originator.save());\n\noriginator.setState('State #2');\ncaretaker.addMemento(originator.save());\n\noriginator.restore(caretaker.getMemento(0)!);\nconsole.log(originator.getState());\n"}]},{"title":"Observer","examples":[{"code":"interface Subject {\n    subscribe(observer: Observer): void;\n    unsubscribe(observer: Observer): void;\n    notify(data: any): void;\n}\n\nclass ConcreteSubject implements Subject {\n    private observers: Observer[] = [];\n\n    subscribe(observer: Observer) {\n        this.observers.push(observer);\n    }\n\n    unsubscribe(observer: Observer) {\n        const index = this.observers.indexOf(observer);\n        if (index > -1) {\n            this.observers.splice(index, 1);\n        }\n    }\n\n    notify(data: any) {\n        this.observers.forEach(observer => observer.update(data));\n    }\n}\n\ninterface Observer {\n    update(data: any): void;\n}\n\nclass ConcreteObserver implements Observer {\n    update(data: any) {\n        console.log(`Observer received data: ${data}`);\n    }\n}\n\n// Client code\nconst subject = new ConcreteSubject();\nconst observer1 = new ConcreteObserver();\nconst observer2 = new ConcreteObserver();\n\nsubject.subscribe(observer1);\nsubject.subscribe(observer2);\n\nsubject.notify('Hello Observers!');\n\nsubject.unsubscribe(observer2);\nsubject.notify('Goodbye Observers!');\n"}]},{"title":"State","examples":[{"code":"interface State {\n    handle1(): void;\n    handle2(): void;\n}\n\nclass Context {\n    private state: State;\n\n    constructor(state: State) {\n        this.transitionTo(state);\n    }\n\n    transitionTo(state: State) {\n        console.log(`Context: Transition to ${state.constructor.name}.`);\n        this.state = state;\n    }\n\n    request1() {\n        this.state.handle1();\n    }\n\n    request2() {\n        this.state.handle2();\n    }\n}\n\nclass ConcreteStateA implements State {\n    handle1() {\n        console.log('ConcreteStateA handles request1.');\n        console.log('ConcreteStateA wants to change the state of the context.');\n    }\n\n    handle2() {\n        console.log('ConcreteStateA handles request2.');\n    }\n}\n\nclass ConcreteStateB implements State {\n    handle1() {\n        console.log('ConcreteStateB handles request1.');\n    }\n\n    handle2() {\n        console.log('ConcreteStateB handles request2.');\n        console.log('ConcreteStateB wants to change the state of the context.');\n    }\n}\n\n// Client code\nconst context = new Context(new ConcreteStateA());\ncontext.request1();\ncontext.request2();\n"}]},{"title":"Strategy","examples":[{"code":"interface Strategy {\n    execute(data: any): string;\n}\n\nclass ConcreteStrategyA implements Strategy {\n    execute(data: any): string {\n        return `Strategy A with data ${data}`;\n    }\n}\n\nclass ConcreteStrategyB implements Strategy {\n    execute(data: any): string {\n        return `Strategy B with data ${data}`;\n    }\n}\n\nclass Context {\n    private strategy: Strategy;\n\n    constructor(strategy: Strategy) {\n        this.strategy = strategy;\n    }\n\n    setStrategy(strategy: Strategy) {\n        this.strategy = strategy;\n    }\n\n    executeStrategy(data: any): string {\n        return this.strategy.execute(data);\n    }\n}\n\n// Client code\nconst context = new Context(new ConcreteStrategyA());\nconsole.log(context.executeStrategy('123'));\n\ncontext.setStrategy(new ConcreteStrategyB());\nconsole.log(context.executeStrategy('456'));\n"}]},{"title":"TemplateMethod","examples":[{"code":"abstract class AbstractClass {\n    templateMethod() {\n        this.baseOperation1();\n        this.requiredOperation1();\n        this.baseOperation2();\n        this.hook1();\n        this.requiredOperation2();\n        this.baseOperation3();\n        this.hook2();\n    }\n\n    baseOperation1() {\n        console.log(\"AbstractClass says: I am doing the bulk of the work\");\n    }\n\n    baseOperation2() {\n        console.log(\"AbstractClass says: But I let subclasses override some operations\");\n    }\n\n    baseOperation3() {\n        console.log(\"AbstractClass says: But I am doing the bulk of the work anyway\");\n    }\n\n    abstract requiredOperation1(): void;\n    abstract requiredOperation2(): void;\n\n    hook1() {}\n    hook2() {}\n}\n\nclass ConcreteClass1 extends AbstractClass {\n    requiredOperation1() {\n        console.log(\"ConcreteClass1 says: Implemented Operation1\");\n    }\n\n    requiredOperation2() {\n        console.log(\"ConcreteClass1 says: Implemented Operation2\");\n    }\n}\n\nclass ConcreteClass2 extends AbstractClass {\n    requiredOperation1() {\n        console.log(\"ConcreteClass2 says: Implemented Operation1\");\n    }\n\n    requiredOperation2() {\n        console.log(\"ConcreteClass2 says: Implemented Operation2\");\n    }\n\n    hook1() {\n        console.log(\"ConcreteClass2 says: Overridden Hook1\");\n    }\n}\n\n// Client code\nconsole.log('Same client code can work with different subclasses:');\nnew ConcreteClass1().templateMethod();\nconsole.log('');\nnew ConcreteClass2().templateMethod();\n"}]},{"title":"Visitor","examples":[{"code":"interface Visitor {\n    visitConcreteComponentA(element: ConcreteComponentA): void;\n    visitConcreteComponentB(element: ConcreteComponentB): void;\n}\n\nclass ConcreteVisitor1 implements Visitor {\n    visitConcreteComponentA(element: ConcreteComponentA) {\n        console.log(`${element.exclusiveMethodOfConcreteComponentA()} + ConcreteVisitor1`);\n    }\n\n    visitConcreteComponentB(element: ConcreteComponentB) {\n        console.log(`${element.specialMethodOfConcreteComponentB()} + ConcreteVisitor1`);\n    }\n}\n\nclass Component {\n    accept(visitor: Visitor) {\n        visitor.visit(this);\n    }\n}\n\nclass ConcreteComponentA extends Component {\n    exclusiveMethodOfConcreteComponentA() {\n        return 'A';\n    }\n}\n\nclass ConcreteComponentB extends Component {\n    specialMethodOfConcreteComponentB() {\n        return 'B';\n    }\n}\n\n// Client code\nconst components = [\n    new ConcreteComponentA(),\n    new ConcreteComponentB(),\n];\n\nconst visitor1 = new ConcreteVisitor1();\n\ncomponents.forEach((c) => c.accept(visitor1));\n"}]}],"patterns_creational":[{"title":"Factory Method","examples":[{"code":"abstract class Creator {\n    abstract factoryMethod(): Product;\n\n    someOperation() {\n        const product = this.factoryMethod();\n        return `Creator: The same creator's code has just worked with ${product.operation()}`;\n    }\n}\n\nclass ConcreteCreator1 extends Creator {\n    factoryMethod(): Product {\n        return new ConcreteProduct1();\n    }\n}\n\nclass ConcreteCreator2 extends Creator {\n    factoryMethod(): Product {\n        return new ConcreteProduct2();\n    }\n}\n\ninterface Product {\n    operation(): string;\n}\n\nclass ConcreteProduct1 implements Product {\n    operation(): string {\n        return '{Result of the ConcreteProduct1}';\n    }\n}\n\nclass ConcreteProduct2 implements Product {\n    operation(): string {\n        return '{Result of the ConcreteProduct2}';\n    }\n}\n\n// Client code\nfunction clientCode(creator: Creator) {\n    console.log(\"Client: I'm not aware of the creator's class, but it still works.\");\n    console.log(creator.someOperation());\n}\n\nconsole.log('App: Launched with the ConcreteCreator1.');\nclientCode(new ConcreteCreator1());\nconsole.log('');\n\nconsole.log('App: Launched with the ConcreteCreator2.');\nclientCode(new ConcreteCreator2());\n"}]},{"title":"Abstract Factory","examples":[{"code":"interface AbstractFactory {\n    createProductA(): AbstractProductA;\n    createProductB(): AbstractProductB;\n}\n\nclass ConcreteFactory1 implements AbstractFactory {\n    createProductA(): AbstractProductA {\n        return new ConcreteProductA1();\n    }\n\n    createProductB(): AbstractProductB {\n        return new ConcreteProductB1();\n    }\n}\n\nclass ConcreteFactory2 implements AbstractFactory {\n    createProductA(): AbstractProductA {\n        return new ConcreteProductA2();\n    }\n\n    createProductB(): AbstractProductB {\n        return new ConcreteProductB2();\n    }\n}\n\ninterface AbstractProductA {\n    usefulFunctionA(): string;\n}\n\nclass ConcreteProductA1 implements AbstractProductA {\n    usefulFunctionA(): string {\n        return 'The result of the product A1.';\n    }\n}\n\nclass ConcreteProductA2 implements AbstractProductA {\n    usefulFunctionA(): string {\n        return 'The result of the product A2.';\n    }\n}\n\ninterface AbstractProductB {\n    usefulFunctionB(): string;\n    anotherUsefulFunctionB(collaborator: AbstractProductA): string;\n}\n\nclass ConcreteProductB1 implements AbstractProductB {\n    usefulFunctionB(): string {\n        return 'The result of the product B1.';\n    }\n\n    anotherUsefulFunctionB(collaborator: AbstractProductA): string {\n        const result = collaborator.usefulFunctionA();\n        return `The result of the B1 collaborating with the (${result})`;\n    }\n}\n\nclass ConcreteProductB2 implements AbstractProductB {\n    usefulFunctionB(): string {\n        return 'The result of the product B2.';\n    }\n\n    anotherUsefulFunctionB(collaborator: AbstractProductA): string {\n        const result = collaborator.usefulFunctionA();\n        return `The result of the B2 collaborating with the (${result})`;\n    }\n}\n\n// Client code\nfunction clientCode(factory: AbstractFactory) {\n    const productA = factory.createProductA();\n    const productB = factory.createProductB();\n\n    console.log(productB.usefulFunctionB());\n    console.log(productB.anotherUsefulFunctionB(productA));\n}\n\nclientCode(new ConcreteFactory1());\nclientCode(new ConcreteFactory2());\n"}]},{"title":"Builder","examples":[{"code":"class Director {\n    private builder: Builder;\n\n    constructor(builder: Builder) {\n        this.builder = builder;\n    }\n\n    construct() {\n        this.builder.buildPartA();\n        this.builder.buildPartB();\n        this.builder.buildPartC();\n    }\n}\n\ninterface Builder {\n    buildPartA(): void;\n    buildPartB(): void;\n    buildPartC(): void;\n}\n\nclass ConcreteBuilder implements Builder {\n    private product: Product;\n\n    constructor() {\n        this.product = new Product();\n    }\n\n    buildPartA() {\n        this.product.parts.push('PartA');\n    }\n\n    buildPartB() {\n        this.product.parts.push('PartB');\n    }\n\n    buildPartC() {\n        this.product.parts.push('PartC');\n    }\n\n    getResult() {\n        return this.product;\n    }\n}\n\nclass Product {\n    parts: string[];\n\n    constructor() {\n        this.parts = [];\n    }\n}\n\n// Client code\nconst builder = new ConcreteBuilder();\nconst director = new Director(builder);\n\ndirector.construct();\nconst product = builder.getResult();\nconsole.log(product.parts);\n"}]},{"title":"Prototype","examples":[{"code":"class Prototype {\n    primitive: number;\n    component: Date;\n    circularReference: { prototype: Prototype };\n\n    clone(): this {\n        const clone = Object.create(this);\n        clone.component = Object.create(this.component);\n\n        // Clone each property if needed (deep copy)\n        clone.circularReference = {\n            ...this.circularReference,\n            prototype: { ...this },\n        };\n\n        return clone;\n    }\n}\n\nclass ConcretePrototype1 extends Prototype {\n    constructor() {\n        super();\n        this.primitive = 245;\n        this.component = new Date();\n        this.circularReference = {\n            prototype: this,\n        };\n    }\n}\n\n// Client code\nconst p1 = new ConcretePrototype1();\nconst p2 = p1.clone();\n\nconsole.log('p1:', p1);\nconsole.log('p2:', p2);\nconsole.log('Same component?', p1.component === p2.component); // false, deep copy\n"}]},{"title":"Singleton","examples":[{"code":"class Singleton {\n    private static instance: Singleton;\n\n    private constructor() {}\n\n    static getInstance(): Singleton {\n        if (!this.instance) {\n            this.instance = new Singleton();\n        }\n        return this.instance;\n    }\n\n    // Some business logic\n    someBusinessLogic() {}\n}\n\n// Client code\nconst instance1 = Singleton.getInstance();\nconst instance2 = Singleton.getInstance();\n\nconsole.log('Same instance?', instance1 === instance2); // true\n"}]}],"patterns_structural":[{"title":"Adapter","examples":[{"code":"class Target {\n    request(): string {\n        return 'Target: The default target\\'s behavior.';\n    }\n}\n\nclass Adaptee {\n    specificRequest(): string {\n        return '.eetpadA eht fo roivaheb laicepS';\n    }\n}\n\nclass Adapter extends Target {\n    private adaptee: Adaptee;\n\n    constructor(adaptee: Adaptee) {\n        super();\n        this.adaptee = adaptee;\n    }\n\n    request(): string {\n        const result = this.adaptee.specificRequest().split('').reverse().join('');\n        return `Adapter: (TRANSLATED) ${result}`;\n    }\n}\n\n// Client code\nconst target = new Target();\nconsole.log(target.request());\n\nconst adaptee = new Adaptee();\nconsole.log(`Adaptee: ${adaptee.specificRequest()}`);\n\nconsole.log('After using Adapter...');\nconst adapter = new Adapter(adaptee);\nconsole.log(adapter.request());\n"}]},{"title":"Bridge","examples":[{"code":"interface Implementation {\n    operationImplementation(): string;\n}\n\nclass Abstraction {\n    protected implementation: Implementation;\n\n    constructor(implementation: Implementation) {\n        this.implementation = implementation;\n    }\n\n    operation(): string {\n        const result = this.implementation.operationImplementation();\n        return `Abstraction: Base operation with:\\n${result}`;\n    }\n}\n\nclass ExtendedAbstraction extends Abstraction {\n    operation(): string {\n        const result = this.implementation.operationImplementation();\n        return `ExtendedAbstraction: Extended operation with:\\n${result}`;\n    }\n}\n\nclass ImplementationA implements Implementation {\n    operationImplementation(): string {\n        return 'ImplementationA: Here\\'s the result on the platform A.';\n    }\n}\n\nclass ImplementationB implements Implementation {\n    operationImplementation(): string {\n        return 'ImplementationB: Here\\'s the result on the platform B.';\n    }\n}\n\n// Client code\nlet implementation: Implementation = new ImplementationA();\nlet abstraction: Abstraction = new Abstraction(implementation);\nconsole.log(abstraction.operation());\n\nimplementation = new ImplementationB();\nabstraction = new ExtendedAbstraction(implementation);\nconsole.log(abstraction.operation());\n"}]},{"title":"Composite","examples":[{"code":"abstract class Component {\n    protected name: string;\n\n    constructor(name: string) {\n        this.name = name;\n    }\n\n    abstract add(component: Component): void;\n    abstract remove(component: Component): void;\n    abstract display(depth: number): void;\n}\n\nclass Leaf extends Component {\n    constructor(name: string) {\n        super(name);\n    }\n\n    display(depth: number): void {\n        console.log('-'.repeat(depth) + this.name);\n    }\n\n    add(component: Component): void {\n        console.log('Cannot add to a leaf.');\n    }\n\n    remove(component: Component): void {\n        console.log('Cannot remove from a leaf.');\n    }\n}\n\nclass Composite extends Component {\n    private children: Component[];\n\n    constructor(name: string) {\n        super(name);\n        this.children = [];\n    }\n\n    add(component: Component): void {\n        this.children.push(component);\n    }\n\n    remove(component: Component): void {\n        const index = this.children.indexOf(component);\n        if (index > -1) {\n            this.children.splice(index, 1);\n        }\n    }\n\n    display(depth: number): void {\n        console.log('-'.repeat(depth) + this.name);\n        for (const child of this.children) {\n            child.display(depth + 2);\n        }\n    }\n}\n\n// Client code\nconst root = new Composite('root');\nroot.add(new Leaf('Leaf A'));\nroot.add(new Leaf('Leaf B'));\n\nconst comp = new Composite('Composite X');\ncomp.add(new Leaf('Leaf XA'));\ncomp.add(new Leaf('Leaf XB'));\n\nroot.add(comp);\nroot.add(new Leaf('Leaf C'));\n\nconst leaf = new Leaf('Leaf D');\nroot.add(leaf);\nroot.remove(leaf);\n\nroot.display(1);\n"}]},{"title":"Decorator","examples":[{"code":"abstract class Component {\n    abstract operation(): string;\n}\n\nclass ConcreteComponent extends Component {\n    operation(): string {\n        return 'ConcreteComponent';\n    }\n}\n\nabstract class Decorator extends Component {\n    protected component: Component;\n\n    constructor(component: Component) {\n        super();\n        this.component = component;\n    }\n\n    operation(): string {\n        return this.component.operation();\n    }\n}\n\nclass ConcreteDecoratorA extends Decorator {\n    operation(): string {\n        return `ConcreteDecoratorA(${super.operation()})`;\n    }\n}\n\nclass ConcreteDecoratorB extends Decorator {\n    operation(): string {\n        return `ConcreteDecoratorB(${super.operation()})`;\n    }\n}\n\n// Client code\nlet simple = new ConcreteComponent();\nconsole.log(`Simple component: ${simple.operation()}`);\n\nlet decorator1 = new ConcreteDecoratorA(simple);\nlet decorator2 = new ConcreteDecoratorB(decorator1);\nconsole.log(`Decorated component: ${decorator2.operation()}`);\n"}]},{"title":"Facade","examples":[{"code":"class Subsystem1 {\n    operation1(): string {\n        return 'Subsystem1: Ready!';\n    }\n\n    operationN(): string {\n        return 'Subsystem1: Go!';\n    }\n}\n\nclass Subsystem2 {\n    operation1(): string {\n        return 'Subsystem2: Get ready!';\n    }\n\n    operationZ(): string {\n        return 'Subsystem2: Fire!';\n    }\n}\n\nclass Facade {\n    private subsystem1: Subsystem1;\n    private subsystem2: Subsystem2;\n\n    constructor(subsystem1?: Subsystem1, subsystem2?: Subsystem2) {\n        this.subsystem1 = subsystem1 || new Subsystem1();\n        this.subsystem2 = subsystem2 || new Subsystem2();\n    }\n\n    operation(): string {\n        let result = 'Facade initializes subsystems:\\n';\n        result += this.subsystem1.operation1();\n        result += this.subsystem2.operation1();\n        result += 'Facade orders subsystems to perform the action:\\n';\n        result += this.subsystem1.operationN();\n        result += this.subsystem2.operationZ();\n        return result;\n    }\n}\n\n// Client code\nconst subsystem1 = new Subsystem1();\nconst subsystem2 = new Subsystem2();\nconst facade = new Facade(subsystem1, subsystem2);\nconsole.log(facade.operation());\n"}]},{"title":"Flyweight","examples":[{"code":"class Flyweight {\n    private sharedState: any;\n\n    constructor(sharedState: any) {\n        this.sharedState = sharedState;\n    }\n\n    operation(uniqueState: any): void {\n        const s = JSON.stringify(this.sharedState);\n        const u = JSON.stringify(uniqueState);\n        console.log(`Flyweight: Displaying shared (${s}) and unique (${u}) state.`);\n    }\n}\n\nclass FlyweightFactory {\n    private flyweights: { [key: string]: Flyweight };\n\n    constructor(initialFlyweights: any[]) {\n        this.flyweights = {};\n        for (const state of initialFlyweights) {\n            this.flyweights[this.getKey(state)] = new Flyweight(state);\n        }\n    }\n\n    private getKey(state: any): string {\n        return state.join('_');\n    }\n\n    getFlyweight(sharedState: any): Flyweight {\n        const key = this.getKey(sharedState);\n\n        if (!(key in this.flyweights)) {\n            console.log('FlyweightFactory: Can\\'t find a flyweight, creating new one.');\n            this.flyweights[key] = new Flyweight(sharedState);\n        } else {\n            console.log('FlyweightFactory: Reusing existing flyweight.');\n        }\n\n        return this.flyweights[key];\n    }\n}\n\n// Client code\nconst factory = new FlyweightFactory([\n    ['Chevrolet', 'Camaro2018', 'pink'],\n    ['Mercedes Benz', 'C300', 'black'],\n    ['Mercedes Benz', 'C500', 'red'],\n]);\n\nfactory.getFlyweight(['Chevrolet', 'Camaro2018', 'pink']).operation(['A001', 'Jul 30, 2020']);\nfactory.getFlyweight(['Mercedes Benz', 'C300', 'black']).operation(['B002', 'May 18, 2021']);\n\nconsole.log('\\nAdding new car to pool');\nfactory.getFlyweight(['BMW', 'M5', 'red']).operation(['C003', 'Mar 15, 2022']);\n"}]},{"title":"Proxy","examples":[{"code":"class Subject {\n    request(): string {\n        return 'Subject: Handling request.';\n    }\n}\n\nclass RealSubject extends Subject {\n    request(): string {\n        return 'RealSubject: Handling request.';\n    }\n}\n\nclass Proxy extends Subject {\n    private realSubject: RealSubject;\n\n    constructor(realSubject: RealSubject) {\n        super();\n        this.realSubject = realSubject;\n    }\n\n    request(): string {\n        if (this.checkAccess()) {\n            this.realSubject.request();\n            this.logAccess();\n            return 'Proxy: Logged and handing over to RealSubject.';\n        }\n        return 'Proxy: I am sorry, but I cannot let you through.';\n    }\n\n    private checkAccess(): boolean {\n        // Some real checks should go here.\n        console.log('Proxy: Checking access prior to firing a real request.');\n        return true;\n    }\n\n    private logAccess(): void {\n        console.log('Proxy: Logging the time of request.');\n    }\n}\n\n// Client code\nconst realSubject = new RealSubject();\nconsole.log(realSubject.request());\n\nconst proxy = new Proxy(realSubject);\nconsole.log(proxy.request());\n"}]}],"patterns_proprietary":[{"title":"Module","description":[{"variant":"subtitle1","content":"The Module Pattern encapsulates \"privacy\", state, and organization using closures. It's commonly used in the JavaScript community due to its powerful ability to create private and public parts.\n"},{"variant":"h6","content":"Benefits"},{"variant":"subtitle1","content":"This pattern provides a way to encapsulate private members while exposing a public API. It also helps in organizing code into manageable sections.\n"}],"examples":[{"code":"namespace Module {\n    let privateVar: string = 'I am private...';\n\n    export function publicMethod() {\n        console.log(privateVar);\n    }\n}\n\nModule.publicMethod(); // Outputs: 'I am private...'\n"}]},{"title":"Mixin","description":[{"variant":"subtitle1","content":"JavaScript's object model includes features that allow it to mimic a classical inheritance pattern, known as Mixins. They allow objects to take on properties and methods from other objects.\n"},{"variant":"h6","content":"Benefits"},{"variant":"subtitle1","content":"Mixins help in avoiding the issues related to traditional inheritance and provide a way to add reusable functionalities to objects. They can be used to augment a class by adding multiple behaviors like event handling as mixins.\n"}],"examples":[{"code":"class Car {\n    constructor(public name: string) {}\n}\n\ninterface CarMixin {\n    revEngine(): void;\n}\n\nfunction applyMixin(targetClass: any, mixin: any) {\n    Object.getOwnPropertyNames(mixin.prototype).forEach(name => {\n        targetClass.prototype[name] = mixin.prototype[name];\n    });\n}\n\nclass SportsCarMixin implements CarMixin {\n    revEngine() {\n        console.log(`The ${this.name} goes vroom vroom!`);\n    }\n}\n\napplyMixin(Car, SportsCarMixin);\n\nlet raceCar = new Car(\"Ferrari\");\nraceCar.revEngine(); // Outputs: The Ferrari goes vroom vroom!\n"}]},{"title":"Publish/Subscribe","description":[{"variant":"subtitle1","content":"This pattern allows you to create modules that can communicate with each other over a single interface without knowing about each other's inner workings. It's a form of decoupling that can be incredibly useful for larger applications.\n"},{"variant":"h6","content":"Benefits"},{"variant":"subtitle1","content":"The pattern promotes loose coupling and enables better testability, maintainability, and scalability of the application. It's an essential pattern for building complex applications that require various modules to communicate with each other asynchronously.\n"}],"examples":[{"code":"type Handler<T> = (data: T) => void;\n\nclass PubSub<T> {\n    private topics: { [key: string]: Handler<T>[] } = {};\n\n    subscribe(topic: string, handler: Handler<T>): string {\n        if (!this.topics[topic]) {\n            this.topics[topic] = [];\n        }\n        const token = (Math.random() * 1000).toFixed(0);\n        this.topics[topic].push(handler);\n        return token;\n    }\n\n    publish(topic: string, data: T): void {\n        const handlers = this.topics[topic];\n        if (handlers) {\n            handlers.forEach(handler => handler(data));\n        }\n    }\n\n    unsubscribe(topic: string, token: string): void {\n        const handlers = this.topics[topic];\n        if (handlers) {\n            this.topics[topic] = handlers.filter(h => h.toString() !== token);\n        }\n    }\n}\n\nconst pubsub = new PubSub<string>();\n\nconst messageLogger: Handler<string> = (data: string) => {\n    console.log(`Logging: ${data}`);\n};\n\nconst subscription = pubsub.subscribe('inbox/newMessage', messageLogger);\n\npubsub.publish('inbox/newMessage', 'hello world!');\npubsub.publish('inbox/newMessage', 'test');\npubsub.publish('inbox/newMessage', 'another message');\n\npubsub.unsubscribe('inbox/newMessage', subscription);\n"}]},{"title":"Promise","description":[{"variant":"subtitle1","content":"With the advent of ES6, Promises are a model for asynchronous programming. Promises are a first-class representation of a value that may be made available in the future.\n"},{"variant":"h6","content":"Benefits"},{"variant":"subtitle1","content":"Promises provide a cleaner, more robust way of handling asynchronous operations compared to callbacks. They simplify error handling, improve readability and make it easier to write asynchronous code.\n"}],"examples":[{"code":"let promise = new Promise<string>((resolve, reject) => {\n    setTimeout(() => {\n        resolve('Hello world!');\n    }, 2000);\n});\n\npromise.then(value => {\n    console.log(value); // \"Hello world!\"\n}).catch(error => {\n    console.log(error);\n});\n"}]},{"title":"Type Guards","description":[{"variant":"subtitle1","content":"Type Guards are a TypeScript-specific pattern used to narrow down the type of a variable within a conditional block. They are particularly useful when dealing with union types or custom types.\n"},{"variant":"h6","content":"Benefits"},{"variant":"subtitle1","content":"Type Guards help ensure type safety by allowing developers to make assertions about the type of a variable within specific code blocks, reducing the likelihood of runtime errors.\n"}],"examples":[{"code":"function isString(value: any): value is string {\n    return typeof value === 'string';\n}\n\nfunction exampleFunction(value: string | number) {\n    if (isString(value)) {\n        // value is now narrowed down to type 'string'\n        console.log(value.toUpperCase());\n    } else {\n        // value is now narrowed down to type 'number'\n        console.log(value.toFixed(2));\n    }\n}\n\nexampleFunction(\"hello\"); // Outputs: HELLO\nexampleFunction(3.14159); // Outputs: 3.14\n"}]},{"title":"Conditional Types","description":[{"variant":"subtitle1","content":"Conditional Types are a feature introduced in TypeScript that allow types to be selected based on conditions. They are used to create flexible and reusable type definitions that adapt to different input types.\n"},{"variant":"h6","content":"Benefits"},{"variant":"subtitle1","content":"Conditional Types enable developers to create more dynamic and expressive type definitions, improving code readability and maintainability. They are especially useful in libraries and frameworks where generic types need to handle various scenarios.\n"}],"examples":[{"code":"type TypeName<T> =\n    T extends string ? \"string\" :\n    T extends number ? \"number\" :\n    T extends boolean ? \"boolean\" :\n    \"object\";\n\ntype StringOrNumber = TypeName<string | number>; // \"string\" | \"number\"\ntype StringOrBoolean = TypeName<string | boolean>; // \"string\" | \"boolean\"\n"}]},{"title":"Mapped Types","description":[{"variant":"subtitle1","content":"Mapped Types are a powerful feature of TypeScript that allow you to transform the properties of an existing type into a new type. They are often used to create new types based on existing ones, with modified or filtered properties.\n"},{"variant":"h6","content":"Benefits"},{"variant":"subtitle1","content":"Mapped Types provide a convenient way to create new types based on existing ones, reducing code duplication and improving type safety. They are particularly useful when working with complex data structures or APIs.\n"}],"examples":[{"code":"type Optional<T> = {\n    [P in keyof T]?: T[P];\n};\n\ninterface Person {\n    name: string;\n    age: number;\n}\n\ntype PartialPerson = Optional<Person>;\n\nconst partialPerson: PartialPerson = { name: \"John\" };\n"}]},{"title":"Nullish Coalescing Operator (??)","description":[{"variant":"subtitle1","content":"The Nullish Coalescing Operator (??) is a TypeScript feature that provides a concise way to handle null or undefined values by providing a default value if the variable is null or undefined.\n"},{"variant":"h6","content":"Benefits"},{"variant":"subtitle1","content":"The Nullish Coalescing Operator simplifies code by reducing the need for verbose null-checking expressions, making it easier to handle potentially null or undefined values in a concise and readable manner.\n"}],"examples":[{"code":"const name: string | null | undefined = null;\nconst displayName = name ?? \"Guest\";\nconsole.log(displayName); // Outputs: Guest\n"}]},{"title":"Optional Chaining Operator (?.)","description":[{"variant":"subtitle1","content":"The Optional Chaining Operator (?.) is a TypeScript feature that allows you to access properties or methods of an object without causing an error if the object is null or undefined.\n"},{"variant":"h6","content":"Benefits"},{"variant":"subtitle1","content":"The Optional Chaining Operator improves code robustness by gracefully handling null or undefined values, reducing the likelihood of runtime errors caused by accessing properties of non-existent objects.\n"}],"examples":[{"code":"interface User {\n    name?: string;\n    address?: {\n        city?: string;\n        zipCode?: string;\n    };\n}\n\nconst user: User = {};\n\nconst city = user.address?.city; // No error if address or city is null or undefined\nconsole.log(city); // Outputs: undefined\n"}]},{"title":"Discriminated Unions","description":[{"variant":"subtitle1","content":"Discriminated Unions are a TypeScript pattern used to model complex data structures with multiple possible shapes. They involve creating a union type with a common discriminant property to differentiate between the different shapes.\n"},{"variant":"h6","content":"Benefits"},{"variant":"subtitle1","content":"Discriminated Unions provide a type-safe way to work with complex data structures, ensuring that only valid shapes are allowed and enabling the TypeScript compiler to perform exhaustive type checking.\n"}],"examples":[{"code":"interface Square {\n    kind: \"square\";\n    size: number;\n}\n\ninterface Rectangle {\n    kind: \"rectangle\";\n    width: number;\n    height: number;\n}\n\ninterface Circle {\n    kind: \"circle\";\n    radius: number;\n}\n\ntype Shape = Square | Rectangle | Circle;\n\nfunction area(shape: Shape): number {\n    switch (shape.kind) {\n        case \"square\":\n            return shape.size * shape.size;\n        case \"rectangle\":\n            return shape.width * shape.height;\n        case \"circle\":\n            return Math.PI * shape.radius ** 2;\n    }\n}\n\nconst square: Shape = { kind: \"square\", size: 5 };\nconsole.log(area(square)); // Outputs: 25\n"}]},{"title":"Type Assertion","description":[{"variant":"subtitle1","content":"Type Assertion is a TypeScript feature that allows you to assert or override the type of a variable when you know more about its type than TypeScript can infer.\n"},{"variant":"h6","content":"Benefits"},{"variant":"subtitle1","content":"Type Assertion provides a way to tell the TypeScript compiler that you know the type of a variable better than it does, allowing you to access properties or methods that are not part of the inferred type.\n"}],"examples":[{"code":"let value: any = \"hello\";\nlet length: number = (value as string).length;\nconsole.log(length); // Outputs: 5\n"}]}]},"principles":{"principles_solid":[{"title":"Single Responsibility","examples":[{"title":"Good Example","code":"class UserDataManager {\n    saveUserData() { /* ... */ }\n}\n\nclass UserNotification {\n    sendNotification() { /* ... */ }\n}\n"},{"title":"Bad Example","code":"class User {\n    saveUserData() { /* ... */ }\n    sendNotification() { /* ... */ }\n}\n"}]},{"title":"Open-Closed","examples":[{"title":"Good Example","code":"class Shape {\n    computeArea(): number { throw new Error('Must be implemented in subclasses'); }\n}\n\nclass Rectangle extends Shape {\n    constructor(private width: number, private height: number) {\n        super();\n    }\n\n    computeArea(): number {\n        return this.width * this.height;\n    }\n}\n"},{"title":"Bad Example","code":"class AreaCalculator {\n    computeArea(shape: any): number {\n        if (shape instanceof Rectangle) {\n            return shape.width * shape.height;\n        } else if (shape instanceof Circle) {\n            return 3.14 * shape.radius * shape.radius;\n        }\n    }\n}\n"}]},{"title":"Liskov Substitution","examples":[{"title":"Good Example","code":"class Bird {\n    fly() { /* ... */ }\n}\n\nclass Sparrow extends Bird {\n    fly() { /* ... */ }  // Sparrow, being a Bird, can fly\n}\n"},{"title":"Bad Example","code":"class Bird {\n    fly() { /* ... */ }\n}\n\nclass Ostrich extends Bird {\n    fly() {\n        throw new Error(\"Can't fly\");  // Ostrich, being a Bird, should not alter the expected behavior of the fly method\n    }\n}\n"}]},{"title":"Interface Segregation","examples":[{"title":"Good Example","code":"class Worker {\n    work() { /* ... */ }\n}\n\nclass Feeder {\n    eat() { /* ... */ }\n}\n\nclass Human extends Worker {}\nclass Robot extends Worker {}\n\nclass Animal extends Feeder {}\n"},{"title":"Bad Example","code":"class Worker {\n    work() { /* ... */ }\n    eat() { /* ... */ }  // This method should not be part of the Worker interface\n}\n"}]},{"title":"Dependency Inversion","examples":[{"title":"Good Example","code":"interface Device {\n    turnOn(): void;\n}\n\nclass Switch {\n    constructor(private device: Device) {}\n    operate() {\n        this.device.turnOn();\n    }\n}\n\nclass Fan implements Device {\n    turnOn() { /* ... */ }\n}\n\nconst wallSwitch = new Switch(new Fan());\n"},{"title":"Bad Example","code":"class LightBulb {\n    turnOn() { /* ... */ }\n}\n\nclass Switch {\n    constructor() {\n        this.bulb = new LightBulb();\n    }\n    operate() {\n        this.bulb.turnOn();\n    }\n}\n"}]}],"principles_other":[{"title":"Don't Repeat Yourself (DRY)","examples":[{"title":"Good Example","code":"// Good example: Using default parameters and arrow functions for repeated logic\nconst addTax = (price: number, rate: number = 0.05): number => price + (price * rate);\n"},{"title":"Bad Example","code":"const addTaxForFood = (price: number): number => price + (price * 0.05);\nconst addTaxForElectronics = (price: number): number => price + (price * 0.05);\n"}]},{"title":"Keep It Simple Stupid (KISS)","examples":[{"title":"Good Example","code":"const isEven = (num: number): boolean => num % 2 === 0;\n"},{"title":"Bad Example","code":"const isEven = (num: number): boolean => num % Math.abs(2) === 0;\n"}]},{"title":"You Aren't Gonna Need It (YAGNI)","examples":[{"title":"Good Example","code":"class Car {\n    drive() { /* ... */ }\n}\n"},{"title":"Bad Example","code":"class Car {\n    drive() { /* ... */ }\n    fly() { /* ... */ }  // Cars don't fly!\n}\n"}]},{"title":"Law of Demeter (Principle of Least Knowledge)","examples":[{"title":"Good Example","code":"class Wallet {\n    private _money: number;\n    constructor() {\n        this._money = 100;\n    }\n    getAmount(): number {\n        return this._money;\n    }\n}\n\nclass Person {\n    wallet: Wallet;\n    constructor() {\n        this.wallet = new Wallet();\n    }\n    getMoneyAmount(): number {\n        return this.wallet.getAmount();\n    }\n}\n\nfunction purchase(item: { price: number }, buyer: Person) {\n    if (buyer.getMoneyAmount() >= item.price) { /* ... */ }\n}\n"},{"title":"Bad Example","code":"class Wallet {\n    money: { amount: number };\n    constructor() {\n        this.money = { amount: 100 };\n    }\n}\n\nclass Person {\n    wallet: Wallet;\n    constructor() {\n        this.wallet = new Wallet();\n    }\n}\n\nfunction purchase(item: { price: number }, buyer: Person) {\n    if (buyer.wallet.money.amount >= item.price) { /* ... */ }\n}\n"}]},{"title":"Separation of Concerns","examples":[{"title":"Good Example","code":"class UserDataService {\n    fetchUserData() { /* ... */ }\n}\n\nclass UserLogic {\n    calculateAge() { /* ... */ }\n}\n\nclass UserComponent {\n    render() { /* ... */ }\n}\n"},{"title":"Bad Example","code":"class UserComponent {\n    fetchUserData() { /* ... */ }\n    render() { /* ... */ }\n    calculateAge() { /* ... */ }\n}\n"}]}],"principles_proprietary":[{"title":"Static Typing","description":[{"variant":"subtitle1","content":"TypeScript provides static typing, allowing variables to be associated with specific types, helping catch type-related errors during development.\n"},{"variant":"subtitle1","content":"TypeScript does offer static typing, but it still retains the dynamic typing feature of JavaScript. Variables can be assigned values of different types at runtime.\n"}],"examples":[{"code":"llet data: number = 42; // data is now a number\n// data = 'hello'; // Error: Type '\"hello\"' is not assignable to type 'number'\ndata = 10; // Valid\n"}]},{"title":"Class-based Object Orientation","description":[{"variant":"subtitle1","content":"TypeScript supports classical inheritance with classes, allowing for more structured and organized code compared to prototype-based inheritance in JavaScript.\n"}],"examples":[{"code":"class Person {\n    constructor(private firstName: string) {}\n\n    sayHello(): string {\n        return `Hello, I'm ${this.firstName}`;\n    }\n}\n\nconst john = new Person(\"John\");\nconsole.log(john.sayHello()); // \"Hello, I'm John\"\n"}]},{"title":"First-Class Functions","description":[{"variant":"subtitle1","content":"In JavaScript, functions are first-class objects. They can be stored in variables, passed as arguments to other functions, returned from those functions, and have their own properties and methods.\n"},{"variant":"subtitle1","content":"Functions in TypeScript are still first-class objects, just like in JavaScript. They can be assigned to variables, passed as arguments, returned from other functions, and have properties and methods.\n"}],"examples":[{"code":"function greet() {\n  return \"Hello World!\";\n}\nlet greetMsg = greet; // Assigning function to variable\nconsole.log(greetMsg()); // \"Hello World!\"\n"}]},{"title":"Stronger Type System","description":[{"variant":"subtitle1","content":"TypeScript has a stronger type system compared to JavaScript, enabling better code quality and maintainability through type checking.\n"}],"examples":[{"code":"function add(x: number, y: number): number {\n    return x + y;\n}\n\nlet result: number = add(5, 10); // Valid\n// let result: string = add(5, 10); // Error: Type 'number' is not assignable to type 'string'\n"}]},{"title":"Enums","description":[{"variant":"subtitle1","content":"TypeScript provides enums to define a set of named constants, which can improve code readability and maintainability.\n"}],"examples":[{"code":"enum Color {\n    Red,\n    Green,\n    Blue,\n}\n\nlet color: Color = Color.Red;\nconsole.log(color); // 0\n"}]},{"title":"Type Inference","description":[{"variant":"subtitle1","content":"TypeScript can infer types based on context, reducing the need for explicit type annotations and making code more concise.\n"}],"examples":[{"code":"let message = \"Hello\"; // Type inference infers 'string' type\n// message = 10; // Error: Type 'number' is not assignable to type 'string'\n"}]},{"title":"Asynchronous Programming","description":[{"variant":"subtitle1","content":"With features like callbacks, promises, and async/await, JavaScript handles asynchronous operations. This is especially useful for operations like fetching data from a server without blocking the main thread.\n"},{"variant":"subtitle1","content":"TypeScript, being a superset of JavaScript, inherits its asynchronous programming features, including callbacks, promises, and async/await syntax for handling asynchronous operations.\n"}],"examples":[{"code":"async function fetchData() {\n  let response = await fetch('https://api.example.com/data');\n  let data = await response.json();\n  console.log(data);\n}\nfetchData();\n"}]},{"title":"Closure","description":[{"variant":"subtitle1","content":"Functions in TypeScript form closures just like in JavaScript. A closure is created when a function is defined within another function and has access to the outer function's variables.\n"}],"examples":[{"code":"function makeAdder(x) {\n  return function(y) {\n    return x + y;\n  };\n}\nlet add5 = makeAdder(5);\nconsole.log(add5(2));  // 7\n"}]},{"title":"Single-Threaded with Non-blocking I/O","description":[{"variant":"subtitle1","content":"TypeScript applications run in a single-threaded environment with an event loop, similar to JavaScript. Asynchronous operations such as setTimeout, fetch, and event handling ensure non-blocking I/O.\n"}],"examples":[{"code":"console.log('First');\nsetTimeout(function() {\n  console.log('Second');\n}, 0);\nconsole.log('Third');\n// Output: First, Third, Second\n"}]},{"title":"Truthy and Falsy Values","description":[{"variant":"subtitle1","content":"TypeScript, like JavaScript, evaluates values as truthy or falsy in conditional statements. Understanding truthy and falsy values is important for flow control in TypeScript code.\n"}],"examples":[{"code":"if ('') console.log('Falsy!');\nif ('hello') console.log('Truthy!');\n// Output: Truthy!\n"}]},{"title":"Template Literals","description":[{"variant":"subtitle1","content":"JavaScript allows for string interpolation and multi-line strings in a more readable fashion with template literals.\n"},{"variant":"subtitle1","content":"TypeScript supports template literals, providing a convenient way to create strings with embedded expressions. This feature enhances readability and maintainability of string formatting.\n"}],"examples":[{"code":"const name = \"world\";\nconsole.log(`Hello, ${name}!`); // Hello, world!\n"}]},{"title":"ES6 and Beyond Compatibility","description":[{"variant":"subtitle1","content":"TypeScript is designed to be compatible with modern ECMAScript features, including ES6 and beyond, providing access to advanced language capabilities while ensuring compatibility with older environments.\n"}],"examples":[{"code":"class Animal {\n    constructor(private name: string) {}\n\n    speak() {\n        console.log(`${this.name} makes a noise.`);\n    }\n}\n\nclass Dog extends Animal {\n    speak() {\n        console.log(`${this.name} barks.`);\n    }\n}\n\nlet dog = new Dog('Rex');\ndog.speak(); // Rex barks.\n"}]}]}}