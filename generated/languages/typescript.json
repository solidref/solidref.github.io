{"name":"TypeScript","code":"typescript","ext":"ts","birth":2012,"death":"N/A","inspiredBy":["javascript","c#","java","php","python","ruby","scala"],"inspiring":["javascript"],"description":"TypeScript is a superset of JavaScript that adds static typing and other features to the language.\nIt was developed by Microsoft and is widely used for building large-scale applications,\nparticularly in the realm of web development. TypeScript compiles to plain JavaScript and can be\nused in both front-end and back-end development. It offers features like static typing,\ninterfaces, generics, and advanced tooling support through tools like Visual Studio Code.\nTypeScript provides developers with increased type safety and helps catch errors at compile time,\nleading to more robust and maintainable codebases.\n","patterns":{"patterns_behavioural":[{"title":"Chain Of Responsibility","examples":[{"codeFile":"patterns/behavioural/chain-of-responsibility/example","code":"// es-lint-disable\n\n// Define the interface for a support handler\ninterface SupportHandler {\n  setNextHandler(handler: SupportHandler): void;\n  handleRequest(request: string): string | null;\n}\n\n// Concrete implementation of the SupportHandler interface for Level 1 support\nclass Level1Support implements SupportHandler {\n  private nextHandler: SupportHandler | null = null;\n\n  setNextHandler(handler: SupportHandler): void {\n    this.nextHandler = handler;\n  }\n\n  handleRequest(request: string): string | null {\n    if (request.includes('basic')) {\n      return 'Level 1 Support: Issue resolved at basic level.';\n    } else if (this.nextHandler) {\n      return this.nextHandler.handleRequest(request);\n    } else {\n      return null; // No more handlers in the chain\n    }\n  }\n}\n\n// Concrete implementation of the SupportHandler interface for Level 2 support\nclass Level2Support implements SupportHandler {\n  private nextHandler: SupportHandler | null = null;\n\n  setNextHandler(handler: SupportHandler): void {\n    this.nextHandler = handler;\n  }\n\n  handleRequest(request: string): string | null {\n    if (request.includes('advanced')) {\n      return 'Level 2 Support: Issue resolved at advanced level.';\n    } else if (this.nextHandler) {\n      return this.nextHandler.handleRequest(request);\n    } else {\n      return null; // No more handlers in the chain\n    }\n  }\n}\n\n// Concrete implementation of the SupportHandler interface for Level 3 support\nclass Level3Support implements SupportHandler {\n  handleRequest(request: string): string | null {\n    if (request.includes('bug')) {\n      return 'Level 3 Support: Issue resolved at development level.';\n    } else {\n      return 'Level 3 Support: Unable to resolve the issue.';\n    }\n  }\n\n  // Level 3 support does not have a next handler\n  setNextHandler(handler: SupportHandler): void {\n    throw new Error('Level 3 Support is the highest level and does not have a next handler.');\n  }\n}\n\n// Client code\nfunction main() {\n  // Create instances of support handlers\n  const level1 = new Level1Support();\n  const level2 = new Level2Support();\n  const level3 = new Level3Support();\n\n  // Chain the handlers together\n  level1.setNextHandler(level2);\n  level2.setNextHandler(level3);\n\n  // Simulate support requests\n  const request1 = 'Fix basic login issue';\n  const request2 = 'Debug advanced performance problem';\n  const request3 = 'Investigate bug causing application crash';\n\n  // Process requests through the chain of responsibility\n  console.log(level1.handleRequest(request1)); // Output: Level 1 Support: Issue resolved at basic level.\n  console.log(level1.handleRequest(request2)); // Output: Level 2 Support: Issue resolved at advanced level.\n  console.log(level1.handleRequest(request3)); // Output: Level 3 Support: Issue resolved at development level.\n}\n\n/**\n * This code demonstrates how the Chain of Responsibility pattern can be used in a support\n * ticket system. The SupportHandler interface defines the contract for handling support\n * requests, and concrete implementations (Level1Support, Level2Support, and Level3Support)\n * represent different levels of support. Each handler decides whether it can handle a\n * request or should pass it to the next handler in the chain.\n */\n"}]},{"title":"Command","examples":[{"codeFile":"patterns/behavioural/command/example","code":"// Define the command interface\ninterface Command {\n  execute(): void;\n}\n\n// Receiver class that performs the actual actions\nclass Light {\n  turnOn(): void {\n    console.log('Light is on');\n  }\n\n  turnOff(): void {\n    console.log('Light is off');\n  }\n}\n\n// Concrete command to turn on the light\nclass TurnOnCommand implements Command {\n  private light: Light;\n\n  constructor(light: Light) {\n    this.light = light;\n  }\n\n  execute(): void {\n    this.light.turnOn();\n  }\n}\n\n// Concrete command to turn off the light\nclass TurnOffCommand implements Command {\n  private light: Light;\n\n  constructor(light: Light) {\n    this.light = light;\n  }\n\n  execute(): void {\n    this.light.turnOff();\n  }\n}\n\n// Invoker class that triggers the commands\nclass RemoteControl {\n  private commands: Command[] = [];\n\n  addCommand(command: Command): void {\n    this.commands.push(command);\n  }\n\n  executeCommands(): void {\n    this.commands.forEach(command => command.execute());\n  }\n}\n\n// Client code\nfunction main() {\n  // Create a light\n  const light = new Light();\n\n  // Create commands for turning the light on and off\n  const turnOnCommand = new TurnOnCommand(light);\n  const turnOffCommand = new TurnOffCommand(light);\n\n  // Create a remote control and add the commands\n  const remoteControl = new RemoteControl();\n  remoteControl.addCommand(turnOnCommand);\n  remoteControl.addCommand(turnOffCommand);\n\n  // Press the buttons on the remote control to execute the commands\n  remoteControl.executeCommands();\n}\n\n/**\n * This code demonstrates how the Command pattern can be used in a remote control\n * system to control a light. The Command interface defines the contract for executing\n * commands, and concrete command classes (TurnOnCommand and TurnOffCommand) encapsulate\n * the actions to be performed on the Light receiver object. The RemoteControl acts as\n * the invoker, which holds and triggers the commands. Pressing buttons on the remote\n * control executes the corresponding commands, resulting in the light being turned on\n * and off.\n */\n"}]},{"title":"Iterator","examples":[{"codeFile":"patterns/behavioural/iterator/example","code":"class Iterator<T> {\n  private collection: T[];\n  private index: number;\n\n  constructor(collection: T[]) {\n    this.collection = collection;\n    this.index = 0;\n  }\n\n  next(): T | undefined {\n    return this.collection[this.index++];\n  }\n\n  hasNext(): boolean {\n    return this.index < this.collection.length;\n  }\n}\n\n// Client code\nconst items = [1, 'two', 3, 'four', 5];\nconst iterator = new Iterator(items);\n\nwhile (iterator.hasNext()) {\n  console.log(iterator.next());\n}\n\n/**\n * In this example, the Iterator pattern is used to iterate over a collection of books\n * stored in a BookCollection. The Iterator interface defines methods for checking if\n * there are more elements (hasNext) and retrieving the next element (next). The\n * ArrayIterator class provides a concrete implementation of the iterator for an array\n * of books. The BookCollection class implements the Iterable interface, which allows\n * it to create iterators for iterating over its collection of books. Finally, in the\n * client code, we create a BookCollection, add books to it, and iterate over the\n * collection using the iterator, printing each book's name.\n */\n"}]},{"title":"Mediator","examples":[{"codeFile":"patterns/behavioural/mediator/example","code":"// Define the Mediator interface\ninterface ChatMediator {\n  sendMessage(message: string, user: User): void;\n}\n\n// Concrete Mediator implementation for a chat room\nclass ChatRoom implements ChatMediator {\n  sendMessage(message: string, user: User): void {\n    console.log(`[${user.getName()}] sends message: ${message}`);\n  }\n}\n\n// Define the Colleague interface\ninterface User {\n  send(message: string): void;\n  receive(message: string): void;\n  getName(): string;\n}\n\n// Concrete Colleague implementation for a chat user\nclass ChatUser implements User {\n  private name: string;\n  private mediator: ChatMediator;\n\n  constructor(name: string, mediator: ChatMediator) {\n    this.name = name;\n    this.mediator = mediator;\n  }\n\n  send(message: string): void {\n    console.log(`[${this.name}] sends message: ${message}`);\n    this.mediator.sendMessage(message, this);\n  }\n\n  receive(message: string): void {\n    console.log(`[${this.name}] received message: ${message}`);\n  }\n\n  getName(): string {\n    return this.name;\n  }\n}\n\n// Client code\nfunction main() {\n  // Create a chat room mediator\n  const chatMediator: ChatMediator = new ChatRoom();\n\n  // Create chat users\n  const user1: User = new ChatUser('User1', chatMediator);\n  const user2: User = new ChatUser('User2', chatMediator);\n\n  // Send messages between users\n  user1.send('Hello, User2!');\n  user2.send('Hi, User1!');\n}\n\n/**\n * In this example, the Mediator pattern is used to facilitate communication between\n * users in a chat room. The ChatMediator interface defines a method sendMessage for\n * sending messages to users. The ChatRoom class provides a concrete implementation\n * of the mediator for managing communication between users in the chat room.\n *\n * The User interface defines methods send and receive for sending and receiving messages,\n * respectively, as well as a method getName for getting the user's name. The ChatUser\n * class implements the User interface and interacts with the mediator to send and\n * receive messages.\n *\n * In the client code, we create a chat room mediator and two chat users. Users can send\n * messages to each other by calling the send method, which delegates the message sending\n * to the mediator. When a message is received, the mediator distributes it to the\n * appropriate user's receive method.\n */\n"}]},{"title":"Memento","examples":[{"codeFile":"patterns/behavioural/memento/example","code":"// Originator class represents the object whose state needs to be saved and restored\nclass Editor {\n  private text: string;\n\n  constructor(text: string) {\n    this.text = text;\n  }\n\n  setText(text: string): void {\n    this.text = text;\n  }\n\n  getText(): string {\n    return this.text;\n  }\n\n  // Creates a memento containing the current state of the editor\n  save(): Memento {\n    return new Memento(this.text);\n  }\n\n  // Restores the editor's state from a memento\n  restore(memento: Memento): void {\n    this.text = memento.getState();\n  }\n}\n\n// Memento class represents the stored state of the editor\nclass Memento {\n  private state: string;\n\n  constructor(state: string) {\n    this.state = state;\n  }\n\n  getState(): string {\n    return this.state;\n  }\n}\n\n// Caretaker class is responsible for keeping track of multiple mementos\nclass History {\n  private mementos: Memento[] = [];\n\n  // Adds a memento to the history\n  addMemento(memento: Memento): void {\n    this.mementos.push(memento);\n  }\n\n  // Retrieves the most recent memento from the history\n  getLatestMemento(): Memento {\n    if (this.mementos.length === 0) {\n      throw new Error(\"No mementos available\");\n    }\n    return this.mementos[this.mementos.length - 1];\n  }\n}\n\n// Client code\nfunction main() {\n  const editor = new Editor(\"Initial text\");\n\n  // Create a history to store mementos\n  const history = new History();\n\n  // Add a memento to the history\n  history.addMemento(editor.save());\n\n  // Modify the text\n  editor.setText(\"Modified text\");\n\n  // Add another memento to the history\n  history.addMemento(editor.save());\n\n  // Restore the editor's state to a previous memento\n  editor.restore(history.getLatestMemento());\n\n  console.log(editor.getText()); // Output: Modified text (restored from the previous state)\n}\n\n/**\n * In this example, the Editor class represents an object whose state can be modified. The save\n * method creates a memento containing the current state of the editor, and the restore method\n * restores the editor's state from a given memento.\n *\n * The Memento class represents the stored state of the editor at a particular point in time.\n *\n * The History class is responsible for maintaining a list of mementos. It provides methods\n * to add a memento to the history and retrieve the most recent memento.\n *\n * In the client code, we create an editor object and a history object. We modify the editor's\n * state, save it to a memento, modify it again, and then restore it to the previous state using\n * the memento stored in the history.\n */\n"}]},{"title":"Observer","examples":[{"codeFile":"patterns/behavioural/observer/example","code":"interface Subject {\n  subscribe(observer: Observer): void;\n  unsubscribe(observer: Observer): void;\n  notify(data: any): void;\n}\n\nclass ConcreteSubject implements Subject {\n  private observers: Observer[] = [];\n\n  subscribe(observer: Observer) {\n    this.observers.push(observer);\n  }\n\n  unsubscribe(observer: Observer) {\n    const index = this.observers.indexOf(observer);\n    if (index > -1) {\n      this.observers.splice(index, 1);\n    }\n  }\n\n  notify(data: any) {\n    this.observers.forEach(observer => observer.update(data));\n  }\n}\n\ninterface Observer {\n  update(data: any): void;\n}\n\nclass ConcreteObserver implements Observer {\n  update(data: any) {\n    console.log(`Observer received data: ${data}`);\n  }\n}\n\n// Client code\nconst subject = new ConcreteSubject();\nconst observer1 = new ConcreteObserver();\nconst observer2 = new ConcreteObserver();\n\nsubject.subscribe(observer1);\nsubject.subscribe(observer2);\n\nsubject.notify('Hello Observers!');\n\nsubject.unsubscribe(observer2);\nsubject.notify('Goodbye Observers!');\n\n/**\n * In this example, the Editor class represents an object whose state can be modified.\n * The save method creates a memento containing the current state of the editor, and\n * the restore method restores the editor's state from a given memento.\n *\n * The Memento class represents the stored state of the editor at a particular point in time.\n * The History class is responsible for maintaining a list of mementos. It provides\n * methods to add a memento to the history and retrieve the most recent memento.\n *\n * In the client code, we create an editor object and a history object. We modify the\n * editor's state, save it to a memento, modify it again, and then restore it to the\n * previous state using the memento stored in the history.\n */\n"}]},{"title":"State","examples":[{"codeFile":"patterns/behavioural/state/example","code":"// Interface defining the common behavior for all traffic light states\ninterface TrafficLightState {\n  changeState(trafficLight: TrafficLight): void;\n}\n\n// Concrete state representing the \"Red\" state of the traffic light\nclass RedState implements TrafficLightState {\n  changeState(trafficLight: TrafficLight): void {\n    console.log(\"Traffic light is now RED. Stop!\");\n    // Transition to the next state (Yellow) after a certain duration\n    setTimeout(() => {\n      trafficLight.setState(new YellowState());\n    }, 3000);\n  }\n}\n\n// Concrete state representing the \"Yellow\" state of the traffic light\nclass YellowState implements TrafficLightState {\n  changeState(trafficLight: TrafficLight): void {\n    console.log(\"Traffic light is now YELLOW. Prepare to stop or proceed with caution.\");\n    // Transition to the next state (Green) after a certain duration\n    setTimeout(() => {\n      trafficLight.setState(new GreenState());\n    }, 2000);\n  }\n}\n\n// Concrete state representing the \"Green\" state of the traffic light\nclass GreenState implements TrafficLightState {\n  changeState(trafficLight: TrafficLight): void {\n    console.log(\"Traffic light is now GREEN. Go!\");\n    // Transition to the next state (Red) after a certain duration\n    setTimeout(() => {\n      trafficLight.setState(new RedState());\n    }, 4000);\n  }\n}\n\n// Context class representing the traffic light\nclass TrafficLight {\n  private state: TrafficLightState;\n\n  constructor() {\n    // Initial state is Red\n    this.state = new RedState();\n  }\n\n  // Method to change the state of the traffic light\n  setState(state: TrafficLightState): void {\n    this.state = state;\n    this.state.changeState(this);\n  }\n}\n\n// Client code\nfunction main() {\n  const trafficLight = new TrafficLight();\n\n  // Simulate traffic light behavior by changing its state\n  trafficLight.setState(new GreenState());\n}\n\n/**\n * The TrafficLightState interface defines the common behavior for all traffic light states.\n * Each concrete state implements this interface and provides its own implementation of the\n * changeState method.\n *\n * Concrete state classes (RedState, YellowState, and GreenState) represent different states\n * of the traffic light and define how the traffic light behaves in each state.\n *\n * The TrafficLight class acts as the context and maintains a reference to the current state.\n * It provides a method setState to change the state of the traffic light.\n *\n * In the client code, we create a TrafficLight object and change its state to simulate the\n * behavior of a traffic light system.\n */\n"}]},{"title":"Strategy","examples":[{"codeFile":"patterns/behavioural/strategy/example","code":"// Interface defining the common behavior for all payment strategies\ninterface PaymentStrategy {\n  pay(amount: number): void;\n}\n\n// Concrete strategy for processing payments via credit card\nclass CreditCardPaymentStrategy implements PaymentStrategy {\n  constructor(private cardNumber: string, private expiryDate: string, private cvv: string) { }\n\n  pay(amount: number): void {\n    console.log(`Processing credit card payment of $${amount} with card number ${this.cardNumber}`);\n    // Logic to process payment via credit card\n  }\n}\n\n// Concrete strategy for processing payments via PayPal\nclass PayPalPaymentStrategy implements PaymentStrategy {\n  constructor(private email: string, private password: string) { }\n\n  pay(amount: number): void {\n    console.log(`Processing PayPal payment of $${amount} with email ${this.email}`);\n    // Logic to process payment via PayPal\n  }\n}\n\n// Context class representing the payment processor\nclass PaymentProcessor {\n  private paymentStrategy: PaymentStrategy;\n\n  // Setter method to set the payment strategy dynamically\n  setPaymentStrategy(paymentStrategy: PaymentStrategy): void {\n    this.paymentStrategy = paymentStrategy;\n  }\n\n  // Method to process payment using the selected strategy\n  processPayment(amount: number): void {\n    if (this.paymentStrategy) {\n      this.paymentStrategy.pay(amount);\n    } else {\n      console.log(\"Payment strategy not set. Please select a payment method.\");\n    }\n  }\n}\n\n// Client code\nfunction main() {\n  const paymentProcessor = new PaymentProcessor();\n\n  // Select a payment method (strategy) dynamically\n  const creditCardStrategy = new CreditCardPaymentStrategy(\"1234 5678 9012 3456\", \"12/25\", \"123\");\n  paymentProcessor.setPaymentStrategy(creditCardStrategy);\n  paymentProcessor.processPayment(100);\n\n  // Change payment method (strategy)\n  const payPalStrategy = new PayPalPaymentStrategy(\"example@example.com\", \"password\");\n  paymentProcessor.setPaymentStrategy(payPalStrategy);\n  paymentProcessor.processPayment(50);\n}\n\n/**\n * The PaymentStrategy interface defines the common behavior for all payment strategies. Each concrete payment\n * strategy class implements this interface and provides its own implementation of the pay method.\n *\n * Concrete strategy classes (CreditCardPaymentStrategy and PayPalPaymentStrategy) represent different payment\n * methods and define how payments are processed for each method.\n *\n * The PaymentProcessor class acts as the context and maintains a reference to the current payment strategy.\n * It provides a setter method setPaymentStrategy to dynamically set the payment strategy, and a processPayment\n * method to process payments using the selected strategy.\n *\n * In the client code, we create a PaymentProcessor object and dynamically select the payment method (strategy)\n * based on user input. We then process payments using the selected strategy.\n *\n */\n"}]},{"title":"Template Method","examples":[{"codeFile":"patterns/behavioural/template-method/example","code":"abstract class Breakfast {\n  // Template method\n  prepare(): void {\n    this.boilWater();\n    this.addIngredients();\n    this.cook();\n    this.serve();\n  }\n\n  // Abstract methods to be implemented by subclasses\n  abstract addIngredients(): void;\n  abstract cook(): void;\n\n  // Concrete methods\n  boilWater(): void {\n    console.log(\"Boiling water...\");\n  }\n\n  serve(): void {\n    console.log(\"Breakfast is served!\");\n  }\n}\n\nclass OmeletteBreakfast extends Breakfast {\n  addIngredients(): void {\n    console.log(\"Adding eggs, cheese, and vegetables to the pan.\");\n  }\n\n  cook(): void {\n    console.log(\"Cooking the omelette until golden brown.\");\n  }\n}\n\nclass PancakeBreakfast extends Breakfast {\n  addIngredients(): void {\n    console.log(\"Mixing flour, eggs, milk, and sugar to make the batter.\");\n  }\n\n  cook(): void {\n    console.log(\"Pouring the batter onto the griddle and flipping until cooked.\");\n  }\n}\n\n// Client code\nconsole.log(\"Preparing Omelette Breakfast:\");\nconst omeletteBreakfast = new OmeletteBreakfast();\nomeletteBreakfast.prepare();\n\nconsole.log(\"\\nPreparing Pancake Breakfast:\");\nconst pancakeBreakfast = new PancakeBreakfast();\npancakeBreakfast.prepare();\n\n/**\n * In this example, we have an abstract class Breakfast representing the template method pattern. It defines\n * the steps of preparing breakfast in the prepare() method, which serves as the template method. The abstract\n * methods addIngredients() and cook() are placeholders for the specific steps that vary between different\n * types of breakfasts.\n *\n * Subclasses such as OmeletteBreakfast and PancakeBreakfast extend the Breakfast class and implement the\n * abstract methods to provide specific implementations for adding ingredients and cooking. The template\n * method prepare() orchestrates the sequence of steps required to prepare each type of breakfast.\n *\n */\n"}]},{"title":"Visitor","examples":[{"codeFile":"patterns/behavioural/visitor/example","code":"// Visitor interface\ninterface AnimalVisitor {\n  visitLion(lion: Lion): void;\n  visitElephant(elephant: Elephant): void;\n  visitGiraffe(giraffe: Giraffe): void;\n}\n\n// Concrete visitor implementing the operations on animals\nclass AnimalFeeder implements AnimalVisitor {\n  visitLion(lion: Lion): void {\n    console.log(`Feeding meat to ${lion.getName()}.`);\n  }\n\n  visitElephant(elephant: Elephant): void {\n    console.log(`Feeding hay to ${elephant.getName()}.`);\n  }\n\n  visitGiraffe(giraffe: Giraffe): void {\n    console.log(`Feeding leaves to ${giraffe.getName()}.`);\n  }\n}\n\n// Element interface representing animals\ninterface Animal {\n  accept(visitor: AnimalVisitor): void;\n}\n\n// Concrete elements representing different types of animals\nclass Lion implements Animal {\n  constructor(private name: string) { }\n\n  getName(): string {\n    return this.name;\n  }\n\n  accept(visitor: AnimalVisitor): void {\n    visitor.visitLion(this);\n  }\n}\n\nclass Elephant implements Animal {\n  constructor(private name: string) { }\n\n  getName(): string {\n    return this.name;\n  }\n\n  accept(visitor: AnimalVisitor): void {\n    visitor.visitElephant(this);\n  }\n}\n\nclass Giraffe implements Animal {\n  constructor(private name: string) { }\n\n  getName(): string {\n    return this.name;\n  }\n\n  accept(visitor: AnimalVisitor): void {\n    visitor.visitGiraffe(this);\n  }\n}\n\n// Object structure containing the collection of animals\nclass Zoo {\n  private animals: Animal[] = [];\n\n  addAnimal(animal: Animal): void {\n    this.animals.push(animal);\n  }\n\n  // Perform the operation defined by the visitor on each animal\n  performOperation(visitor: AnimalVisitor): void {\n    this.animals.forEach(animal => {\n      animal.accept(visitor);\n    });\n  }\n}\n\n// Client code\nconst zoo = new Zoo();\nzoo.addAnimal(new Lion(\"Simba\"));\nzoo.addAnimal(new Elephant(\"Dumbo\"));\nzoo.addAnimal(new Giraffe(\"Melman\"));\n\nconst feeder = new AnimalFeeder();\nzoo.performOperation(feeder);\n\n/**\n * The AnimalVisitor interface defines the operations that can be performed on different types of animals.\n *\n * The AnimalFeeder class is a concrete visitor that implements feeding operations for lions, elephants,\n * and giraffes.\n *\n * The Animal interface represents animals, and concrete animal classes (Lion, Elephant, and Giraffe)\n * implement this interface and define how they accept a visitor.\n *\n * The Zoo class represents the object structure that contains a collection of animals. It has methods to\n * add animals and perform an operation (feeding in this case) using a visitor.\n *\n * Finally, in the client code, we create a zoo, add animals to it, create a visitor (animal feeder), and\n * then perform the feeding operation on each animal in the zoo using the visitor.\n */\n"}]}],"patterns_creational":[{"title":"Factory Method","examples":[{"codeFile":"patterns/creational/factory-method/example","code":"// Product interface: Vehicle\ninterface Vehicle {\n  drive(): void;\n}\n\n// Concrete Products: Car and Truck\nclass Car implements Vehicle {\n  drive(): void {\n    console.log(\"Driving a car...\");\n  }\n}\n\nclass Truck implements Vehicle {\n  drive(): void {\n    console.log(\"Driving a truck...\");\n  }\n}\n\n// Creator: VehicleFactory\nabstract class VehicleFactory {\n  // Factory Method\n  abstract createVehicle(): Vehicle;\n\n  // An operation that uses the factory method\n  deliverVehicle(): void {\n    const vehicle = this.createVehicle();\n    console.log(\"Delivering the vehicle...\");\n    vehicle.drive();\n  }\n}\n\n// Concrete Creators: CarFactory and TruckFactory\nclass CarFactory extends VehicleFactory {\n  // Factory Method implementation for creating a car\n  createVehicle(): Vehicle {\n    console.log(\"Creating a car...\");\n    return new Car();\n  }\n}\n\nclass TruckFactory extends VehicleFactory {\n  // Factory Method implementation for creating a truck\n  createVehicle(): Vehicle {\n    console.log(\"Creating a truck...\");\n    return new Truck();\n  }\n}\n\n// Client code\nconst carFactory = new CarFactory();\ncarFactory.deliverVehicle();\n\nconst truckFactory = new TruckFactory();\ntruckFactory.deliverVehicle();\n\n/**\n * The Vehicle interface defines a common interface for all vehicles, which includes a drive() method.\n *\n * The Car and Truck classes are concrete implementations of the Vehicle interface.\n *\n * The VehicleFactory class is an abstract class representing a creator. It declares the createVehicle()\n * method, which serves as the Factory Method for creating vehicles. The deliverVehicle() method is a\n * common operation that uses the Factory Method to create and deliver a vehicle.\n *\n * The CarFactory and TruckFactory classes are concrete implementations of the VehicleFactory class.\n * They override the createVehicle() method to create specific types of vehicles (i.e., cars and trucks).\n *\n */\n"}]},{"title":"Abstract Factory","examples":[{"codeFile":"patterns/creational/abstract-factory/example","code":"// Abstract Factory interface\ninterface FurnitureFactory {\n  createChair(): Chair;\n  createTable(): Table;\n}\n\n// Concrete Factory 1: Modern Furniture Factory\nclass ModernFurnitureFactory implements FurnitureFactory {\n  createChair(): Chair {\n    return new ModernChair();\n  }\n\n  createTable(): Table {\n    return new ModernTable();\n  }\n}\n\n// Concrete Factory 2: Vintage Furniture Factory\nclass VintageFurnitureFactory implements FurnitureFactory {\n  createChair(): Chair {\n    return new VintageChair();\n  }\n\n  createTable(): Table {\n    return new VintageTable();\n  }\n}\n\n// Abstract Product: Chair\ninterface Chair {\n  sitOn(): void;\n}\n\n// Concrete Product: Modern Chair\nclass ModernChair implements Chair {\n  sitOn(): void {\n    console.log(\"Sitting on a modern chair.\");\n  }\n}\n\n// Concrete Product: Vintage Chair\nclass VintageChair implements Chair {\n  sitOn(): void {\n    console.log(\"Sitting on a vintage chair.\");\n  }\n}\n\n// Abstract Product: Table\ninterface Table {\n  putOn(): void;\n}\n\n// Concrete Product: Modern Table\nclass ModernTable implements Table {\n  putOn(): void {\n    console.log(\"Putting something on a modern table.\");\n  }\n}\n\n// Concrete Product: Vintage Table\nclass VintageTable implements Table {\n  putOn(): void {\n    console.log(\"Putting something on a vintage table.\");\n  }\n}\n\n// Client code\nfunction createFurniture(factory: FurnitureFactory): void {\n  const chair = factory.createChair();\n  const table = factory.createTable();\n\n  console.log(\"Created furniture:\");\n  chair.sitOn();\n  table.putOn();\n}\n\n// Creating modern furniture\nconsole.log(\"Creating modern furniture:\");\ncreateFurniture(new ModernFurnitureFactory());\n\n// Creating vintage furniture\nconsole.log(\"\\nCreating vintage furniture:\");\ncreateFurniture(new VintageFurnitureFactory());\n\n/**\n * The FurnitureFactory interface declares methods for creating chairs and tables.\n *\n * Concrete factories (ModernFurnitureFactory and VintageFurnitureFactory) implement the\n * FurnitureFactory interface to produce modern and vintage furniture, respectively.\n *\n * The Chair interface declares a method for sitting on a chair, and concrete chair classes\n * (ModernChair and VintageChair) implement this interface.\n *\n * The Table interface declares a method for putting something on a table, and concrete table\n * classes (ModernTable and VintageTable) implement this interface.\n * The createFurniture function acts as a client and receives a FurnitureFactory as a parameter.\n * It creates a chair and a table using the factory and then performs actions on the created furniture.\n *\n */\n"}]},{"title":"Builder","examples":[{"codeFile":"patterns/creational/builder/example","code":"// Product: Computer\nclass Computer {\n  private cpu: string;\n  private ram: number;\n  private storage: number;\n  private gpu: string;\n  private screenSize: number;\n\n  constructor(cpu: string, ram: number, storage: number, gpu: string, screenSize: number) {\n    this.cpu = cpu;\n    this.ram = ram;\n    this.storage = storage;\n    this.gpu = gpu;\n    this.screenSize = screenSize;\n  }\n\n  displaySpecs(): void {\n    console.log(`CPU: ${this.cpu}`);\n    console.log(`RAM: ${this.ram} GB`);\n    console.log(`Storage: ${this.storage} GB`);\n    console.log(`GPU: ${this.gpu}`);\n    console.log(`Screen Size: ${this.screenSize} inches`);\n  }\n}\n\n// Builder interface\ninterface ComputerBuilder {\n  setCPU(cpu: string): void;\n  setRAM(ram: number): void;\n  setStorage(storage: number): void;\n  setGPU(gpu: string): void;\n  setScreenSize(screenSize: number): void;\n  getResult(): Computer;\n}\n\n// Concrete Builder: Gaming Computer Builder\nclass GamingComputerBuilder implements ComputerBuilder {\n  private computer: Computer;\n\n  constructor() {\n    this.computer = new Computer(\"\", 0, 0, \"\", 0);\n  }\n\n  setCPU(cpu: string): void {\n    this.computer = new Computer(cpu, this.computer.ram, this.computer.storage, this.computer.gpu, this.computer.screenSize);\n  }\n\n  setRAM(ram: number): void {\n    this.computer = new Computer(this.computer.cpu, ram, this.computer.storage, this.computer.gpu, this.computer.screenSize);\n  }\n\n  setStorage(storage: number): void {\n    this.computer = new Computer(this.computer.cpu, this.computer.ram, storage, this.computer.gpu, this.computer.screenSize);\n  }\n\n  setGPU(gpu: string): void {\n    this.computer = new Computer(this.computer.cpu, this.computer.ram, this.computer.storage, gpu, this.computer.screenSize);\n  }\n\n  setScreenSize(screenSize: number): void {\n    this.computer = new Computer(this.computer.cpu, this.computer.ram, this.computer.storage, this.computer.gpu, screenSize);\n  }\n\n  getResult(): Computer {\n    return this.computer;\n  }\n}\n\n// Director\nclass ComputerBuilderDirector {\n  private builder: ComputerBuilder;\n\n  constructor(builder: ComputerBuilder) {\n    this.builder = builder;\n  }\n\n  constructGamingComputer(): void {\n    this.builder.setCPU(\"Intel Core i9\");\n    this.builder.setRAM(32);\n    this.builder.setStorage(1000);\n    this.builder.setGPU(\"NVIDIA GeForce RTX 3080\");\n    this.builder.setScreenSize(27);\n  }\n}\n\n// Client code\nconst gamingComputerBuilder = new GamingComputerBuilder();\nconst director = new ComputerBuilderDirector(gamingComputerBuilder);\ndirector.constructGamingComputer();\nconst gamingComputer = gamingComputerBuilder.getResult();\nconsole.log(\"Gaming Computer Specifications:\");\ngamingComputer.displaySpecs();\n\n\n/**\n * The Computer class represents the product we want to build, which is a custom computer with\n * various specifications like CPU, RAM, storage, GPU, and screen size.\n *\n * The ComputerBuilder interface defines methods for setting each component of the computer.\n *\n * The GamingComputerBuilder class is a concrete builder that implements the ComputerBuilder\n * interface to construct a gaming computer with specific configurations.\n *\n * The ComputerBuilderDirector class is responsible for directing the construction process using\n * a builder.\n *\n * The client code creates a GamingComputerBuilder, passes it to the director, and instructs the\n * director to construct a gaming computer. Finally, it retrieves the constructed gaming computer\n * and displays its specifications.\n *\n */\n"}]},{"title":"Prototype","examples":[{"codeFile":"patterns/creational/prototype/example","code":"// Prototype interface: UserProfile\ninterface UserProfile {\n  clone(): UserProfile;\n  customizeProfile(settings: UserProfileSettings): void;\n  displayProfile(): void;\n}\n\n// Concrete Prototype: DefaultUserProfile\nclass DefaultUserProfile implements UserProfile {\n  private username: string;\n  private bio: string;\n  private profilePicture: string;\n\n  constructor(username: string, bio: string, profilePicture: string) {\n    this.username = username;\n    this.bio = bio;\n    this.profilePicture = profilePicture;\n  }\n\n  clone(): UserProfile {\n    return new DefaultUserProfile(this.username, this.bio, this.profilePicture);\n  }\n\n  customizeProfile(settings: UserProfileSettings): void {\n    if (settings.username) {\n      this.username = settings.username;\n    }\n    if (settings.bio) {\n      this.bio = settings.bio;\n    }\n    if (settings.profilePicture) {\n      this.profilePicture = settings.profilePicture;\n    }\n  }\n\n  displayProfile(): void {\n    console.log(\"Username:\", this.username);\n    console.log(\"Bio:\", this.bio);\n    console.log(\"Profile Picture:\", this.profilePicture);\n  }\n}\n\n// Prototype settings: UserProfileSettings\ninterface UserProfileSettings {\n  username?: string;\n  bio?: string;\n  profilePicture?: string;\n}\n\n// Client code\nconst defaultProfile = new DefaultUserProfile(\"user123\", \"Welcome to my profile!\", \"default.jpg\");\n\n// Clone the default profile to create a customized profile\nconst customizedProfile = defaultProfile.clone();\ncustomizedProfile.customizeProfile({ bio: \"I'm a software developer.\", profilePicture: \"avatar.jpg\" });\n\n// Display both profiles\nconsole.log(\"Default Profile:\");\ndefaultProfile.displayProfile();\n\nconsole.log(\"\\nCustomized Profile:\");\ncustomizedProfile.displayProfile();\n\n/**\n * The UserProfile interface defines methods for cloning a profile, customizing profile settings, and\n * displaying the profile.\n *\n * The DefaultUserProfile class is a concrete implementation of the UserProfile interface. It represents\n * the default user profile with properties like username, bio, and profile picture. The clone()\n * method creates a copy of the profile, and the customizeProfile() method allows modifying profile\n * settings.\n *\n * The UserProfileSettings interface defines optional settings that can be customized in a user profile.\n *\n * In the client code, we create a default user profile and then clone it to create a customized profile\n * with updated settings. Both profiles can be displayed independently, demonstrating the use of the\n * Prototype pattern to create new objects by copying existing ones.\n */\n"}]},{"title":"Singleton","examples":[{"codeFile":"patterns/creational/singleton/example","code":"class Logger {\n  private static instance: Logger;\n  private logHistory: string[] = [];\n\n  // Private constructor to prevent instantiation from outside the class\n  private constructor() { }\n\n  // Static method to retrieve the singleton instance\n  static getInstance(): Logger {\n    if (!Logger.instance) {\n      Logger.instance = new Logger();\n    }\n    return Logger.instance;\n  }\n\n  // Method to log messages\n  log(message: string): void {\n    const timestamp = new Date().toISOString();\n    const logEntry = `[${timestamp}] ${message}`;\n    this.logHistory.push(logEntry);\n    console.log(logEntry);\n  }\n\n  // Method to retrieve log history\n  getLogHistory(): string[] {\n    return this.logHistory;\n  }\n}\n\n// Client code\nconst logger1 = Logger.getInstance();\nconst logger2 = Logger.getInstance();\n\nconsole.log(logger1 === logger2); // Output: true, both references point to the same instance\n\nlogger1.log(\"User logged in\");\nlogger2.log(\"Data saved to database\");\n\nconsole.log(logger1.getLogHistory());\n\n/**\n * The Logger class has a private static instance property that holds the single instance of the logger.\n *\n * The constructor is made private to prevent instantiation from outside the class.\n *\n * The getInstance() method is a static method that returns the singleton instance of the logger. It\n * ensures that only one instance of the logger is created throughout the application.\n *\n * The log() method logs a message along with a timestamp and adds the log entry to the logHistory array.\n *\n * The getLogHistory() method retrieves the log history.\n *\n * In the client code, both logger1 and logger2 references point to the same instance of the logger\n * obtained using the getInstance() method.\n *\n * Logging messages using either logger1 or logger2 will result in consistent logging behavior, and the\n * log history can be retrieved from either instance.\n */\n"}]}],"patterns_structural":[{"title":"Adapter","examples":[{"codeFile":"patterns/structural/adapter/example","code":"// Adaptee: Existing MP3 player\nclass Mp3Player {\n  playMp3(fileName: string): void {\n    console.log(`Playing MP3 file: ${fileName}`);\n  }\n}\n\n// Target: Interface expected by the client (unified interface)\ninterface AudioPlayer {\n  play(fileName: string): void;\n}\n\n// Adapter: Converts OGG audio files to MP3 format\nclass OggToMp3Adapter implements AudioPlayer {\n  private mp3Player: Mp3Player;\n\n  constructor() {\n    this.mp3Player = new Mp3Player();\n  }\n\n  play(fileName: string): void {\n    // Convert OGG to MP3 and play using the MP3 player\n    console.log(`Converting OGG file '${fileName}' to MP3 format`);\n    const mp3FileName = this.convertToMp3(fileName);\n    this.mp3Player.playMp3(mp3FileName);\n  }\n\n  private convertToMp3(fileName: string): string {\n    // Simulate conversion process (replace extension)\n    return fileName.replace('.ogg', '.mp3');\n  }\n}\n\n// Client code\nconst audioPlayer: AudioPlayer = new OggToMp3Adapter();\n\n// Play MP3 file\naudioPlayer.play('audio1.mp3');\n\n// Play OGG file (automatically converted to MP3)\naudioPlayer.play('audio2.ogg');\n\n/**\n * Mp3Player represents the existing audio player that can play MP3 files.\n *\n * AudioPlayer is the target interface that defines the unified interface expected by the\n * client application for playing audio files.\n *\n * OggToMp3Adapter is the adapter class that implements the AudioPlayer interface. It internally\n * uses the Mp3Player to play MP3 files but converts OGG files to MP3 format before delegating to\n * the Mp3Player.\n *\n * In the client code, the application interacts with the AudioPlayer interface, unaware of whether\n * it's playing MP3 or OGG files. When playing an OGG file, the adapter automatically converts it\n * to MP3 format before playing it using the Mp3Player.\n *\n */\n"}]},{"title":"Bridge","examples":[{"codeFile":"patterns/structural/bridge/example","code":"// Abstraction: Vehicle\nabstract class Vehicle {\n  protected workshop: Workshop;\n\n  constructor(workshop: Workshop) {\n    this.workshop = workshop;\n  }\n\n  abstract manufacture(): void;\n}\n\n// Implementor: Workshop\ninterface Workshop {\n  work(): void;\n}\n\n// Concrete Implementor: Paint Workshop\nclass PaintWorkshop implements Workshop {\n  work(): void {\n    console.log('Painting vehicle');\n  }\n}\n\n// Concrete Implementor: Repair Workshop\nclass RepairWorkshop implements Workshop {\n  work(): void {\n    console.log('Repairing vehicle');\n  }\n}\n\n// Refined Abstraction: Car\nclass Car extends Vehicle {\n  manufacture(): void {\n    console.log('Manufacturing car.');\n    this.workshop.work();\n  }\n}\n\n// Refined Abstraction: Truck\nclass Truck extends Vehicle {\n  manufacture(): void {\n    console.log('Manufacturing truck.');\n    this.workshop.work();\n  }\n}\n\n// Client code\nconst car = new Car(new PaintWorkshop());\ncar.manufacture(); // Output: Manufacturing car. Painting vehicle\n\nconst truck = new Truck(new RepairWorkshop());\ntruck.manufacture(); // Output: Manufacturing truck. Repairing vehicle\n\n/**\n * The Vehicle class represents the abstraction, which is extended by Car and Truck.\n *\n * The Workshop interface represents the implementor, defining the work method.\n *\n * PaintWorkshop and RepairWorkshop are concrete implementations of the Workshop interface.\n *\n * Each vehicle can be associated with a specific workshop using composition, and it delegates the work to that workshop.\n */\n"}]},{"title":"Composite","examples":[{"codeFile":"patterns/structural/composite/example","code":"// Component: Department\ninterface Department {\n  getName(): string;\n  getEmployees(): string[];\n}\n\n// Leaf: Individual Department\nclass IndividualDepartment implements Department {\n  private name: string;\n  private employees: string[];\n\n  constructor(name: string, employees: string[]) {\n    this.name = name;\n    this.employees = employees;\n  }\n\n  getName(): string {\n    return this.name;\n  }\n\n  getEmployees(): string[] {\n    return this.employees;\n  }\n}\n\n// Composite: Composite Department\nclass CompositeDepartment implements Department {\n  private name: string;\n  private departments: Department[];\n\n  constructor(name: string) {\n    this.name = name;\n    this.departments = [];\n  }\n\n  getName(): string {\n    return this.name;\n  }\n\n  addDepartment(department: Department): void {\n    this.departments.push(department);\n  }\n\n  removeDepartment(department: Department): void {\n    const index = this.departments.indexOf(department);\n    if (index !== -1) {\n      this.departments.splice(index, 1);\n    }\n  }\n\n  getEmployees(): string[] {\n    let employees: string[] = [];\n    for (const department of this.departments) {\n      employees = employees.concat(department.getEmployees());\n    }\n    return employees;\n  }\n}\n\n// Client code\nconst salesDepartment = new IndividualDepartment('Sales Department', ['John', 'Alice', 'Bob']);\nconst marketingDepartment = new IndividualDepartment('Marketing Department', ['Emily', 'David']);\nconst engineeringDepartment = new IndividualDepartment('Engineering Department', ['Michael', 'Sarah', 'Chris']);\n\nconst headDepartment = new CompositeDepartment('Head Department');\nheadDepartment.addDepartment(salesDepartment);\nheadDepartment.addDepartment(marketingDepartment);\n\nconst parentEngineeringDepartment = new CompositeDepartment('Parent Engineering Department');\nparentEngineeringDepartment.addDepartment(engineeringDepartment);\n\nconst rootDepartment = new CompositeDepartment('Root Department');\nrootDepartment.addDepartment(headDepartment);\nrootDepartment.addDepartment(parentEngineeringDepartment);\n\n// Get all employees in the root department\nconsole.log('Employees in the root department:');\nconsole.log(rootDepartment.getEmployees());\n\n/**\n * The Department interface defines the common methods for both individual departments and composite departments.\n *\n * IndividualDepartment represents an individual department with a name and a list of employees.\n *\n * CompositeDepartment represents a composite department that can contain sub-departments. It maintains a\n * list of departments and delegates the getEmployees method to its sub-departments recursively.\n *\n * The client code creates a hierarchical structure of departments and retrieves all employees from the root department.\n */\n"}]},{"title":"Decorator","examples":[{"codeFile":"patterns/structural/decorator/example","code":"// Component: Notification\ninterface Notification {\n  send(): string;\n}\n\n// Concrete Component: Base Notification\nclass BaseNotification implements Notification {\n  send(): string {\n    return 'Base notification: You have a new message!';\n  }\n}\n\n// Decorator: Notification Decorator\nabstract class NotificationDecorator implements Notification {\n  protected notification: Notification;\n\n  constructor(notification: Notification) {\n    this.notification = notification;\n  }\n\n  send(): string {\n    return this.notification.send();\n  }\n}\n\n// Concrete Decorator: Sound Notification\nclass SoundNotificationDecorator extends NotificationDecorator {\n  send(): string {\n    return `${super.send()} (Sound notification: Ding!)`;\n  }\n}\n\n// Concrete Decorator: Priority Notification\nclass PriorityNotificationDecorator extends NotificationDecorator {\n  send(): string {\n    return `${super.send()} (Priority notification: High priority!)`;\n  }\n}\n\n// Client code\nconst baseNotification: Notification = new BaseNotification();\nconsole.log(baseNotification.send());\n\nconst soundNotification: Notification = new SoundNotificationDecorator(baseNotification);\nconsole.log(soundNotification.send());\n\nconst priorityNotification: Notification = new PriorityNotificationDecorator(baseNotification);\nconsole.log(priorityNotification.send());\n\nconst soundAndPriorityNotification: Notification = new PriorityNotificationDecorator(new SoundNotificationDecorator(baseNotification));\nconsole.log(soundAndPriorityNotification.send());\n\n/**\n * The Notification interface defines the common method for sending notifications.\n *\n * BaseNotification represents the base notification without any additional features.\n *\n * NotificationDecorator is an abstract class that serves as the base class for concrete decorators.\n * It holds a reference to the wrapped notification.\n *\n * SoundNotificationDecorator adds sound notification functionality to the base notification.\n *\n * PriorityNotificationDecorator adds priority notification functionality to the base notification.\n *\n * The client code demonstrates how we can dynamically add sound notification, priority notification,\n * or both to the base notification. Each decorator enhances the behavior of the base notification\n * without modifying its implementation.\n */\n"}]},{"title":"Facade","examples":[{"codeFile":"patterns/structural/facade/example","code":"// Subsystem: Flight Booking\nclass FlightBookingSystem {\n  bookFlight(origin: string, destination: string): string {\n    return `Flight booked from ${origin} to ${destination}`;\n  }\n}\n\n// Subsystem: Hotel Booking\nclass HotelBookingSystem {\n  bookHotel(location: string, checkInDate: Date, checkOutDate: Date): string {\n    return `Hotel booked at ${location} from ${checkInDate.toDateString()} to ${checkOutDate.toDateString()}`;\n  }\n}\n\n// Subsystem: Car Rental\nclass CarRentalSystem {\n  rentCar(location: string, startDate: Date, endDate: Date): string {\n    return `Car rented at ${location} from ${startDate.toDateString()} to ${endDate.toDateString()}`;\n  }\n}\n\n// Facade: TravelFacade\nclass TravelFacade {\n  private flightBookingSystem: FlightBookingSystem;\n  private hotelBookingSystem: HotelBookingSystem;\n  private carRentalSystem: CarRentalSystem;\n\n  constructor() {\n    this.flightBookingSystem = new FlightBookingSystem();\n    this.hotelBookingSystem = new HotelBookingSystem();\n    this.carRentalSystem = new CarRentalSystem();\n  }\n\n  bookTravel(origin: string, destination: string, location: string, checkInDate: Date, checkOutDate: Date, startDate: Date, endDate: Date): string {\n    const flightDetails = this.flightBookingSystem.bookFlight(origin, destination);\n    const hotelDetails = this.hotelBookingSystem.bookHotel(location, checkInDate, checkOutDate);\n    const carDetails = this.carRentalSystem.rentCar(location, startDate, endDate);\n\n    return `${flightDetails}\\n${hotelDetails}\\n${carDetails}`;\n  }\n}\n\n// Client code\nconst travelFacade = new TravelFacade();\nconst bookingDetails = travelFacade.bookTravel('New York', 'Los Angeles', 'Hilton', new Date('2023-12-15'), new Date('2023-12-20'), new Date('2023-12-15'), new Date('2023-12-20'));\nconsole.log(bookingDetails);\n\n/**\n * The FlightBookingSystem, HotelBookingSystem, and CarRentalSystem classes represent the\n * subsystems of flight booking, hotel booking, and car rental, respectively.\n *\n * The TravelFacade class provides a simplified interface for booking a complete travel\n * package. It encapsulates the complexities of interacting with the subsystems.\n *\n * The client code interacts with the TravelFacade to book a complete travel package without\n * directly interacting with the subsystems.\n */\n"}]},{"title":"Flyweight","examples":[{"codeFile":"patterns/structural/flyweight/example","code":"// Flyweight: Character\nclass Character {\n  constructor(private character: string) { }\n\n  display(font: string, size: number): string {\n    return `Character: ${this.character}, Font: ${font}, Size: ${size}`;\n  }\n}\n\n// Flyweight Factory: CharacterFactory\nclass CharacterFactory {\n  private characters: { [key: string]: Character } = {};\n\n  getCharacter(character: string): Character {\n    if (!this.characters[character]) {\n      this.characters[character] = new Character(character);\n    }\n    return this.characters[character];\n  }\n}\n\n// Client code\nconst characterFactory = new CharacterFactory();\n\n// Text document\nconst text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\";\n\n// Rendering text with flyweight characters\nconst renderedText: string[] = [];\n\nfor (const char of text) {\n  const character = characterFactory.getCharacter(char);\n  renderedText.push(character.display('Arial', 12)); // Assume same font and size for simplicity\n}\n\n// Displaying rendered text\nconsole.log(renderedText.join('\\n'));\n\n\n/**\n * The Character class represents the flyweight object for a character. It contains intrinsic\n * state (the character itself).\n *\n * The CharacterFactory class acts as a flyweight factory, creating and managing flyweight\n * objects. It ensures that each character is shared among multiple instances.\n *\n * In the client code, we create a text document and render it using flyweight characters.\n * Instead of creating a new character object for each character in the text, we retrieve\n * existing flyweight characters from the factory, saving memory and improving performance.\n */\n"}]},{"title":"Proxy","examples":[{"codeFile":"patterns/structural/proxy/example","code":"// Subject: Interface representing the common behavior of RealSubject and Proxy\ninterface IHttpServer {\n  request(url: string): Promise<string>;\n}\n\n// RealSubject: The actual HTTP server implementation\nclass HttpServer implements IHttpServer {\n  async request(url: string): Promise<string> {\n    // Simulating HTTP request to the actual server\n    return `Response from server for URL: ${url}`;\n  }\n}\n\n// Proxy: Proxy server that intercepts requests before forwarding them to the real server\nclass ProxyServer implements IHttpServer {\n  private httpServer: HttpServer;\n\n  constructor() {\n    this.httpServer = new HttpServer();\n  }\n\n  async request(url: string): Promise<string> {\n    // Additional logic can be added here, e.g., caching, access control, logging\n    console.log(`Proxy: Intercepted request for URL: ${url}`);\n\n    // Forward the request to the real server\n    const response = await this.httpServer.request(url);\n\n    // Additional processing on the response can be done here\n\n    return response;\n  }\n}\n\n// Client code\nasync function testProxy() {\n  const proxy = new ProxyServer();\n\n  // Client sends a request to the proxy server\n  const response = await proxy.request(\"https://example.com\");\n\n  console.log(response);\n}\n\n// Test the proxy\ntestProxy();\n\n/**\n * The IHttpServer interface defines the common behavior for both the HttpServer and ProxyServer classes.\n *\n * The HttpServer class represents the real HTTP server implementation. It implements the request method\n * to send HTTP requests to the actual server.\n *\n * The ProxyServer class acts as a proxy server. It intercepts requests before forwarding them to the real\n * server. The request method of the proxy performs additional tasks such as logging, caching, or access\n * control before delegating the request to the real server.\n *\n * In the client code, we instantiate a ProxyServer object and send a request to it. The proxy intercepts\n * the request, performs any necessary processing, and then forwards the request to the real server.\n * Finally, it returns the response to the client.\n */\n"}]}],"patterns_proprietary":[{"title":"Module","description":[{"variant":"subtitle1","content":"The Module Pattern encapsulates \"privacy\", state, and organization using closures. It's commonly used in the JavaScript community due to its powerful ability to create private and public parts.\n"},{"variant":"h6","content":"Benefits"},{"variant":"subtitle1","content":"This pattern provides a way to encapsulate private members while exposing a public API. It also helps in organizing code into manageable sections.\n"}],"examples":[{"code":"namespace Module {\n    let privateVar: string = 'I am private...';\n\n    export function publicMethod() {\n        console.log(privateVar);\n    }\n}\n\nModule.publicMethod(); // Outputs: 'I am private...'\n"}]},{"title":"Mixin","description":[{"variant":"subtitle1","content":"JavaScript's object model includes features that allow it to mimic a classical inheritance pattern, known as Mixins. They allow objects to take on properties and methods from other objects.\n"},{"variant":"h6","content":"Benefits"},{"variant":"subtitle1","content":"Mixins help in avoiding the issues related to traditional inheritance and provide a way to add reusable functionalities to objects. They can be used to augment a class by adding multiple behaviors like event handling as mixins.\n"}],"examples":[{"code":"class Car {\n    constructor(public name: string) {}\n}\n\ninterface CarMixin {\n    revEngine(): void;\n}\n\nfunction applyMixin(targetClass: any, mixin: any) {\n    Object.getOwnPropertyNames(mixin.prototype).forEach(name => {\n        targetClass.prototype[name] = mixin.prototype[name];\n    });\n}\n\nclass SportsCarMixin implements CarMixin {\n    revEngine() {\n        console.log(`The ${this.name} goes vroom vroom!`);\n    }\n}\n\napplyMixin(Car, SportsCarMixin);\n\nlet raceCar = new Car(\"Ferrari\");\nraceCar.revEngine(); // Outputs: The Ferrari goes vroom vroom!\n"}]},{"title":"Publish/Subscribe","description":[{"variant":"subtitle1","content":"This pattern allows you to create modules that can communicate with each other over a single interface without knowing about each other's inner workings. It's a form of decoupling that can be incredibly useful for larger applications.\n"},{"variant":"h6","content":"Benefits"},{"variant":"subtitle1","content":"The pattern promotes loose coupling and enables better testability, maintainability, and scalability of the application. It's an essential pattern for building complex applications that require various modules to communicate with each other asynchronously.\n"}],"examples":[{"code":"type Handler<T> = (data: T) => void;\n\nclass PubSub<T> {\n    private topics: { [key: string]: Handler<T>[] } = {};\n\n    subscribe(topic: string, handler: Handler<T>): string {\n        if (!this.topics[topic]) {\n            this.topics[topic] = [];\n        }\n        const token = (Math.random() * 1000).toFixed(0);\n        this.topics[topic].push(handler);\n        return token;\n    }\n\n    publish(topic: string, data: T): void {\n        const handlers = this.topics[topic];\n        if (handlers) {\n            handlers.forEach(handler => handler(data));\n        }\n    }\n\n    unsubscribe(topic: string, token: string): void {\n        const handlers = this.topics[topic];\n        if (handlers) {\n            this.topics[topic] = handlers.filter(h => h.toString() !== token);\n        }\n    }\n}\n\nconst pubsub = new PubSub<string>();\n\nconst messageLogger: Handler<string> = (data: string) => {\n    console.log(`Logging: ${data}`);\n};\n\nconst subscription = pubsub.subscribe('inbox/newMessage', messageLogger);\n\npubsub.publish('inbox/newMessage', 'hello world!');\npubsub.publish('inbox/newMessage', 'test');\npubsub.publish('inbox/newMessage', 'another message');\n\npubsub.unsubscribe('inbox/newMessage', subscription);\n"}]},{"title":"Promise","description":[{"variant":"subtitle1","content":"With the advent of ES6, Promises are a model for asynchronous programming. Promises are a first-class representation of a value that may be made available in the future.\n"},{"variant":"h6","content":"Benefits"},{"variant":"subtitle1","content":"Promises provide a cleaner, more robust way of handling asynchronous operations compared to callbacks. They simplify error handling, improve readability and make it easier to write asynchronous code.\n"}],"examples":[{"code":"let promise = new Promise<string>((resolve, reject) => {\n    setTimeout(() => {\n        resolve('Hello world!');\n    }, 2000);\n});\n\npromise.then(value => {\n    console.log(value); // \"Hello world!\"\n}).catch(error => {\n    console.log(error);\n});\n"}]},{"title":"Type Guards","description":[{"variant":"subtitle1","content":"Type Guards are a TypeScript-specific pattern used to narrow down the type of a variable within a conditional block. They are particularly useful when dealing with union types or custom types.\n"},{"variant":"h6","content":"Benefits"},{"variant":"subtitle1","content":"Type Guards help ensure type safety by allowing developers to make assertions about the type of a variable within specific code blocks, reducing the likelihood of runtime errors.\n"}],"examples":[{"code":"function isString(value: any): value is string {\n    return typeof value === 'string';\n}\n\nfunction exampleFunction(value: string | number) {\n    if (isString(value)) {\n        // value is now narrowed down to type 'string'\n        console.log(value.toUpperCase());\n    } else {\n        // value is now narrowed down to type 'number'\n        console.log(value.toFixed(2));\n    }\n}\n\nexampleFunction(\"hello\"); // Outputs: HELLO\nexampleFunction(3.14159); // Outputs: 3.14\n"}]},{"title":"Conditional Types","description":[{"variant":"subtitle1","content":"Conditional Types are a feature introduced in TypeScript that allow types to be selected based on conditions. They are used to create flexible and reusable type definitions that adapt to different input types.\n"},{"variant":"h6","content":"Benefits"},{"variant":"subtitle1","content":"Conditional Types enable developers to create more dynamic and expressive type definitions, improving code readability and maintainability. They are especially useful in libraries and frameworks where generic types need to handle various scenarios.\n"}],"examples":[{"code":"type TypeName<T> =\n    T extends string ? \"string\" :\n    T extends number ? \"number\" :\n    T extends boolean ? \"boolean\" :\n    \"object\";\n\ntype StringOrNumber = TypeName<string | number>; // \"string\" | \"number\"\ntype StringOrBoolean = TypeName<string | boolean>; // \"string\" | \"boolean\"\n"}]},{"title":"Mapped Types","description":[{"variant":"subtitle1","content":"Mapped Types are a powerful feature of TypeScript that allow you to transform the properties of an existing type into a new type. They are often used to create new types based on existing ones, with modified or filtered properties.\n"},{"variant":"h6","content":"Benefits"},{"variant":"subtitle1","content":"Mapped Types provide a convenient way to create new types based on existing ones, reducing code duplication and improving type safety. They are particularly useful when working with complex data structures or APIs.\n"}],"examples":[{"code":"type Optional<T> = {\n    [P in keyof T]?: T[P];\n};\n\ninterface Person {\n    name: string;\n    age: number;\n}\n\ntype PartialPerson = Optional<Person>;\n\nconst partialPerson: PartialPerson = { name: \"John\" };\n"}]},{"title":"Nullish Coalescing Operator (??)","description":[{"variant":"subtitle1","content":"The Nullish Coalescing Operator (??) is a TypeScript feature that provides a concise way to handle null or undefined values by providing a default value if the variable is null or undefined.\n"},{"variant":"h6","content":"Benefits"},{"variant":"subtitle1","content":"The Nullish Coalescing Operator simplifies code by reducing the need for verbose null-checking expressions, making it easier to handle potentially null or undefined values in a concise and readable manner.\n"}],"examples":[{"code":"const name: string | null | undefined = null;\nconst displayName = name ?? \"Guest\";\nconsole.log(displayName); // Outputs: Guest\n"}]},{"title":"Optional Chaining Operator (?.)","description":[{"variant":"subtitle1","content":"The Optional Chaining Operator (?.) is a TypeScript feature that allows you to access properties or methods of an object without causing an error if the object is null or undefined.\n"},{"variant":"h6","content":"Benefits"},{"variant":"subtitle1","content":"The Optional Chaining Operator improves code robustness by gracefully handling null or undefined values, reducing the likelihood of runtime errors caused by accessing properties of non-existent objects.\n"}],"examples":[{"code":"interface User {\n    name?: string;\n    address?: {\n        city?: string;\n        zipCode?: string;\n    };\n}\n\nconst user: User = {};\n\nconst city = user.address?.city; // No error if address or city is null or undefined\nconsole.log(city); // Outputs: undefined\n"}]},{"title":"Discriminated Unions","description":[{"variant":"subtitle1","content":"Discriminated Unions are a TypeScript pattern used to model complex data structures with multiple possible shapes. They involve creating a union type with a common discriminant property to differentiate between the different shapes.\n"},{"variant":"h6","content":"Benefits"},{"variant":"subtitle1","content":"Discriminated Unions provide a type-safe way to work with complex data structures, ensuring that only valid shapes are allowed and enabling the TypeScript compiler to perform exhaustive type checking.\n"}],"examples":[{"code":"interface Square {\n    kind: \"square\";\n    size: number;\n}\n\ninterface Rectangle {\n    kind: \"rectangle\";\n    width: number;\n    height: number;\n}\n\ninterface Circle {\n    kind: \"circle\";\n    radius: number;\n}\n\ntype Shape = Square | Rectangle | Circle;\n\nfunction area(shape: Shape): number {\n    switch (shape.kind) {\n        case \"square\":\n            return shape.size * shape.size;\n        case \"rectangle\":\n            return shape.width * shape.height;\n        case \"circle\":\n            return Math.PI * shape.radius ** 2;\n    }\n}\n\nconst square: Shape = { kind: \"square\", size: 5 };\nconsole.log(area(square)); // Outputs: 25\n"}]},{"title":"Type Assertion","description":[{"variant":"subtitle1","content":"Type Assertion is a TypeScript feature that allows you to assert or override the type of a variable when you know more about its type than TypeScript can infer.\n"},{"variant":"h6","content":"Benefits"},{"variant":"subtitle1","content":"Type Assertion provides a way to tell the TypeScript compiler that you know the type of a variable better than it does, allowing you to access properties or methods that are not part of the inferred type.\n"}],"examples":[{"code":"let value: any = \"hello\";\nlet length: number = (value as string).length;\nconsole.log(length); // Outputs: 5\n"}]}]},"principles":{"principles_solid":[{"title":"Single Responsibility","examples":[{"title":"Good Example","codeFile":"principles/solid/single-responsibility/good-example","code":"// Employee class responsible only for storing employee data\nclass Employee {\n  constructor(private name: string, private position: string, private salary: number) { }\n\n  getName(): string {\n    return this.name;\n  }\n\n  getPosition(): string {\n    return this.position;\n  }\n\n  getSalary(): number {\n    return this.salary;\n  }\n}\n\n// Printer class responsible only for printing employee information\nclass EmployeePrinter {\n  print(employee: Employee): void {\n    console.log(`Name: ${employee.getName()}`);\n    console.log(`Position: ${employee.getPosition()}`);\n    console.log(`Salary: ${employee.getSalary()}`);\n  }\n}\n\n// Usage\nconst employee = new Employee(\"John Doe\", \"Software Engineer\", 50000);\nconst printer = new EmployeePrinter();\nprinter.print(employee);\n"},{"title":"Bad Example","codeFile":"principles/solid/single-responsibility/bad-example","code":"class Employee {\n  constructor(private name: string, private position: string, private salary: number) { }\n\n  // Method responsible for storing employee data and printing employee information\n  print(): void {\n    console.log(`Name: ${this.name}`);\n    console.log(`Position: ${this.position}`);\n    console.log(`Salary: ${this.salary}`);\n  }\n}\n\n// Usage\nconst employee = new Employee(\"John Doe\", \"Software Engineer\", 50000);\nemployee.print();\n"}]},{"title":"Open-Closed","examples":[{"title":"Good Example","codeFile":"principles/solid/open-closed/good-example","code":"class Shape {\n  computeArea(): number {\n    throw new Error('Must be implemented in subclasses');\n  }\n}\n\nclass Rectangle extends Shape {\n  constructor(private width: number, private height: number) { super(); }\n\n  computeArea(): number { return this.width * this.height; }\n}\n\nclass Circle extends Shape {\n  constructor(private radius: number) { super(); }\n\n  computeArea(): number { return Math.PI * Math.pow(this.radius, 2); }\n}\n"},{"title":"Bad Example","codeFile":"principles/solid/open-closed/bad-example","code":"class Rectangle {\n  width: number;\n  height: number;\n}\n\nclass Circle {\n  radius: number;\n}\n\nclass AreaCalculator {\n  computeArea(shape: any): number {\n    if (shape instanceof Rectangle) {\n      return shape.width * shape.height;\n    } else if (shape instanceof Circle) {\n      return Math.PI * shape.radius * shape.radius;\n    }\n\n    return 0;\n  }\n}\n"}]},{"title":"Liskov Substitution","examples":[{"title":"Good Example","codeFile":"principles/solid/liskov-substitution/good-example","code":"class Bird {\n  fly(): void {\n    console.log(\"Bird is flying\");\n  }\n}\n\nclass Duck extends Bird {\n  quack(): void {\n    console.log(\"Duck is quacking\");\n  }\n}\n\nclass Goose extends Bird {\n  swim(): void {\n    console.log(\"Penguin is swimming\");\n  }\n}\n\nfunction makeBirdFly(bird: Bird): void {\n  bird.fly();\n}\n\nconst duck = new Duck();\nconst penguin = new Goose();\n\nmakeBirdFly(duck);     // Output: Bird is flying\nmakeBirdFly(penguin);  // Output: Bird is flying\n"},{"title":"Bad Example","codeFile":"principles/solid/liskov-substitution/bad-example","code":"class Bird {\n  fly() { /* ... */ }\n}\n\nclass Ostrich extends Bird {\n  fly() {\n    throw new Error(\"Can't fly\");  // Ostrich, being a Bird, should not alter the expected behavior of the fly method\n  }\n}\n"}]},{"title":"Interface Segregation","examples":[{"title":"Good Example","codeFile":"principles/solid/interface-segregation/good-example","code":"interface Printer {\n  printDocument(): void;\n}\n\ninterface Fax {\n  faxDocument(): void;\n}\n\ninterface Scanner {\n  scanDocument(): void;\n}\n\nclass SimplePrinter implements Printer {\n  printDocument(): void {\n    console.log(\"Printing document...\");\n  }\n}\n\nclass MultifunctionalPrinter implements Printer, Fax, Scanner {\n  printDocument(): void {\n    console.log(\"Printing document...\");\n  }\n\n  faxDocument(): void {\n    console.log(\"Faxing document...\");\n  }\n\n  scanDocument(): void {\n    console.log(\"Scanning document...\");\n  }\n}\n"},{"title":"Bad Example","codeFile":"principles/solid/interface-segregation/bad-example","code":"interface Machine {\n  printDocument(): void;\n  faxDocument(): void;\n  scanDocument(): void;\n}\n\nclass OldPrinter implements Machine {\n  printDocument(): void {\n    console.log(\"Printing document...\");\n  }\n\n  faxDocument(): void {\n    throw new Error(\"This printer cannot fax documents.\");\n  }\n\n  scanDocument(): void {\n    throw new Error(\"This printer cannot scan documents.\");\n  }\n}\n"}]},{"title":"Dependency Inversion","examples":[{"title":"Good Example","codeFile":"principles/solid/interface-segregation/good-example","code":"interface Printer {\n  printDocument(): void;\n}\n\ninterface Fax {\n  faxDocument(): void;\n}\n\ninterface Scanner {\n  scanDocument(): void;\n}\n\nclass SimplePrinter implements Printer {\n  printDocument(): void {\n    console.log(\"Printing document...\");\n  }\n}\n\nclass MultifunctionalPrinter implements Printer, Fax, Scanner {\n  printDocument(): void {\n    console.log(\"Printing document...\");\n  }\n\n  faxDocument(): void {\n    console.log(\"Faxing document...\");\n  }\n\n  scanDocument(): void {\n    console.log(\"Scanning document...\");\n  }\n}\n"},{"title":"Bad Example","codeFile":"principles/solid/interface-segregation/bad-example","code":"interface Machine {\n  printDocument(): void;\n  faxDocument(): void;\n  scanDocument(): void;\n}\n\nclass OldPrinter implements Machine {\n  printDocument(): void {\n    console.log(\"Printing document...\");\n  }\n\n  faxDocument(): void {\n    throw new Error(\"This printer cannot fax documents.\");\n  }\n\n  scanDocument(): void {\n    throw new Error(\"This printer cannot scan documents.\");\n  }\n}\n"}]}],"principles_other":[{"title":"Don't Repeat Yourself (DRY)","examples":[{"title":"Good Example","codeFile":"principles/other/dry/good-example","code":"// Using default parameters and arrow functions for repeated logic\nconst addTax = (price: number, rate: number = 0.05): number => price + (price * rate);\n"},{"title":"Bad Example","codeFile":"principles/other/dry/bad-example","code":"const addTaxForFood = (price: number): number => price + (price * 0.05);\nconst addTaxForElectronics = (price: number): number => price + (price * 0.05);\n"}]},{"title":"Keep It Simple Stupid (KISS)","examples":[{"title":"Good Example","codeFile":"principles/other/kiss/good-example","code":"const isEven = (num: number): boolean => num % 2 === 0;\n"},{"title":"Bad Example","codeFile":"principles/other/kiss/bad-example","code":"// there is no need for absolute value here\nconst isEven = (num: number): boolean => num % Math.abs(2) === 0;\n"}]},{"title":"You Aren't Gonna Need It (YAGNI)","examples":[{"title":"Good Example","codeFile":"principles/other/yagni/good-example","code":"class Calculator {\n  add(a: number, b: number): number {\n    return a + b;\n  }\n}\n"},{"title":"Bad Example","codeFile":"principles/other/yagni/bad-example","code":"class Calculator {\n  add(a: number, b: number): number {\n    return a + b;\n  }\n\n  // Do not define methods unless they are used\n\n  multiply(a: number, b: number): number {\n    return a * b;\n  }\n\n  divide(a: number, b: number): number {\n    if (b === 0) {\n      throw new Error(\"Division by zero is not allowed.\");\n    }\n    return a / b;\n  }\n\n  subtract(a: number, b: number): number {\n    return a - b;\n  }\n}\n"}]},{"title":"Law of Demeter (Principle of Least Knowledge)","examples":[{"title":"Good Example","codeFile":"principles/other/yagni/good-example","code":"class Calculator {\n  add(a: number, b: number): number {\n    return a + b;\n  }\n}\n"},{"title":"Bad Example","codeFile":"principles/other/yagni/bad-example","code":"class Calculator {\n  add(a: number, b: number): number {\n    return a + b;\n  }\n\n  // Do not define methods unless they are used\n\n  multiply(a: number, b: number): number {\n    return a * b;\n  }\n\n  divide(a: number, b: number): number {\n    if (b === 0) {\n      throw new Error(\"Division by zero is not allowed.\");\n    }\n    return a / b;\n  }\n\n  subtract(a: number, b: number): number {\n    return a - b;\n  }\n}\n"}]},{"title":"Separation of Concerns","examples":[{"title":"Good Example","codeFile":"principles/other/separation/good-example","code":"// Authentication service\nclass AuthenticationService {\n  login(username: string, password: string): boolean {\n    // Authentication logic here\n    return true; // Dummy implementation\n  }\n\n  logout(): void {\n    // Logout logic here\n  }\n}\n\n// Data service\nclass DataService {\n  fetchData(): any[] {\n    // Data retrieval logic here\n    return []; // Dummy implementation\n  }\n}\n\n/**\n * - `AuthenticationService` and `DataService` are responsible for handling authentication and data retrieval, respectively.\n * - `UserController` and `DataController` serve as intermediaries between the HTTP layer (not shown) and the services.\n * - Each component has a single responsibility, promoting modularity, testability, and maintainability.\n *\n */\n\n// User controller\nclass UserController {\n  private authService: AuthenticationService;\n\n  constructor(authService: AuthenticationService) {\n    this.authService = authService;\n  }\n\n  loginUser(username: string, password: string): boolean {\n    return this.authService.login(username, password);\n  }\n\n  logoutUser(): void {\n    this.authService.logout();\n  }\n}\n\n// Data controller\nclass DataController {\n  private dataService: DataService;\n\n  constructor(dataService: DataService) {\n    this.dataService = dataService;\n  }\n\n  getData(): any[] {\n    return this.dataService.fetchData();\n  }\n}\n\n// Usage\nconst authService = new AuthenticationService();\nconst dataService = new DataService();\n\nconst userController = new UserController(authService);\nconst dataController = new DataController(dataService);\n\n// Simulate user login/logout\nuserController.loginUser(\"username\", \"password\");\nuserController.logoutUser();\n\n// Retrieve data\nconst data = dataController.getData();\nconsole.log(data);\n"},{"title":"Bad Example","codeFile":"principles/other/separation/bad-example","code":"// Authentication service\nclass AuthenticationService {\n  login(username: string, password: string): boolean {\n    // Authentication logic here\n    return true; // Dummy implementation\n  }\n\n  logout(): void {\n    // Logout logic here\n  }\n}\n\n// Data service\nclass DataService {\n  fetchData(): any[] {\n    // Data retrieval logic here\n    return []; // Dummy implementation\n  }\n}\n\n/**\n * - The `CombinedController` class is responsible for both user authentication and data retrieval.\n * - The loginUser method not only handles authentication but also retrieves user data directly\n *   from the `DataService`, violating the Single Responsibility Principle and mixing concerns.\n * - This violates the principle of Separation of Concerns and makes the code harder to maintain, test, and understand.\n */\nclass CombinedController {\n  private authService: AuthenticationService;\n  private dataService: DataService;\n\n  constructor(authService: AuthenticationService, dataService: DataService) {\n    this.authService = authService;\n    this.dataService = dataService;\n  }\n\n  loginUser(username: string, password: string): boolean {\n    // Authentication logic here\n    const isAuthenticated = this.authService.login(username, password);\n    if (isAuthenticated) {\n      // Retrieve user data (mixing concerns)\n      const userData = this.dataService.fetchData();\n      console.log(userData);\n    }\n    return isAuthenticated;\n  }\n\n  logoutUser(): void {\n    // Logout logic here\n    this.authService.logout();\n  }\n}\n\n// Usage\nconst authService = new AuthenticationService();\nconst dataService = new DataService();\n\nconst combinedController = new CombinedController(authService, dataService);\n\n// Simulate user login/logout\ncombinedController.loginUser(\"username\", \"password\");\ncombinedController.logoutUser();\n"}]}],"principles_proprietary":[{"title":"Static Typing","description":[{"variant":"subtitle1","content":"TypeScript provides static typing, allowing variables to be associated with specific types, helping catch type-related errors during development.\n"},{"variant":"subtitle1","content":"TypeScript does offer static typing, but it still retains the dynamic typing feature of JavaScript. Variables can be assigned values of different types at runtime.\n"}],"examples":[{"code":"llet data: number = 42; // data is now a number\n// data = 'hello'; // Error: Type '\"hello\"' is not assignable to type 'number'\ndata = 10; // Valid\n"}]},{"title":"Class-based Object Orientation","description":[{"variant":"subtitle1","content":"TypeScript supports classical inheritance with classes, allowing for more structured and organized code compared to prototype-based inheritance in JavaScript.\n"}],"examples":[{"code":"class Person {\n    constructor(private firstName: string) {}\n\n    sayHello(): string {\n        return `Hello, I'm ${this.firstName}`;\n    }\n}\n\nconst john = new Person(\"John\");\nconsole.log(john.sayHello()); // \"Hello, I'm John\"\n"}]},{"title":"First-Class Functions","description":[{"variant":"subtitle1","content":"In JavaScript, functions are first-class objects. They can be stored in variables, passed as arguments to other functions, returned from those functions, and have their own properties and methods.\n"},{"variant":"subtitle1","content":"Functions in TypeScript are still first-class objects, just like in JavaScript. They can be assigned to variables, passed as arguments, returned from other functions, and have properties and methods.\n"}],"examples":[{"code":"function greet() {\n  return \"Hello World!\";\n}\nlet greetMsg = greet; // Assigning function to variable\nconsole.log(greetMsg()); // \"Hello World!\"\n"}]},{"title":"Stronger Type System","description":[{"variant":"subtitle1","content":"TypeScript has a stronger type system compared to JavaScript, enabling better code quality and maintainability through type checking.\n"}],"examples":[{"code":"function add(x: number, y: number): number {\n    return x + y;\n}\n\nlet result: number = add(5, 10); // Valid\n// let result: string = add(5, 10); // Error: Type 'number' is not assignable to type 'string'\n"}]},{"title":"Enums","description":[{"variant":"subtitle1","content":"TypeScript provides enums to define a set of named constants, which can improve code readability and maintainability.\n"}],"examples":[{"code":"enum Color {\n    Red,\n    Green,\n    Blue,\n}\n\nlet color: Color = Color.Red;\nconsole.log(color); // 0\n"}]},{"title":"Type Inference","description":[{"variant":"subtitle1","content":"TypeScript can infer types based on context, reducing the need for explicit type annotations and making code more concise.\n"}],"examples":[{"code":"let message = \"Hello\"; // Type inference infers 'string' type\n// message = 10; // Error: Type 'number' is not assignable to type 'string'\n"}]},{"title":"Asynchronous Programming","description":[{"variant":"subtitle1","content":"With features like callbacks, promises, and async/await, JavaScript handles asynchronous operations. This is especially useful for operations like fetching data from a server without blocking the main thread.\n"},{"variant":"subtitle1","content":"TypeScript, being a superset of JavaScript, inherits its asynchronous programming features, including callbacks, promises, and async/await syntax for handling asynchronous operations.\n"}],"examples":[{"code":"async function fetchData() {\n  let response = await fetch('https://api.example.com/data');\n  let data = await response.json();\n  console.log(data);\n}\nfetchData();\n"}]},{"title":"Closure","description":[{"variant":"subtitle1","content":"Functions in TypeScript form closures just like in JavaScript. A closure is created when a function is defined within another function and has access to the outer function's variables.\n"}],"examples":[{"code":"function makeAdder(x) {\n  return function(y) {\n    return x + y;\n  };\n}\nlet add5 = makeAdder(5);\nconsole.log(add5(2));  // 7\n"}]},{"title":"Single-Threaded with Non-blocking I/O","description":[{"variant":"subtitle1","content":"TypeScript applications run in a single-threaded environment with an event loop, similar to JavaScript. Asynchronous operations such as setTimeout, fetch, and event handling ensure non-blocking I/O.\n"}],"examples":[{"code":"console.log('First');\nsetTimeout(function() {\n  console.log('Second');\n}, 0);\nconsole.log('Third');\n// Output: First, Third, Second\n"}]},{"title":"Truthy and Falsy Values","description":[{"variant":"subtitle1","content":"TypeScript, like JavaScript, evaluates values as truthy or falsy in conditional statements. Understanding truthy and falsy values is important for flow control in TypeScript code.\n"}],"examples":[{"code":"if ('') console.log('Falsy!');\nif ('hello') console.log('Truthy!');\n// Output: Truthy!\n"}]},{"title":"Template Literals","description":[{"variant":"subtitle1","content":"JavaScript allows for string interpolation and multi-line strings in a more readable fashion with template literals.\n"},{"variant":"subtitle1","content":"TypeScript supports template literals, providing a convenient way to create strings with embedded expressions. This feature enhances readability and maintainability of string formatting.\n"}],"examples":[{"code":"const name = \"world\";\nconsole.log(`Hello, ${name}!`); // Hello, world!\n"}]},{"title":"ES6 and Beyond Compatibility","description":[{"variant":"subtitle1","content":"TypeScript is designed to be compatible with modern ECMAScript features, including ES6 and beyond, providing access to advanced language capabilities while ensuring compatibility with older environments.\n"}],"examples":[{"code":"class Animal {\n    constructor(private name: string) {}\n\n    speak() {\n        console.log(`${this.name} makes a noise.`);\n    }\n}\n\nclass Dog extends Animal {\n    speak() {\n        console.log(`${this.name} barks.`);\n    }\n}\n\nlet dog = new Dog('Rex');\ndog.speak(); // Rex barks.\n"}]}]}}