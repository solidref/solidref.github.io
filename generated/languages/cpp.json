{"name":"C++","code":"cpp","ext":"cpp","birth":1985,"death":"N/A","inspiredBy":["c","simula","ada","algol 68","smalltalk","lisp","ml"],"inspiring":["java","c#","d","php","javascript","rust","swift"],"description":"C++ is a highly versatile and powerful programming language that extends the C programming language.\nCreated by Bjarne Stroustrup, it was designed for system and application software, high-performance server and client applications,\nand software engineering. C++ offers both high-level object-oriented programming features and low-level memory manipulation capabilities,\nmaking it suitable for developing operating systems, game engines, desktop apps, and much more. It supports multiple programming paradigms,\nincluding procedural, object-oriented, and generic programming. C++ is known for its efficiency and performance, which is why it's widely used\nin developing applications where performance is critical. Over the years, C++ has evolved significantly with the introduction of the Standard Template Library (STL),\nmodern syntax features, and improvements in performance and usability through its various versions (C++11, C++14, C++17, C++20, and the upcoming C++23).\nDespite its steep learning curve, C++ remains a foundational language that is crucial for systems programming, game development, and performance-critical applications.\n","patterns":{"patterns_behavioural":[{"title":"Chain Of Responsibility","examples":[{"title":"Example","codeFile":"patterns/behavioural/chain-of-responsibility/example","code":"#include <iostream>\n#include <memory>\n#include <string>\n\n// Define the interface for a support handler\nclass SupportHandler {\npublic:\n  virtual void setNextHandler(std::shared_ptr<SupportHandler> handler) = 0;\n  virtual std::string handleRequest(const std::string &request) = 0;\n  virtual ~SupportHandler() {}\n};\n\n// Concrete implementation of the SupportHandler interface for Level 1 support\nclass Level1Support : public SupportHandler {\nprivate:\n  std::shared_ptr<SupportHandler> nextHandler = nullptr;\n\npublic:\n  void setNextHandler(std::shared_ptr<SupportHandler> handler) override {\n    nextHandler = handler;\n  }\n\n  std::string handleRequest(const std::string &request) override {\n    if (request.find(\"basic\") != std::string::npos) {\n      return \"Level 1 Support: Issue resolved at basic level.\";\n    } else if (nextHandler != nullptr) {\n      return nextHandler->handleRequest(request);\n    } else {\n      return \"No more handlers in the chain\";\n    }\n  }\n};\n\n// Concrete implementation of the SupportHandler interface for Level 2 support\nclass Level2Support : public SupportHandler {\nprivate:\n  std::shared_ptr<SupportHandler> nextHandler = nullptr;\n\npublic:\n  void setNextHandler(std::shared_ptr<SupportHandler> handler) override {\n    nextHandler = handler;\n  }\n\n  std::string handleRequest(const std::string &request) override {\n    if (request.find(\"advanced\") != std::string::npos) {\n      return \"Level 2 Support: Issue resolved at advanced level.\";\n    } else if (nextHandler != nullptr) {\n      return nextHandler->handleRequest(request);\n    } else {\n      return \"No more handlers in the chain\";\n    }\n  }\n};\n\n// Concrete implementation of the SupportHandler interface for Level 3 support\nclass Level3Support : public SupportHandler {\npublic:\n  std::string handleRequest(const std::string &request) override {\n    if (request.find(\"bug\") != std::string::npos) {\n      return \"Level 3 Support: Issue resolved at development level.\";\n    } else {\n      return \"Level 3 Support: Unable to resolve the issue.\";\n    }\n  }\n\n  void setNextHandler(std::shared_ptr<SupportHandler> /*handler*/) override {\n    throw std::runtime_error(\"Level 3 Support is the highest level and does \"\n                             \"not have a next handler.\");\n  }\n};\n\n// Example usage\nint main() {\n  auto level1 = std::make_shared<Level1Support>();\n  auto level2 = std::make_shared<Level2Support>();\n  auto level3 = std::make_shared<Level3Support>();\n\n  level1->setNextHandler(level2);\n  level2->setNextHandler(level3);\n\n  std::cout << level1->handleRequest(\"Fix basic login issue\") << std::endl;\n  std::cout << level1->handleRequest(\"Debug advanced performance problem\")\n            << std::endl;\n  std::cout << level1->handleRequest(\n                   \"Investigate bug causing application crash\")\n            << std::endl;\n\n  return 0;\n}\n\n/**\n * This code demonstrates how the Chain of Responsibility pattern can be used in\n * a support ticket system. The SupportHandler interface defines the contract\n * for handling support requests, and concrete implementations (Level1Support,\n * Level2Support, and Level3Support) represent different levels of support. Each\n * handler decides whether it can handle a request or should pass it to the next\n * handler in the chain.\n */\n"},{"title":"Refined Example","codeFile":"patterns/behavioural/chain-of-responsibility/example-refined","code":"#include <iostream>\n#include <memory> // For std::shared_ptr and std::make_shared\n#include <string>\n\n// Abstract Handler: Defines an interface for handling requests and setting the\n// successor in the chain\nclass Handler {\npublic:\n  virtual ~Handler() {}\n\n  // Set the next handler in the chain\n  virtual void setNext(std::shared_ptr<Handler> handler) = 0;\n\n  // Handle request, to be implemented by concrete handlers\n  virtual std::string handle(const std::string &request) = 0;\n};\n\n// Concrete Handler 1\nclass ConcreteHandler1 : public Handler {\nprivate:\n  std::shared_ptr<Handler> nextHandler;\n\npublic:\n  void setNext(std::shared_ptr<Handler> handler) override {\n    nextHandler = handler;\n  }\n\n  std::string handle(const std::string &request) override {\n    // Check if this handler can handle the request\n    if (request == \"Operation1\") {\n      return \"ConcreteHandler1 handled the request\";\n    } else if (nextHandler) { // Pass to the next handler in the chain\n      return nextHandler->handle(request);\n    } else {\n      return \"Request not handled\";\n    }\n  }\n};\n\n// Concrete Handler 2\nclass ConcreteHandler2 : public Handler {\nprivate:\n  std::shared_ptr<Handler> nextHandler;\n\npublic:\n  void setNext(std::shared_ptr<Handler> handler) override {\n    nextHandler = handler;\n  }\n\n  std::string handle(const std::string &request) override {\n    if (request == \"Operation2\") {\n      return \"ConcreteHandler2 handled the request\";\n    } else if (nextHandler) {\n      return nextHandler->handle(request);\n    } else {\n      return \"Request not handled\";\n    }\n  }\n};\n\n// Example usage\nint main() {\n  // Creating the handlers\n  auto handler1 = std::make_shared<ConcreteHandler1>();\n  auto handler2 = std::make_shared<ConcreteHandler2>();\n\n  // Setting up the chain: Handler1 -> Handler2\n  handler1->setNext(handler2);\n\n  // Making requests\n  std::string request1 = \"Operation2\";\n  std::cout << handler1->handle(request1) << std::endl;\n\n  std::string request2 = \"UnknownOperation\";\n  std::cout << handler1->handle(request2) << std::endl;\n\n  return 0;\n}\n\n/**\n * Abstract Handler (Handler): This abstract base class declares the setNext\n * method for chaining handlers and the handle method for processing requests.\n * Concrete handlers must implement these methods.\n *\n * Concrete Handlers (ConcreteHandler1, ConcreteHandler2): These classes\n * implement the handling behavior for specific requests. If a handler cannot\n * process a request, it passes the request along the chain.\n *\n * Chain Setup: The main function demonstrates how to link handlers into a chain\n * (handler1 is linked to handler2). The chain can be extended easily by adding\n * more handlers and linking them together.\n *\n * Request Handling: Requests are passed to the first handler in the chain. Each\n * handler decides either to process the request or to pass it along to the next\n * handler in the chain.\n *\n * Flexibility and Decoupling: The Chain of Responsibility pattern allows for\n * the dynamic addition or removal of handlers from the chain, promoting\n * flexibility and decoupling the sender of a request from its receivers.\n */\n"}]},{"title":"Command","examples":[{"title":"Example","codeFile":"patterns/behavioural/command/example","code":"#include <iostream>\n#include <memory> // For std::unique_ptr\n#include <vector>\n\n// Define the Command interface\nclass Command {\npublic:\n  virtual void execute() = 0;\n  virtual ~Command() {}\n};\n\n// Receiver class that performs the actual actions\nclass Light {\npublic:\n  void turnOn() const { std::cout << \"Light is on\" << std::endl; }\n\n  void turnOff() const { std::cout << \"Light is off\" << std::endl; }\n};\n\n// Concrete command to turn on the light\nclass TurnOnCommand : public Command {\nprivate:\n  Light &light;\n\npublic:\n  TurnOnCommand(Light &light) : light(light) {}\n\n  void execute() override { light.turnOn(); }\n};\n\n// Concrete command to turn off the light\nclass TurnOffCommand : public Command {\nprivate:\n  Light &light;\n\npublic:\n  TurnOffCommand(Light &light) : light(light) {}\n\n  void execute() override { light.turnOff(); }\n};\n\n// Invoker class that triggers the commands\nclass RemoteControl {\nprivate:\n  std::vector<std::unique_ptr<Command>> commands;\n\npublic:\n  void addCommand(std::unique_ptr<Command> command) {\n    commands.push_back(std::move(command));\n  }\n\n  void executeCommands() {\n    for (const auto &command : commands) {\n      command->execute();\n    }\n  }\n};\n\n// Client code\nint main() {\n  Light light;\n\n  // Create a remote control and add the commands\n  RemoteControl remoteControl;\n  remoteControl.addCommand(std::make_unique<TurnOnCommand>(light));\n  remoteControl.addCommand(std::make_unique<TurnOffCommand>(light));\n\n  // Press the buttons on the remote control to execute the commands\n  remoteControl.executeCommands();\n\n  return 0;\n}\n\n/**\n * This code demonstrates how the Command pattern can be used in a remote\n * control system to control a light. The Command interface defines the contract\n * for executing commands, and concrete command classes (TurnOnCommand and\n * TurnOffCommand) encapsulate the actions to be performed on the Light receiver\n * object. The RemoteControl acts as the invoker, which holds and triggers the\n * commands. Pressing buttons on the remote control executes the corresponding\n * commands, resulting in the light being turned on and off.\n */\n"},{"title":"Refined Example","codeFile":"patterns/behavioural/command/example-refined","code":"#include <functional>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n\n// Command Interface\nclass Command {\npublic:\n  virtual void execute() = 0;\n  virtual void undo() = 0;\n  virtual ~Command() {}\n};\n\n// Receiver Class\nclass TextEditor {\n  std::string text;\n\npublic:\n  void addText(const std::string &newText) { text += newText; }\n\n  void deleteLastCharacter() {\n    if (!text.empty()) {\n      text.pop_back();\n    }\n  }\n\n  const std::string &getText() const { return text; }\n};\n\n// LambdaCommand adapts a lambda to the Command interface\nclass LambdaCommand : public Command {\n  std::function<void()> action;\n  std::function<void()> undoAction;\n\npublic:\n  LambdaCommand(std::function<void()> action, std::function<void()> undoAction)\n      : action(action), undoAction(undoAction) {}\n\n  void execute() override { action(); }\n\n  void undo() override { undoAction(); }\n};\n\nclass CommandManager {\n  std::vector<std::unique_ptr<Command>> history;\n\npublic:\n  void executeCommand(std::unique_ptr<Command> cmd) {\n    cmd->execute();\n    history.push_back(std::move(cmd));\n  }\n\n  void undo() {\n    if (!history.empty()) {\n      history.back()->undo();\n      history.pop_back();\n    }\n  }\n};\n\nint main() {\n  TextEditor editor;\n  CommandManager cmdManager;\n\n  // Add text command\n  cmdManager.executeCommand(std::make_unique<LambdaCommand>(\n      [&editor]() { editor.addText(\"Hello, \"); },\n      [&editor]() {\n        editor.deleteLastCharacter();\n        editor.deleteLastCharacter();\n      }));\n\n  // Add more text\n  cmdManager.executeCommand(\n      std::make_unique<LambdaCommand>([&editor]() { editor.addText(\"world!\"); },\n                                      [&editor]() {\n                                        for (int i = 0; i < 6; ++i)\n                                          editor.deleteLastCharacter();\n                                      }));\n\n  std::cout << \"Current Text: \" << editor.getText() << std::endl;\n\n  // Undo the last command\n  cmdManager.undo();\n  std::cout << \"After undo: \" << editor.getText() << std::endl;\n\n  // Undo again\n  cmdManager.undo();\n  std::cout << \"After another undo: \" << editor.getText() << std::endl;\n\n  return 0;\n}\n\n/**\n * TextEditor: Acts as the receiver with methods to manipulate the text.\n *\n * LambdaCommand: This is a flexible command class that can adapt any pair of\n * lambda expressions to the Command interface. It allows defining both the\n * action and its undo action inline.\n *\n * CommandManager: Acts as the invoker, executing commands and managing the\n * history for undo operations.\n *\n * Client Code: Demonstrates creating a text editor, executing commands to add\n * text, and undoing those commands.\n *\n * This example illustrates a powerful use of the Command Design Pattern in C++,\n * taking full advantage of lambda expressions for concise command definition\n * and smart pointers for automatic memory management, making it more aligned\n * with modern C++ idioms.\n */\n"}]},{"title":"Iterator","examples":[{"title":"Example","codeFile":"patterns/behavioural/iterator/example","code":"#include <iostream>\n#include <stdexcept> // For std::runtime_error\n#include <vector>\n\n// Define the Iterator interface\ntemplate <typename T> class Iterator {\npublic:\n  virtual bool hasNext() = 0;\n  virtual T next() = 0;\n  virtual ~Iterator() {}\n};\n\n// Concrete Iterator implementation for a vector\ntemplate <typename T> class VectorIterator : public Iterator<T> {\nprivate:\n  std::vector<T> array;\n  size_t index;\n\npublic:\n  VectorIterator(const std::vector<T> &array) : array(array), index(0) {}\n\n  bool hasNext() override { return index < array.size(); }\n\n  T next() override {\n    if (this->hasNext()) {\n      return array.at(index++); // Use at() for bounds checking\n    } else {\n      throw std::runtime_error(\"No more elements in the vector\");\n    }\n  }\n};\n\n// Define the Iterable interface\ntemplate <typename T> class Iterable {\npublic:\n  virtual Iterator<T> *createIterator() = 0;\n  virtual ~Iterable() {}\n};\n\n// Concrete Iterable implementation for a collection of books\nclass BookCollection : public Iterable<std::string> {\nprivate:\n  std::vector<std::string> books;\n\npublic:\n  void addBook(const std::string &book) { books.push_back(book); }\n\n  Iterator<std::string> *createIterator() override {\n    return new VectorIterator<std::string>(books);\n  }\n};\n\n// Example usage\nint main() {\n  // Create a collection of books\n  BookCollection bookCollection;\n  bookCollection.addBook(\"Book 1\");\n  bookCollection.addBook(\"Book 2\");\n  bookCollection.addBook(\"Book 3\");\n\n  // Iterate over the collection using the iterator\n  Iterator<std::string> *iterator = bookCollection.createIterator();\n  while (iterator->hasNext()) {\n    std::string book = iterator->next();\n    std::cout << \"Book: \" << book << std::endl;\n  }\n\n  delete iterator; // Clean up the dynamically allocated iterator\n\n  return 0;\n}\n\n/**\n * In this example, the Iterator pattern is used to iterate over a collection of\n * books stored in a BookCollection. The Iterator interface defines methods for\n * checking if there are more elements (hasNext) and retrieving the next element\n * (next). The ArrayIterator class provides a concrete implementation of the\n * iterator for an array of books. The BookCollection class implements the\n * Iterable interface, which allows it to create iterators for iterating over\n * its collection of books. Finally, in the client code, we create a\n * BookCollection, add books to it, and iterate over the collection using the\n * iterator, printing each book's name.\n */\n"},{"title":"Refined Example","codeFile":"patterns/behavioural/iterator/example-refined","code":"#include <iostream>\n#include <iterator> // For std::begin(), std::end()\n#include <string>\n#include <vector>\n\n// Custom container for a collection of books\nclass BookCollection {\nprivate:\n  std::vector<std::string> books;\n\npublic:\n  // Adds a book to the collection\n  void addBook(const std::string &book) { books.push_back(book); }\n\n  // Returns the beginning iterator of the collection\n  auto begin() const -> decltype(books.begin()) { return books.begin(); }\n\n  // Returns the end iterator of the collection\n  auto end() const -> decltype(books.end()) { return books.end(); }\n};\n\n// Example usage\nint main() {\n  BookCollection bookCollection;\n\n  // Add books to the collection\n  bookCollection.addBook(\"C++ Primer\");\n  bookCollection.addBook(\"Effective Modern C++\");\n  bookCollection.addBook(\"The C++ Programming Language\");\n\n  // Iterate over the collection using a range-based for loop\n  for (const auto &book : bookCollection) {\n    std::cout << \"Book: \" << book << std::endl;\n  }\n\n  return 0;\n}\n\n/**\n * Custom Container (BookCollection): A simple class that encapsulates a\n * std::vector<std::string> to store a collection of books. It provides addBook\n * method to add books to the collection.\n *\n * Native Iteration Support: Instead of manually defining an iterator interface\n * and concrete iterator classes, this example leverages the iterators provided\n * by the std::vector container. The begin() and end() methods return iterators\n * to the start and end of the books vector, respectively.\n *\n * Range-based For Loop: The example utilizes a range-based for loop for\n * iteration, a feature introduced in C++11 that allows iterating over any\n * container that provides begin() and end() methods returning iterators. This\n * feature significantly simplifies code compared to manually managing iterator\n * objects.\n */\n"}]},{"title":"Mediator","examples":[{"title":"Example","codeFile":"patterns/behavioural/mediator/example","code":"#include <iostream>\n#include <string>\n\n// Forward declaration\nclass User;\n\n// Define the Mediator interface\nclass ChatMediator {\npublic:\n  virtual void sendMessage(const std::string &message, User *user) = 0;\n  virtual ~ChatMediator() {}\n};\n\n// Concrete Mediator implementation for a chat room\nclass ChatRoom : public ChatMediator {\npublic:\n  void sendMessage(const std::string &message, User *user) override;\n};\n\n// Define the Colleague (User) interface\nclass User {\nprotected:\n  std::string name;\n  ChatMediator *mediator;\n\npublic:\n  User(const std::string &name, ChatMediator *mediator)\n      : name(name), mediator(mediator) {}\n  virtual void send(const std::string &message) = 0;\n  virtual void receive(const std::string &message) = 0;\n  std::string getName() const { return name; }\n  virtual ~User() {}\n};\n\n// Implement sendMessage to avoid incomplete type error\nvoid ChatRoom::sendMessage(const std::string &message, User *user) {\n  std::cout << \"[\" << user->getName() << \"] sends message: \" << message\n            << std::endl;\n}\n\n// Concrete Colleague implementation for a chat user\nclass ChatUser : public User {\npublic:\n  ChatUser(const std::string &name, ChatMediator *mediator)\n      : User(name, mediator) {}\n\n  void send(const std::string &message) override {\n    std::cout << \"[\" << this->name << \"] sends message: \" << message\n              << std::endl;\n    mediator->sendMessage(message, this);\n  }\n\n  void receive(const std::string &message) override {\n    std::cout << \"[\" << this->name << \"] received message: \" << message\n              << std::endl;\n  }\n};\n\n// Client code\nint main() {\n  ChatRoom chatMediator;\n\n  ChatUser user1(\"User1\", &chatMediator);\n  ChatUser user2(\"User2\", &chatMediator);\n\n  user1.send(\"Hello, User2!\");\n  user2.send(\"Hi, User1!\");\n\n  return 0;\n}\n\n/**\n * In this example, the Mediator pattern is used to facilitate communication\n * between users in a chat room. The ChatMediator interface defines a method\n * sendMessage for sending messages to users. The ChatRoom class provides a\n * concrete implementation of the mediator for managing communication between\n * users in the chat room.\n *\n * The User interface defines methods send and receive for sending and receiving\n * messages, respectively, as well as a method getName for getting the user's\n * name. The ChatUser class implements the User interface and interacts with the\n * mediator to send and receive messages.\n *\n * In the client code, we create a chat room mediator and two chat users. Users\n * can send messages to each other by calling the send method, which delegates\n * the message sending to the mediator. When a message is received, the mediator\n * distributes it to the appropriate user's receive method.\n */\n"},{"title":"Refined Example","codeFile":"patterns/behavioural/mediator/example-refined","code":"#include <iostream>\n#include <memory>\n#include <string>\n#include <unordered_map>\n\nclass User;\n\n// Mediator Interface\nclass ChatMediator {\npublic:\n  virtual void addUser(std::shared_ptr<User> user) = 0;\n  virtual void sendMessage(const std::string &message,\n                           const std::string &userId) = 0;\n  virtual ~ChatMediator() {}\n};\n\n// Colleague Interface\nclass User {\nprotected:\n  std::string id;\n  std::shared_ptr<ChatMediator> mediator;\n\npublic:\n  User(const std::string &id, std::shared_ptr<ChatMediator> mediator)\n      : id(id), mediator(mediator) {}\n  virtual void send(const std::string &message) = 0;\n  virtual void receive(const std::string &message) const = 0;\n  std::string getId() const { return id; }\n  virtual ~User() {}\n};\n\n/** Concrete Mediator */\n\nclass ConcreteChatMediator : public ChatMediator {\n  std::unordered_map<std::string, std::shared_ptr<User>> users;\n\npublic:\n  void addUser(std::shared_ptr<User> user) override {\n    users[user->getId()] = user;\n  }\n\n  void sendMessage(const std::string &message,\n                   const std::string &userId) override {\n    auto it = users.find(userId);\n    if (it != users.end()) {\n      it->second->receive(message);\n    } else {\n      std::cout << \"User \" << userId << \" not found in chat.\" << std::endl;\n    }\n  }\n};\n\n/** Concrete Colleague */\n\nclass ConcreteUser : public User {\npublic:\n  using User::User; // Inherit constructors\n\n  void send(const std::string &message) override {\n    std::cout << \"Sending from \" << id << \": \" << message << std::endl;\n    mediator->sendMessage(message, id);\n  }\n\n  void receive(const std::string &message) const override {\n    std::cout << id << \" received: \" << message << std::endl;\n  }\n};\n\nint main() {\n  auto mediator = std::make_shared<ConcreteChatMediator>();\n\n  auto user1 = std::make_shared<ConcreteUser>(\"User1\", mediator);\n  auto user2 = std::make_shared<ConcreteUser>(\"User2\", mediator);\n\n  mediator->addUser(user1);\n  mediator->addUser(user2);\n\n  user1->send(\"Hello from User1 to User2\");\n  user2->send(\"Hello from User2 to User1\");\n\n  // Attempt to send a message to an unknown user\n  mediator->sendMessage(\"This is a test\", \"UnknownUser\");\n\n  return 0;\n}\n\n/**\n * Separation of Concerns: The ChatMediator handles the registration of users\n * and the routing of messages, whereas the User class focuses on sending and\n * receiving messages.\n *\n * Loose Coupling: Users communicate through the mediator without knowing about\n * each other's existence, making it easier to add new user types without\n * affecting existing code.\n *\n * Scalability: The mediator can manage any number of users, facilitating direct\n * or broadcast messaging as needed.\n *\n * Flexibility: The design allows for different types of users and mediators to\n * be introduced with minimal changes to the existing system.\n *\n * This example better showcases the Mediator Design Pattern's capabilities in\n * C++, leveraging smart pointers for memory management and providing a more\n * complex scenario that highlights the pattern's benefits.\n */\n"}]},{"title":"Memento","examples":[{"title":"Example","codeFile":"patterns/behavioural/memento/example","code":"#include <iostream>\n#include <memory> // For smart pointers\n#include <vector>\n\n// Forward declaration\nclass Memento;\n\n// Originator class\nclass Editor {\n  std::string text;\n\npublic:\n  Editor(const std::string &text) : text(text) {}\n\n  void setText(const std::string &newText) { text = newText; }\n\n  std::string getText() const { return text; }\n\n  std::shared_ptr<Memento> save() const;\n  void restore(const std::shared_ptr<Memento> &memento);\n};\n\n// Memento class\nclass Memento {\n  std::string state;\n\n  // Make Editor a friend class to allow it to access the private constructor\n  friend class Editor;\n\n  Memento(const std::string &state) : state(state) {}\n\npublic:\n  std::string getState() const { return state; }\n};\n\n// Implementations of Editor's methods that depend on Memento\nstd::shared_ptr<Memento> Editor::save() const {\n  return std::make_shared<Memento>(text);\n}\n\nvoid Editor::restore(const std::shared_ptr<Memento> &memento) {\n  text = memento->getState();\n}\n\n// Caretaker class\nclass History {\n  std::vector<std::shared_ptr<Memento>> mementos;\n\npublic:\n  void addMemento(const std::shared_ptr<Memento> &memento) {\n    mementos.push_back(memento);\n  }\n\n  std::shared_ptr<Memento> getLatestMemento() const {\n    if (mementos.empty()) {\n      throw std::runtime_error(\"No mementos available\");\n    }\n    return mementos.back();\n  }\n};\n\n// Client code\nint main() {\n  Editor editor(\"Initial text\");\n  History history;\n\n  history.addMemento(editor.save()); // Save initial state\n\n  editor.setText(\"Modified text\");\n  history.addMemento(editor.save()); // Save modified state\n\n  // Restore the editor's state to the most recent memento\n  editor.restore(history.getLatestMemento());\n  std::cout << editor.getText() << std::endl; // Output: Modified text\n\n  return 0;\n}\n\n/**\n * In this example, the Editor class represents an object whose state can be\n * modified. The save method creates a memento containing the current state of\n * the editor, and the restore method restores the editor's state from a given\n * memento.\n *\n * The Memento class represents the stored state of the editor at a particular\n * point in time.\n *\n * The History class is responsible for maintaining a list of mementos. It\n * provides methods to add a memento to the history and retrieve the most recent\n * memento.\n *\n * In the client code, we create an editor object and a history object. We\n * modify the editor's state, save it to a memento, modify it again, and then\n * restore it to the previous state using the memento stored in the history.\n */\n"},{"title":"Refined Example","codeFile":"patterns/behavioural/memento/example-refined","code":"#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n\n/**\n * Editor (Originator)\n * The Editor class represents the originator that maintains the current text\n * state and can create and restore mementos of its state.\n */\n\nclass Memento {\n  friend class Editor;\n  std::string state;\n\n  explicit Memento(const std::string &s) : state(s) {}\n\npublic:\n  std::string getState() const { return state; }\n};\n\nclass Editor {\n  std::string text;\n\npublic:\n  void type(const std::string &words) { text += words; }\n\n  std::shared_ptr<Memento> save() { return std::make_shared<Memento>(text); }\n\n  void restore(const std::shared_ptr<Memento> &memento) {\n    text = memento->getState();\n  }\n\n  void print() const { std::cout << \"Editor content: \" << text << std::endl; }\n};\n\n/**\n * Caretaker\n * The Caretaker class is responsible for keeping the history of mementos,\n * allowing the user to undo changes.\n */\n\nclass Caretaker {\n  Editor &editor;\n  std::vector<std::shared_ptr<Memento>> history;\n  size_t current;\n\npublic:\n  explicit Caretaker(Editor &editor) : editor(editor), current(0) {}\n\n  void backup() {\n    while (history.size() > current) {\n      history.pop_back();\n    }\n    history.push_back(editor.save());\n    current++;\n  }\n\n  bool undo() {\n    if (current == 0) {\n      return false;\n    }\n    current--;\n    editor.restore(history[current]);\n    return true;\n  }\n\n  bool redo() {\n    if (current + 1 >= history.size()) {\n      return false;\n    }\n    editor.restore(history[++current]);\n    return true;\n  }\n};\n\nint main() {\n  Editor editor;\n  Caretaker caretaker(editor);\n\n  editor.type(\"This is the first sentence.\");\n  caretaker.backup();\n\n  editor.type(\" This is the second sentence.\");\n  caretaker.backup();\n\n  editor.type(\" This is the third sentence.\");\n  editor.print();\n\n  std::cout << \"Undoing...\\n\";\n  caretaker.undo();\n  editor.print();\n\n  std::cout << \"Undoing...\\n\";\n  caretaker.undo();\n  editor.print();\n\n  std::cout << \"Redoing...\\n\";\n  caretaker.redo();\n  editor.print();\n\n  return 0;\n}\n\n/**\n * Memento: Encapsulates the state of the Editor. Access to its constructor is\n * restricted to the Editor by making it a friend class, ensuring that only the\n * Editor can create mementos.\n *\n * Editor (Originator): Manages the current state and can create and restore\n * snapshots of its state through mementos.\n *\n * Caretaker: Manages the timeline of states by keeping a history of mementos.\n * It provides backup, undo, and redo operations to control the state of the\n * Editor.\n */\n"}]},{"title":"Observer","examples":[{"title":"Example","codeFile":"patterns/behavioural/observer/example","code":"#include <algorithm>\n#include <iostream>\n#include <memory>\n#include <vector>\n\n// Forward declaration for Observer to resolve circular dependency\nclass Observer;\n\n// Subject Interface\nclass Subject {\npublic:\n  virtual void subscribe(std::shared_ptr<Observer> observer) = 0;\n  virtual void unsubscribe(std::shared_ptr<Observer> observer) = 0;\n  virtual void notify(const std::string &data) = 0;\n  virtual ~Subject() {}\n};\n\n// Observer Interface\nclass Observer {\npublic:\n  virtual void update(const std::string &data) = 0;\n  virtual ~Observer() {}\n};\n\n// Concrete Subject\nclass ConcreteSubject : public Subject {\n  std::vector<std::shared_ptr<Observer>> observers;\n\npublic:\n  void subscribe(std::shared_ptr<Observer> observer) override {\n    observers.push_back(observer);\n  }\n\n  void unsubscribe(std::shared_ptr<Observer> observer) override {\n    observers.erase(std::remove(observers.begin(), observers.end(), observer),\n                    observers.end());\n  }\n\n  void notify(const std::string &data) override {\n    for (auto &observer : observers) {\n      observer->update(data);\n    }\n  }\n};\n\n// Concrete Observer\nclass ConcreteObserver : public Observer {\npublic:\n  void update(const std::string &data) override {\n    std::cout << \"Observer received data: \" << data << std::endl;\n  }\n};\n\n// Client code\nint main() {\n  auto subject = std::make_shared<ConcreteSubject>();\n  auto observer1 = std::make_shared<ConcreteObserver>();\n  auto observer2 = std::make_shared<ConcreteObserver>();\n\n  subject->subscribe(observer1);\n  subject->subscribe(observer2);\n\n  subject->notify(\"Hello Observers!\");\n\n  subject->unsubscribe(observer2);\n  subject->notify(\"Goodbye Observers!\");\n\n  return 0;\n}\n\n/**\n * In this example, the Editor class represents an object whose state can be\n * modified. The save method creates a memento containing the current state of\n * the editor, and the restore method restores the editor's state from a given\n * memento.\n *\n * The Memento class represents the stored state of the editor at a particular\n * point in time. The History class is responsible for maintaining a list of\n * mementos. It provides methods to add a memento to the history and retrieve\n * the most recent memento.\n *\n * In the client code, we create an editor object and a history object. We\n * modify the editor's state, save it to a memento, modify it again, and then\n * restore it to the previous state using the memento stored in the history.\n */\n"},{"title":"Refined Example","codeFile":"patterns/behavioural/observer/example-refined","code":"#include <functional>\n#include <iostream>\n#include <memory>\n#include <string>\n#include <unordered_map>\n#include <vector>\n\n// Observer Interface\n\nclass INotification {\npublic:\n  virtual ~INotification() = default;\n};\n\nclass NotificationA : public INotification {\npublic:\n  void message() const { std::cout << \"Notification A message\" << std::endl; }\n};\n\nclass NotificationB : public INotification {\npublic:\n  void message() const { std::cout << \"Notification B message\" << std::endl; }\n};\n\n// Subject Interface\n\nclass ISubject {\npublic:\n  virtual void\n  subscribe(const std::string &notificationType,\n            std::function<void(std::shared_ptr<INotification>)> observer) = 0;\n  virtual void unsubscribe(const std::string &notificationType) = 0;\n  virtual void notify(const std::string &notificationType,\n                      std::shared_ptr<INotification> notification) = 0;\n  virtual ~ISubject() {}\n};\n\nclass Subject : public ISubject {\n  std::unordered_map<\n      std::string,\n      std::vector<std::function<void(std::shared_ptr<INotification>)>>>\n      observers;\n\npublic:\n  void subscribe(\n      const std::string &notificationType,\n      std::function<void(std::shared_ptr<INotification>)> observer) override {\n    observers[notificationType].push_back(observer);\n  }\n\n  void unsubscribe(const std::string &notificationType) override {\n    observers.erase(notificationType);\n  }\n\n  void notify(const std::string &notificationType,\n              std::shared_ptr<INotification> notification) override {\n    if (observers.find(notificationType) != observers.end()) {\n      for (auto &observer : observers[notificationType]) {\n        observer(notification);\n      }\n    }\n  }\n};\n\nint main() {\n  Subject subject;\n\n  // Subscribe to NotificationA\n  subject.subscribe(\n      \"NotificationA\", [](std::shared_ptr<INotification> notification) {\n        auto notif = std::dynamic_pointer_cast<NotificationA>(notification);\n        if (notif) {\n          notif->message();\n        }\n      });\n\n  // Subscribe to NotificationB\n  subject.subscribe(\n      \"NotificationB\", [](std::shared_ptr<INotification> notification) {\n        auto notif = std::dynamic_pointer_cast<NotificationB>(notification);\n        if (notif) {\n          notif->message();\n        }\n      });\n\n  // Notify observers\n  subject.notify(\"NotificationA\", std::make_shared<NotificationA>());\n  subject.notify(\"NotificationB\", std::make_shared<NotificationB>());\n\n  return 0;\n}\n\n/**\n * Generic Notification System: The example demonstrates a flexible notification\n * system where observers can subscribe to specific types of notifications.\n *\n * Use of std::function for Callbacks: This allows observers to subscribe using\n * any callable that matches the signature, including free functions, member\n * functions, lambdas, and functors.\n *\n * Type-Safe Notifications: Observers can dynamically cast the notification to\n * the expected type, allowing for type-safe handling of different notification\n * types.\n *\n * Modern C++ Features: Leveraging std::shared_ptr for automatic memory\n * management, std::function for flexible callbacks, and std::unordered_map for\n * efficiently managing subscriptions.\n */\n"}]},{"title":"State","examples":[{"title":"Example","codeFile":"patterns/behavioural/state/example","code":"#include <iostream>\n#include <memory>\n\nclass TrafficLight; // Forward declaration\n\n// Abstract class defining the common behavior for all traffic light states\nclass TrafficLightState {\npublic:\n  virtual void changeState(TrafficLight &trafficLight) = 0;\n  virtual ~TrafficLightState() {}\n};\n\n// Forward declaration of concrete states\nclass RedState;\nclass YellowState;\nclass GreenState;\n\n// Context class representing the traffic light\nclass TrafficLight {\n  std::shared_ptr<TrafficLightState> state;\n\npublic:\n  TrafficLight()\n      : state(std::make_shared<RedState>()) {} // Initial state is Red\n\n  void setState(std::shared_ptr<TrafficLightState> newState) {\n    state = newState;\n    state->changeState(*this);\n  }\n};\n\n// Concrete state representing the \"Red\" state of the traffic light\nclass RedState : public TrafficLightState {\npublic:\n  void changeState(TrafficLight &trafficLight) override {\n    std::cout << \"Traffic light is now RED. Stop!\" << std::endl;\n    // Transition to YellowState would go here\n  }\n};\n\n// Concrete state representing the \"Yellow\" state of the traffic light\nclass YellowState : public TrafficLightState {\npublic:\n  void changeState(TrafficLight &trafficLight) override {\n    std::cout << \"Traffic light is now YELLOW. Prepare to stop or proceed with \"\n                 \"caution.\"\n              << std::endl;\n    // Transition to GreenState would go here\n  }\n};\n\n// Concrete state representing the \"Green\" state of the traffic light\nclass GreenState : public TrafficLightState {\npublic:\n  void changeState(TrafficLight &trafficLight) override {\n    std::cout << \"Traffic light is now GREEN. Go!\" << std::endl;\n    // Transition to RedState would go here\n  }\n};\n\nint main() {\n  TrafficLight trafficLight;\n\n  // Simulate traffic light behavior by changing its state\n  // Note: In the real world, the state transitions would be triggered by the\n  // states themselves or external events, not directly like this\n  trafficLight.setState(std::make_shared<GreenState>());\n  trafficLight.setState(std::make_shared<YellowState>());\n  trafficLight.setState(std::make_shared<RedState>());\n\n  return 0;\n}\n\n/**\n * The TrafficLightState interface defines the common behavior for all traffic\n * light states. Each concrete state implements this interface and provides its\n * own implementation of the changeState method.\n *\n * Concrete state classes (RedState, YellowState, and GreenState) represent\n * different states of the traffic light and define how the traffic light\n * behaves in each state.\n *\n * The TrafficLight class acts as the context and maintains a reference to the\n * current state. It provides a method setState to change the state of the\n * traffic light.\n *\n * In the client code, we create a TrafficLight object and change its state to\n * simulate the behavior of a traffic light system.\n */\n"},{"title":"Refined Example","codeFile":"patterns/behavioural/state/example-refined","code":"#include <chrono>\n#include <iostream>\n#include <memory>\n#include <thread>\n\nclass TrafficLight;\n\n// Abstract State class\nclass TrafficLightState {\npublic:\n  virtual void enter(TrafficLight &light) = 0;\n  virtual ~TrafficLightState() {}\n};\n\n// Forward declarations of concrete state classes to resolve circular dependency\nclass RedState;\nclass YellowState;\nclass GreenState;\n\nclass TrafficLight {\n  std::shared_ptr<TrafficLightState> state;\n\npublic:\n  TrafficLight() : state(nullptr) {}\n  void changeState(std::shared_ptr<TrafficLightState> newState) {\n    state = newState;\n    state->enter(*this);\n  }\n  void setState(std::shared_ptr<TrafficLightState> newState) {\n    state = newState;\n  }\n};\n\n// Concrete State Classes\n\n// Red State\nclass RedState : public TrafficLightState {\npublic:\n  void enter(TrafficLight &light) override {\n    std::cout << \"Red Light - STOP\" << std::endl;\n    std::this_thread::sleep_for(std::chrono::seconds(3)); // Simulate time delay\n    light.changeState(std::make_shared<YellowState>());\n  }\n};\n\n// Yellow State\nclass YellowState : public TrafficLightState {\npublic:\n  void enter(TrafficLight &light) override {\n    std::cout << \"Yellow Light - PREPARE\" << std::endl;\n    std::this_thread::sleep_for(std::chrono::seconds(2)); // Simulate time delay\n    light.changeState(std::make_shared<GreenState>());\n  }\n};\n\n// Green State\nclass GreenState : public TrafficLightState {\npublic:\n  void enter(TrafficLight &light) override {\n    std::cout << \"Green Light - GO\" << std::endl;\n    std::this_thread::sleep_for(std::chrono::seconds(4)); // Simulate time delay\n    light.changeState(std::make_shared<RedState>());\n  }\n};\n\nint main() {\n  TrafficLight light;\n  light.changeState(std::make_shared<RedState>());\n\n  // The loop will continue indefinitely, simulating the continuous operation\n  // of a traffic light. In a real application, you might want to provide a\n  // mechanism to stop the system gracefully.\n  return 0;\n}\n\n/**\n * Encapsulation of State and Behavior: Each state class (RedState, YellowState,\n * GreenState) encapsulates both the behavior of the traffic light in that state\n * and the logic for transitioning to the next state.\n *\n * Use of Smart Pointers: The example uses std::shared_ptr for state management,\n * simplifying memory management and ownership semantics.\n *\n * Simulated Time Delays: Utilizes std::this_thread::sleep_for along with\n * std::chrono::seconds to introduce realistic delays between state transitions,\n * mimicking the operation of an actual traffic light system.\n *\n * This C++ example showcases a practical application of the State Design\n * Pattern, where state transitions are self-managed by each state, providing a\n * clean and modular design that isolates state-specific logic within separate\n * classes.\n */\n"}]},{"title":"Strategy","examples":[{"title":"Example","codeFile":"patterns/behavioural/strategy/example","code":"// Payment Strategy Interface and Concrete Strategies\n\n#include <iostream>\n#include <memory>\n#include <string>\n\n// Abstract class defining the common behavior for all payment strategies\nclass PaymentStrategy {\npublic:\n  virtual void pay(int amount) const = 0;\n  virtual ~PaymentStrategy() {}\n};\n\n// Concrete strategy for processing payments via credit card\nclass CreditCardPaymentStrategy : public PaymentStrategy {\n  std::string cardNumber;\n  std::string expiryDate;\n  std::string cvv;\n\npublic:\n  CreditCardPaymentStrategy(const std::string &cardNumber,\n                            const std::string &expiryDate,\n                            const std::string &cvv)\n      : cardNumber(cardNumber), expiryDate(expiryDate), cvv(cvv) {}\n\n  void pay(int amount) const override {\n    std::cout << \"Processing credit card payment of $\" << amount\n              << \" with card number \" << cardNumber << std::endl;\n    // Logic to process payment via credit card\n  }\n};\n\n// Concrete strategy for processing payments via PayPal\nclass PayPalPaymentStrategy : public PaymentStrategy {\n  std::string email;\n  std::string password;\n\npublic:\n  PayPalPaymentStrategy(const std::string &email, const std::string &password)\n      : email(email), password(password) {}\n\n  void pay(int amount) const override {\n    std::cout << \"Processing PayPal payment of $\" << amount << \" with email \"\n              << email << std::endl;\n    // Logic to process payment via PayPal\n  }\n};\n\n// Payment Processor Context Class\n\nclass PaymentProcessor {\n  std::shared_ptr<PaymentStrategy> paymentStrategy;\n\npublic:\n  // Setter method to set the payment strategy dynamically\n  void setPaymentStrategy(const std::shared_ptr<PaymentStrategy> &strategy) {\n    paymentStrategy = strategy;\n  }\n\n  // Method to process payment using the selected strategy\n  void processPayment(int amount) const {\n    if (paymentStrategy) {\n      paymentStrategy->pay(amount);\n    } else {\n      std::cout << \"Payment strategy not set. Please select a payment method.\"\n                << std::endl;\n    }\n  }\n};\n\nint main() {\n  PaymentProcessor paymentProcessor;\n\n  // Select a payment method (strategy) dynamically\n  auto creditCardStrategy = std::make_shared<CreditCardPaymentStrategy>(\n      \"1234 5678 9012 3456\", \"12/25\", \"123\");\n  paymentProcessor.setPaymentStrategy(creditCardStrategy);\n  paymentProcessor.processPayment(100);\n\n  // Change payment method (strategy)\n  auto payPalStrategy = std::make_shared<PayPalPaymentStrategy>(\n      \"example@example.com\", \"password\");\n  paymentProcessor.setPaymentStrategy(payPalStrategy);\n  paymentProcessor.processPayment(50);\n\n  return 0;\n}\n\n/**\n * The PaymentStrategy interface defines the common behavior for all payment\n * strategies. Each concrete payment strategy class implements this interface\n * and provides its own implementation of the pay method.\n *\n * Concrete strategy classes (CreditCardPaymentStrategy and\n * PayPalPaymentStrategy) represent different payment methods and define how\n * payments are processed for each method.\n *\n * The PaymentProcessor class acts as the context and maintains a reference to\n * the current payment strategy. It provides a setter method setPaymentStrategy\n * to dynamically set the payment strategy, and a processPayment method to\n * process payments using the selected strategy.\n *\n * In the client code, we create a PaymentProcessor object and dynamically\n * select the payment method (strategy) based on user input. We then process\n * payments using the selected strategy.\n *\n */\n"},{"title":"Refined Example","codeFile":"patterns/behavioural/strategy/example-refined","code":"// Strategy Interface Using std::function\n// Instead of defining a traditional interface with virtual methods, we'll use\n// std::function to hold any callable that matches the strategy's signature.\n\n#include <functional>\n#include <iostream>\n#include <string>\n\n// Strategy signature as std::function\nusing PaymentStrategy = std::function<void(const std::string &, double)>;\n\n// Context Class\n// The context class will use a PaymentStrategy to process payments. It can\n// dynamically change the strategy at runtime.\n\nclass PaymentProcessor {\nprivate:\n  PaymentStrategy strategy;\n\npublic:\n  // Constructor for initializing with a default strategy, if desired\n  explicit PaymentProcessor(const PaymentStrategy &strategy = nullptr)\n      : strategy(strategy) {}\n\n  // Method to set the payment strategy dynamically\n  void setPaymentStrategy(const PaymentStrategy &newStrategy) {\n    strategy = newStrategy;\n  }\n\n  // Method to process payment using the selected strategy\n  void processPayment(const std::string &account, double amount) const {\n    if (strategy) {\n      strategy(account, amount);\n    } else {\n      std::cerr << \"Payment strategy not set. Please select a payment method.\"\n                << std::endl;\n    }\n  }\n};\n\n// Defining Concrete Strategies\n// Concrete strategies can be defined inline using lambdas, function objects, or\n// regular functions, providing great flexibility.\n\n// Example strategies\nauto creditCardPayment = [](const std::string &cardNumber, double amount) {\n  std::cout << \"Processing credit card payment of $\" << amount\n            << \" using card number \" << cardNumber << std::endl;\n};\n\nauto paypalPayment = [](const std::string &email, double amount) {\n  std::cout << \"Processing PayPal payment of $\" << amount << \" for \" << email\n            << std::endl;\n};\n\nint main() {\n  PaymentProcessor processor;\n\n  // Use the credit card payment strategy\n  processor.setPaymentStrategy(creditCardPayment);\n  processor.processPayment(\"4111 1111 1111 1111\", 100.0);\n\n  // Switch to the PayPal payment strategy\n  processor.setPaymentStrategy(paypalPayment);\n  processor.processPayment(\"user@example.com\", 50.0);\n\n  // Directly setting a lambda as a strategy\n  processor.setPaymentStrategy([](const std::string &account, double amount) {\n    std::cout << \"Processing cryptocurrency payment of $\" << amount\n              << \" to wallet \" << account << std::endl;\n  });\n  processor.processPayment(\"crypto_wallet_address\", 75.0);\n\n  return 0;\n}\n\n// Flexibility: The use of std::function for the strategy pattern allows the\n// PaymentProcessor to accept any callable that matches the signature, including\n// lambdas, function objects, and free functions. This flexibility greatly\n// enhances the pattern's utility and expressiveness in C++.\n\n// Ease of Use: Directly setting strategies without the need to define concrete\n// strategy classes for every case simplifies code and reduces boilerplate,\n// making the strategy pattern more accessible and easier to use for a variety\n// of scenarios.\n\n// Dynamic Strategy Selection: Strategies can be dynamically changed at runtime,\n// allowing the system to adapt its behavior as needed based on context or user\n// preferences.\n"}]},{"title":"Template Method","examples":[{"title":"Example","codeFile":"patterns/behavioural/template-method/example","code":"#include <iostream>\n\n// Abstract Base Class with Template Method\n\nclass Breakfast {\npublic:\n  // Template method\n  void prepare() {\n    boilWater();\n    addIngredients();\n    cook();\n    serve();\n  }\n\n  // Destructor\n  virtual ~Breakfast() {}\n\nprotected:\n  // Abstract methods to be implemented by subclasses\n  virtual void addIngredients() = 0;\n  virtual void cook() = 0;\n\n  // Concrete methods\n  void boilWater() { std::cout << \"Boiling water...\" << std::endl; }\n\n  void serve() { std::cout << \"Breakfast is served!\" << std::endl; }\n};\n\n// Concrete Subclasses Implementing the Specific Steps\n\nclass OmeletteBreakfast : public Breakfast {\nprotected:\n  void addIngredients() override {\n    std::cout << \"Adding eggs, cheese, and vegetables to the pan.\" << std::endl;\n  }\n\n  void cook() override {\n    std::cout << \"Cooking the omelette until golden brown.\" << std::endl;\n  }\n};\n\nclass PancakeBreakfast : public Breakfast {\nprotected:\n  void addIngredients() override {\n    std::cout << \"Mixing flour, eggs, milk, and sugar to make the batter.\"\n              << std::endl;\n  }\n\n  void cook() override {\n    std::cout\n        << \"Pouring the batter onto the griddle and flipping until cooked.\"\n        << std::endl;\n  }\n};\n\nint main() {\n  std::cout << \"Preparing Omelette Breakfast:\" << std::endl;\n  OmeletteBreakfast omeletteBreakfast;\n  omeletteBreakfast.prepare();\n\n  std::cout << \"\\nPreparing Pancake Breakfast:\" << std::endl;\n  PancakeBreakfast pancakeBreakfast;\n  pancakeBreakfast.prepare();\n\n  return 0;\n}\n\n/**\n * In this example, we have an abstract class Breakfast representing the\n * template method pattern. It defines the steps of preparing breakfast in the\n * prepare() method, which serves as the template method. The abstract methods\n * addIngredients() and cook() are placeholders for the specific steps that vary\n * between different types of breakfasts.\n *\n * Subclasses such as OmeletteBreakfast and PancakeBreakfast extend the\n * Breakfast class and implement the abstract methods to provide specific\n * implementations for adding ingredients and cooking. The template method\n * prepare() orchestrates the sequence of steps required to prepare each type of\n * breakfast.\n *\n */\n"},{"title":"Refined Example","codeFile":"patterns/behavioural/template-method/example-refined","code":"#include <iostream>\n#include <string>\n\n// Abstract Base Class with Template Method\n\nclass DocumentParser {\npublic:\n  // Template method\n  void parseDocument(const std::string &content) {\n    preprocess(content);\n    extractData(content);\n    postprocess(content);\n  }\n\n  virtual ~DocumentParser() {}\n\nprotected:\n  virtual void preprocess(const std::string &content) {\n    std::cout << \"Preprocessing content: \" << content << std::endl;\n  }\n\n  virtual void extractData(const std::string &content) = 0; // Abstract method\n\n  virtual void postprocess(const std::string &content) {\n    std::cout << \"Postprocessing content: \" << content << std::endl;\n  }\n};\n\n// Concrete Subclasses Implementing Specific Parsing Logic\n\nclass XMLParser : public DocumentParser {\nprotected:\n  void extractData(const std::string &content) override {\n    std::cout << \"Extracting data from XML: \" << content << std::endl;\n  }\n};\n\nclass JSONParser : public DocumentParser {\nprotected:\n  void extractData(const std::string &content) override {\n    std::cout << \"Extracting data from JSON: \" << content << std::endl;\n  }\n};\n\nclass CSVParser : public DocumentParser {\nprotected:\n  void preprocess(const std::string &content) override {\n    std::cout << \"Custom preprocessing for CSV: \" << content << std::endl;\n  }\n\n  void extractData(const std::string &content) override {\n    std::cout << \"Extracting data from CSV: \" << content << std::endl;\n  }\n\n  void postprocess(const std::string &content) override {\n    std::cout << \"Custom postprocessing for CSV: \" << content << std::endl;\n  }\n};\n\nint main() {\n  XMLParser xmlParser;\n  JSONParser jsonParser;\n  CSVParser csvParser;\n\n  std::cout << \"Parsing XML document:\" << std::endl;\n  xmlParser.parseDocument(\"<xml>Some data</xml>\");\n\n  std::cout << \"\\nParsing JSON document:\" << std::endl;\n  jsonParser.parseDocument(\"{ \\\"key\\\": \\\"value\\\" }\");\n\n  std::cout << \"\\nParsing CSV document:\" << std::endl;\n  csvParser.parseDocument(\"name,age\\nJohn Doe,30\");\n\n  return 0;\n}\n\n// Algorithm Skeleton: The DocumentParser base class outlines the algorithm's\n// skeleton with the parseDocument method, providing default implementations for\n// optional steps (preprocess and postprocess) and requiring concrete subclasses\n// to implement the essential step (extractData).\n\n// Polymorphism and Flexibility: Concrete classes (XMLParser, JSONParser,\n// CSVParser) inherit from DocumentParser and provide specific implementations\n// for parsing different document formats. This demonstrates the pattern's\n// flexibility in accommodating various algorithms under a unified interface.\n\n// Customization of Steps: The CSVParser class overrides all steps to provide\n// custom behavior, showcasing the pattern's ability to adapt the algorithm's\n// skeleton to specific needs without altering its overall structure.\n\n// This example demonstrates a sophisticated use of the Template Method Design\n// Pattern in C++, effectively separating the invariant parts of an algorithm\n// from the variant parts, thus promoting code reuse and flexibility in\n// extending the system with new document formats.\n"}]},{"title":"Visitor","examples":[{"title":"Example","codeFile":"patterns/behavioural/visitor/example","code":"\n\n/**\n * The AnimalVisitor interface defines the operations that can be performed on\n * different types of animals.\n *\n * The AnimalFeeder class is a concrete visitor that implements feeding\n * operations for lions, elephants, and giraffes.\n *\n * The Animal interface represents animals, and concrete animal classes (Lion,\n * Elephant, and Giraffe) implement this interface and define how they accept a\n * visitor.\n *\n * The Zoo class represents the object structure that contains a collection of\n * animals. It has methods to add animals and perform an operation (feeding in\n * this case) using a visitor.\n *\n * Finally, in the client code, we create a zoo, add animals to it, create a\n * visitor (animal feeder), and then perform the feeding operation on each\n * animal in the zoo using the visitor.\n */\n"},{"title":"Refined Example","codeFile":"patterns/behavioural/visitor/example-refined","code":"#include <iostream>\n#include <memory>\n#include <string>\n#include <vector>\n\nclass Lion;\nclass Elephant;\nclass Giraffe;\n\n// Visitor interface\nclass AnimalVisitor {\npublic:\n  virtual void visitLion(Lion *lion) = 0;\n  virtual void visitElephant(Elephant *elephant) = 0;\n  virtual void visitGiraffe(Giraffe *giraffe) = 0;\n  virtual ~AnimalVisitor() = default;\n};\n\n// Concrete visitor\nclass AnimalFeeder : public AnimalVisitor {\npublic:\n  void visitLion(Lion *lion) override;\n  void visitElephant(Elephant *elephant) override;\n  void visitGiraffe(Giraffe *giraffe) override;\n};\n\n// Element interface\nclass Animal {\npublic:\n  virtual void accept(AnimalVisitor *visitor) = 0;\n  virtual std::string getName() const = 0;\n  virtual ~Animal() = default;\n};\n\nclass Lion : public Animal {\n  std::string name;\n\npublic:\n  Lion(const std::string &name) : name(name) {}\n  void accept(AnimalVisitor *visitor) override { visitor->visitLion(this); }\n  std::string getName() const override { return name; }\n};\n\nclass Elephant : public Animal {\n  std::string name;\n\npublic:\n  Elephant(const std::string &name) : name(name) {}\n  void accept(AnimalVisitor *visitor) override { visitor->visitElephant(this); }\n  std::string getName() const override { return name; }\n};\n\nclass Giraffe : public Animal {\n  std::string name;\n\npublic:\n  Giraffe(const std::string &name) : name(name) {}\n  void accept(AnimalVisitor *visitor) override { visitor->visitGiraffe(this); }\n  std::string getName() const override { return name; }\n};\nConcrete Visitor Implementation Implement the AnimalFeeder methods to feed each\n    type of animal.\n\n    cpp Copy code void\n    AnimalFeeder::visitLion(Lion *lion) {\n  std::cout << \"Feeding meat to \" << lion->getName() << \".\" << std::endl;\n}\n\nvoid AnimalFeeder::visitElephant(Elephant *elephant) {\n  std::cout << \"Feeding hay to \" << elephant->getName() << \".\" << std::endl;\n}\n\nvoid AnimalFeeder::visitGiraffe(Giraffe *giraffe) {\n  std::cout << \"Feeding leaves to \" << giraffe->getName() << \".\" << std::endl;\n}\n\n// Zoo Class and Client Code The Zoo class contains a collection of animals and\n// a method to perform operations on them using a visitor.\n\nclass Zoo {\n  std::vector<std::shared_ptr<Animal>> animals;\n\npublic:\n  void addAnimal(const std::shared_ptr<Animal> &animal) {\n    animals.push_back(animal);\n  }\n\n  void performOperation(AnimalVisitor *visitor) {\n    for (auto &animal : animals) {\n      animal->accept(visitor);\n    }\n  }\n};\n\nint main() {\n  Zoo zoo;\n  zoo.addAnimal(std::make_shared<Lion>(\"Simba\"));\n  zoo.addAnimal(std::make_shared<Elephant>(\"Dumbo\"));\n  zoo.addAnimal(std::make_shared<Giraffe>(\"Melman\"));\n\n  AnimalFeeder feeder;\n  zoo.performOperation(&feeder);\n\n  return 0;\n}\n\n// Visitor Pattern in C++: Demonstrates defining operations on elements (Lion,\n// Elephant, Giraffe) outside of their classes, adhering to the open/closed\n// principle.\n\n// Polymorphism and Dynamic Binding: Uses polymorphism to apply different\n// operations dynamically based on the object's type at runtime.\n\n// Memory Management: Utilizes std::shared_ptr for automatic memory management\n// of the animal objects within the Zoo class.\n\n// This C++ example showcases how the Visitor Design Pattern enables adding new\n// operations to existing object structures without modifying the structures,\n// promoting flexibility and scalability in application design.\n"}]}],"patterns_creational":[{"title":"Factory Method","examples":[{"codeFile":"patterns/creational/factory-method/example","code":"#include <iostream>\n#include <memory>\n\nclass Vehicle {\npublic:\n  virtual void drive() const = 0;\n  virtual ~Vehicle() {}\n};\n\nclass Car : public Vehicle {\npublic:\n  void drive() const override { std::cout << \"Driving a car...\" << std::endl; }\n};\n\nclass Truck : public Vehicle {\npublic:\n  void drive() const override {\n    std::cout << \"Driving a truck...\" << std::endl;\n  }\n};\n\n// Creator: VehicleFactory\n\nclass VehicleFactory {\npublic:\n  virtual std::unique_ptr<Vehicle> createVehicle() const = 0;\n\n  void deliverVehicle() const {\n    auto vehicle = createVehicle();\n    std::cout << \"Delivering the vehicle...\" << std::endl;\n    vehicle->drive();\n  }\n\n  virtual ~VehicleFactory() {}\n};\n\n// Concrete Creators: CarFactory and TruckFactory\n\nclass CarFactory : public VehicleFactory {\npublic:\n  std::unique_ptr<Vehicle> createVehicle() const override {\n    std::cout << \"Creating a car...\" << std::endl;\n    return std::make_unique<Car>();\n  }\n};\n\nclass TruckFactory : public VehicleFactory {\npublic:\n  std::unique_ptr<Vehicle> createVehicle() const override {\n    std::cout << \"Creating a truck...\" << std::endl;\n    return std::make_unique<Truck>();\n  }\n};\n\n// Client Code\n\nint main() {\n  CarFactory carFactory;\n  carFactory.deliverVehicle();\n\n  TruckFactory truckFactory;\n  truckFactory.deliverVehicle();\n\n  return 0;\n}\n\n/**\n * The Vehicle interface defines a common interface for all vehicles, which\n * includes a drive() method.\n *\n * The Car and Truck classes are concrete implementations of the Vehicle\n * interface.\n *\n * The VehicleFactory class is an abstract class representing a creator. It\n * declares the createVehicle() method, which serves as the Factory Method for\n * creating vehicles. The deliverVehicle() method is a common operation that\n * uses the Factory Method to create and deliver a vehicle.\n *\n * The CarFactory and TruckFactory classes are concrete implementations of the\n * VehicleFactory class. They override the createVehicle() method to create\n * specific types of vehicles (i.e., cars and trucks).\n *\n */\n"}]},{"title":"Abstract Factory","examples":[{"codeFile":"patterns/creational/abstract-factory/example","code":"#include <iostream>\n#include <memory>\n\n// Forward declarations of product interfaces\nclass Chair;\nclass Table;\n\n// Abstract Factory interface\nclass FurnitureFactory {\npublic:\n  virtual std::shared_ptr<Chair> createChair() const = 0;\n  virtual std::shared_ptr<Table> createTable() const = 0;\n  virtual ~FurnitureFactory() {}\n};\n\n// Concrete Factory: Modern Furniture Factory\nclass ModernFurnitureFactory : public FurnitureFactory {\npublic:\n  std::shared_ptr<Chair> createChair() const override;\n  std::shared_ptr<Table> createTable() const override;\n};\n\n// Concrete Factory: Vintage Furniture Factory\nclass VintageFurnitureFactory : public FurnitureFactory {\npublic:\n  std::shared_ptr<Chair> createChair() const override;\n  std::shared_ptr<Table> createTable() const override;\n};\n\n// Abstract Product: Chair\nclass Chair {\npublic:\n  virtual void sitOn() const = 0;\n  virtual ~Chair() {}\n};\n\n// Concrete Product: Modern Chair\nclass ModernChair : public Chair {\npublic:\n  void sitOn() const override {\n    std::cout << \"Sitting on a modern chair.\" << std::endl;\n  }\n};\n\n// Concrete Product: Vintage Chair\nclass VintageChair : public Chair {\npublic:\n  void sitOn() const override {\n    std::cout << \"Sitting on a vintage chair.\" << std::endl;\n  }\n};\n\n// Abstract Product: Table\nclass Table {\npublic:\n  virtual void putOn() const = 0;\n  virtual ~Table() {}\n};\n\n// Concrete Product: Modern Table\nclass ModernTable : public Table {\npublic:\n  void putOn() const override {\n    std::cout << \"Putting something on a modern table.\" << std::endl;\n  }\n};\n\n// Concrete Product: Vintage Table\nclass VintageTable : public Table {\npublic:\n  void putOn() const override {\n    std::cout << \"Putting something on a vintage table.\" << std::endl;\n  }\n};\n\nstd::shared_ptr<Chair> ModernFurnitureFactory::createChair() const {\n  return std::make_shared<ModernChair>();\n}\n\nstd::shared_ptr<Table> ModernFurnitureFactory::createTable() const {\n  return std::make_shared<ModernTable>();\n}\n\nstd::shared_ptr<Chair> VintageFurnitureFactory::createChair() const {\n  return std::make_shared<VintageChair>();\n}\n\nstd::shared_ptr<Table> VintageFurnitureFactory::createTable() const {\n  return std::make_shared<VintageTable>();\n}\nvoid createFurniture(const FurnitureFactory &factory) {\n  auto chair = factory.createChair();\n  auto table = factory.createTable();\n\n  std::cout << \"Created furniture:\" << std::endl;\n  chair->sitOn();\n  table->putOn();\n}\n\nint main() {\n  std::cout << \"Creating modern furniture:\" << std::endl;\n  ModernFurnitureFactory modernFactory;\n  createFurniture(modernFactory);\n\n  std::cout << \"\\nCreating vintage furniture:\" << std::endl;\n  VintageFurnitureFactory vintageFactory;\n  createFurniture(vintageFactory);\n\n  return 0;\n}\n\n/**\n * The FurnitureFactory interface declares methods for creating chairs and\n * tables.\n *\n * Concrete factories (ModernFurnitureFactory and VintageFurnitureFactory)\n * implement the FurnitureFactory interface to produce modern and vintage\n * furniture, respectively.\n *\n * The Chair interface declares a method for sitting on a chair, and concrete\n * chair classes (ModernChair and VintageChair) implement this interface.\n *\n * The Table interface declares a method for putting something on a table, and\n * concrete table classes (ModernTable and VintageTable) implement this\n * interface. The createFurniture function acts as a client and receives a\n * FurnitureFactory as a parameter. It creates a chair and a table using the\n * factory and then performs actions on the created furniture.\n *\n */\n"}]},{"title":"Builder","examples":[{"codeFile":"patterns/creational/builder/example","code":"#include <iostream>\n#include <string>\n\nclass Computer {\n  std::string cpu;\n  int ram;\n  int storage;\n  std::string gpu;\n  double screenSize;\n\npublic:\n  Computer(const std::string &cpu, int ram, int storage, const std::string &gpu,\n           double screenSize)\n      : cpu(cpu), ram(ram), storage(storage), gpu(gpu), screenSize(screenSize) {\n  }\n\n  void displaySpecs() const {\n    std::cout << \"CPU: \" << cpu << std::endl;\n    std::cout << \"RAM: \" << ram << \" GB\" << std::endl;\n    std::cout << \"Storage: \" << storage << \" GB\" << std::endl;\n    std::cout << \"GPU: \" << gpu << std::endl;\n    std::cout << \"Screen Size: \" << screenSize << \" inches\" << std::endl;\n  }\n};\n\nclass ComputerBuilder {\npublic:\n  virtual void setCPU(const std::string &cpu) = 0;\n  virtual void setRAM(int ram) = 0;\n  virtual void setStorage(int storage) = 0;\n  virtual void setGPU(const std::string &gpu) = 0;\n  virtual void setScreenSize(double screenSize) = 0;\n  virtual Computer getResult() const = 0;\n  virtual ~ComputerBuilder() {}\n};\n\nclass GamingComputerBuilder : public ComputerBuilder {\n  std::string cpu;\n  int ram = 0;\n  int storage = 0;\n  std::string gpu;\n  double screenSize = 0.0;\n\npublic:\n  void setCPU(const std::string &cpu) override { this->cpu = cpu; }\n\n  void setRAM(int ram) override { this->ram = ram; }\n\n  void setStorage(int storage) override { this->storage = storage; }\n\n  void setGPU(const std::string &gpu) override { this->gpu = gpu; }\n\n  void setScreenSize(double screenSize) override {\n    this->screenSize = screenSize;\n  }\n\n  Computer getResult() const override {\n    return Computer(cpu, ram, storage, gpu, screenSize);\n  }\n};\n\nclass ComputerBuilderDirector {\n  ComputerBuilder *builder;\n\npublic:\n  ComputerBuilderDirector(ComputerBuilder *builder) : builder(builder) {}\n\n  void constructGamingComputer() {\n    builder->setCPU(\"Intel Core i9\");\n    builder->setRAM(32);\n    builder->setStorage(1000);\n    builder->setGPU(\"NVIDIA GeForce RTX 3080\");\n    builder->setScreenSize(27);\n  }\n};\n\nint main() {\n  GamingComputerBuilder builder;\n  ComputerBuilderDirector director(&builder);\n  director.constructGamingComputer();\n  Computer gamingComputer = builder.getResult();\n  std::cout << \"Gaming Computer Specifications:\" << std::endl;\n  gamingComputer.displaySpecs();\n\n  return 0;\n}\n\n/**\n * The Computer class represents the product we want to build, which is a custom\n * computer with various specifications like CPU, RAM, storage, GPU, and screen\n * size.\n *\n * The ComputerBuilder interface defines methods for setting each component of\n * the computer.\n *\n * The GamingComputerBuilder class is a concrete builder that implements the\n * ComputerBuilder interface to construct a gaming computer with specific\n * configurations.\n *\n * The ComputerBuilderDirector class is responsible for directing the\n * construction process using a builder.\n *\n * The client code creates a GamingComputerBuilder, passes it to the director,\n * and instructs the director to construct a gaming computer. Finally, it\n * retrieves the constructed gaming computer and displays its specifications.\n *\n */\n"}]},{"title":"Prototype","examples":[{"codeFile":"patterns/creational/prototype/example","code":"#include <iostream>\n#include <memory>\n#include <string>\n\n// Prototype interface\nclass UserProfile {\npublic:\n  virtual std::unique_ptr<UserProfile> clone() const = 0;\n  virtual void customizeProfile(const std::string &username,\n                                const std::string &bio,\n                                const std::string &profilePicture) = 0;\n  virtual void displayProfile() const = 0;\n  virtual ~UserProfile() {}\n};\n\n// Concrete Prototype\nclass DefaultUserProfile : public UserProfile {\n  std::string username;\n  std::string bio;\n  std::string profilePicture;\n\npublic:\n  DefaultUserProfile(const std::string &username, const std::string &bio,\n                     const std::string &profilePicture)\n      : username(username), bio(bio), profilePicture(profilePicture) {}\n\n  std::unique_ptr<UserProfile> clone() const override {\n    return std::make_unique<DefaultUserProfile>(*this);\n  }\n\n  void customizeProfile(const std::string &newUsername,\n                        const std::string &newBio,\n                        const std::string &newProfilePicture) override {\n    if (!newUsername.empty())\n      username = newUsername;\n    if (!newBio.empty())\n      bio = newBio;\n    if (!newProfilePicture.empty())\n      profilePicture = newProfilePicture;\n  }\n\n  void displayProfile() const override {\n    std::cout << \"Username: \" << username << std::endl;\n    std::cout << \"Bio: \" << bio << std::endl;\n    std::cout << \"Profile Picture: \" << profilePicture << std::endl;\n  }\n};\n\n// Client Code\n\nint main() {\n  DefaultUserProfile defaultProfile(\"user123\", \"Welcome to my profile!\",\n                                    \"default.jpg\");\n\n  // Clone the default profile to create a customized profile\n  auto customizedProfile = defaultProfile.clone();\n  customizedProfile->customizeProfile(\"\", \"I'm a software developer.\",\n                                      \"avatar.jpg\");\n\n  // Display both profiles\n  std::cout << \"Default Profile:\" << std::endl;\n  defaultProfile.displayProfile();\n\n  std::cout << \"\\nCustomized Profile:\" << std::endl;\n  customizedProfile->displayProfile();\n\n  return 0;\n}\n/**\n * The UserProfile interface defines methods for cloning a profile, customizing\n * profile settings, and displaying the profile.\n *\n * The DefaultUserProfile class is a concrete implementation of the UserProfile\n * interface. It represents the default user profile with properties like\n * username, bio, and profile picture. The clone() method creates a copy of the\n * profile, and the customizeProfile() method allows modifying profile settings.\n *\n * The UserProfileSettings interface defines optional settings that can be\n * customized in a user profile.\n *\n * In the client code, we create a default user profile and then clone it to\n * create a customized profile with updated settings. Both profiles can be\n * displayed independently, demonstrating the use of the Prototype pattern to\n * create new objects by copying existing ones.\n */\n"}]},{"title":"Singleton","examples":[{"codeFile":"patterns/creational/singleton/example","code":"#include <chrono>\n#include <iomanip>\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <vector>\n\n// Singleton Class Implementation\n\nclass Logger {\nprivate:\n  static Logger *instance;\n  std::vector<std::string> logHistory;\n\n  // Private constructor to prevent instantiation from outside the class\n  Logger() {}\n\npublic:\n  // Deleted copy constructor and assignment operator for singleton property\n  Logger(const Logger &) = delete;\n  Logger &operator=(const Logger &) = delete;\n\n  // Static method to retrieve the singleton instance\n  static Logger *getInstance() {\n    if (instance == nullptr) {\n      instance = new Logger();\n    }\n    return instance;\n  }\n\n  // Method to log messages\n  void log(const std::string &message) {\n    auto now = std::chrono::system_clock::now();\n    auto now_c = std::chrono::system_clock::to_time_t(now);\n    std::stringstream ss;\n    ss << std::put_time(std::localtime(&now_c), \"[%Y-%m-%d %X]\") << \" \"\n       << message;\n    std::string logEntry = ss.str();\n\n    logHistory.push_back(logEntry);\n    std::cout << logEntry << std::endl;\n  }\n\n  // Method to retrieve log history\n  std::vector<std::string> getLogHistory() const { return logHistory; }\n};\n\n// Initialize the static member of Logger class\nLogger *Logger::instance = nullptr;\n\n// Client Code\n\nint main() {\n  Logger *logger1 = Logger::getInstance();\n  Logger *logger2 = Logger::getInstance();\n\n  std::cout\n      << std::boolalpha << (logger1 == logger2)\n      << std::endl; // Output: true, both references point to the same instance\n\n  logger1->log(\"User logged in\");\n  logger2->log(\"Data saved to database\");\n\n  for (const auto &logEntry : logger1->getLogHistory()) {\n    std::cout << logEntry << std::endl;\n  }\n\n  return 0;\n}\n\n/**\n * The Logger class has a private static instance property that holds the single\n * instance of the logger.\n *\n * The constructor is made private to prevent instantiation from outside the\n * class.\n *\n * The getInstance() method is a static method that returns the singleton\n * instance of the logger. It ensures that only one instance of the logger is\n * created throughout the application.\n *\n * The log() method logs a message along with a timestamp and adds the log entry\n * to the logHistory array.\n *\n * The getLogHistory() method retrieves the log history.\n *\n * In the client code, both logger1 and logger2 references point to the same\n * instance of the logger obtained using the getInstance() method.\n *\n * Logging messages using either logger1 or logger2 will result in consistent\n * logging behavior, and the log history can be retrieved from either instance.\n */\n"}]}],"patterns_structural":[{"title":"Adapter","examples":[{"codeFile":"patterns/structural/adapter/example","code":"// Adaptee: Existing MP3 player\nclass Mp3Player {\n  playMp3(fileName: string): void {\n    console.log(`Playing MP3 file: ${fileName}`);\n  }\n}\n\n// Target: Interface expected by the client (unified interface)\ninterface AudioPlayer {\n  play(fileName: string): void;\n}\n\n// Adapter: Converts OGG audio files to MP3 format\nclass OggToMp3Adapter implements AudioPlayer {\n  private mp3Player: Mp3Player;\n\n  constructor() {\n    this.mp3Player = new Mp3Player();\n  }\n\n  play(fileName: string): void {\n    // Convert OGG to MP3 and play using the MP3 player\n    console.log(`Converting OGG file '${fileName}' to MP3 format`);\n    const mp3FileName = this.convertToMp3(fileName);\n    this.mp3Player.playMp3(mp3FileName);\n  }\n\n  private convertToMp3(fileName: string): string {\n    // Simulate conversion process (replace extension)\n    return fileName.replace('.ogg', '.mp3');\n  }\n}\n\n// Client code\nconst audioPlayer: AudioPlayer = new OggToMp3Adapter();\n\n// Play MP3 file\naudioPlayer.play('audio1.mp3');\n\n// Play OGG file (automatically converted to MP3)\naudioPlayer.play('audio2.ogg');\n\n/**\n * Mp3Player represents the existing audio player that can play MP3 files.\n *\n * AudioPlayer is the target interface that defines the unified interface expected by the\n * client application for playing audio files.\n *\n * OggToMp3Adapter is the adapter class that implements the AudioPlayer interface. It internally\n * uses the Mp3Player to play MP3 files but converts OGG files to MP3 format before delegating to\n * the Mp3Player.\n *\n * In the client code, the application interacts with the AudioPlayer interface, unaware of whether\n * it's playing MP3 or OGG files. When playing an OGG file, the adapter automatically converts it\n * to MP3 format before playing it using the Mp3Player.\n *\n */\n"}]},{"title":"Bridge","examples":[{"codeFile":"patterns/structural/bridge/example","code":"// Abstraction: Vehicle\nabstract class Vehicle {\n  protected workshop: Workshop;\n\n  constructor(workshop: Workshop) {\n    this.workshop = workshop;\n  }\n\n  abstract manufacture(): void;\n}\n\n// Implementor: Workshop\ninterface Workshop {\n  work(): void;\n}\n\n// Concrete Implementor: Paint Workshop\nclass PaintWorkshop implements Workshop {\n  work(): void {\n    console.log('Painting vehicle');\n  }\n}\n\n// Concrete Implementor: Repair Workshop\nclass RepairWorkshop implements Workshop {\n  work(): void {\n    console.log('Repairing vehicle');\n  }\n}\n\n// Refined Abstraction: Car\nclass Car extends Vehicle {\n  manufacture(): void {\n    console.log('Manufacturing car.');\n    this.workshop.work();\n  }\n}\n\n// Refined Abstraction: Truck\nclass Truck extends Vehicle {\n  manufacture(): void {\n    console.log('Manufacturing truck.');\n    this.workshop.work();\n  }\n}\n\n// Client code\nconst car = new Car(new PaintWorkshop());\ncar.manufacture(); // Output: Manufacturing car. Painting vehicle\n\nconst truck = new Truck(new RepairWorkshop());\ntruck.manufacture(); // Output: Manufacturing truck. Repairing vehicle\n\n/**\n * The Vehicle class represents the abstraction, which is extended by Car and Truck.\n *\n * The Workshop interface represents the implementor, defining the work method.\n *\n * PaintWorkshop and RepairWorkshop are concrete implementations of the Workshop interface.\n *\n * Each vehicle can be associated with a specific workshop using composition, and it delegates the work to that workshop.\n */\n"}]},{"title":"Composite","examples":[{"codeFile":"patterns/structural/composite/example","code":"// Component: Department\ninterface Department {\n  getName(): string;\n  getEmployees(): string[];\n}\n\n// Leaf: Individual Department\nclass IndividualDepartment implements Department {\n  private name: string;\n  private employees: string[];\n\n  constructor(name: string, employees: string[]) {\n    this.name = name;\n    this.employees = employees;\n  }\n\n  getName(): string {\n    return this.name;\n  }\n\n  getEmployees(): string[] {\n    return this.employees;\n  }\n}\n\n// Composite: Composite Department\nclass CompositeDepartment implements Department {\n  private name: string;\n  private departments: Department[];\n\n  constructor(name: string) {\n    this.name = name;\n    this.departments = [];\n  }\n\n  getName(): string {\n    return this.name;\n  }\n\n  addDepartment(department: Department): void {\n    this.departments.push(department);\n  }\n\n  removeDepartment(department: Department): void {\n    const index = this.departments.indexOf(department);\n    if (index !== -1) {\n      this.departments.splice(index, 1);\n    }\n  }\n\n  getEmployees(): string[] {\n    let employees: string[] = [];\n    for (const department of this.departments) {\n      employees = employees.concat(department.getEmployees());\n    }\n    return employees;\n  }\n}\n\n// Client code\nconst salesDepartment = new IndividualDepartment('Sales Department', ['John', 'Alice', 'Bob']);\nconst marketingDepartment = new IndividualDepartment('Marketing Department', ['Emily', 'David']);\nconst engineeringDepartment = new IndividualDepartment('Engineering Department', ['Michael', 'Sarah', 'Chris']);\n\nconst headDepartment = new CompositeDepartment('Head Department');\nheadDepartment.addDepartment(salesDepartment);\nheadDepartment.addDepartment(marketingDepartment);\n\nconst parentEngineeringDepartment = new CompositeDepartment('Parent Engineering Department');\nparentEngineeringDepartment.addDepartment(engineeringDepartment);\n\nconst rootDepartment = new CompositeDepartment('Root Department');\nrootDepartment.addDepartment(headDepartment);\nrootDepartment.addDepartment(parentEngineeringDepartment);\n\n// Get all employees in the root department\nconsole.log('Employees in the root department:');\nconsole.log(rootDepartment.getEmployees());\n\n/**\n * The Department interface defines the common methods for both individual departments and composite departments.\n *\n * IndividualDepartment represents an individual department with a name and a list of employees.\n *\n * CompositeDepartment represents a composite department that can contain sub-departments. It maintains a\n * list of departments and delegates the getEmployees method to its sub-departments recursively.\n *\n * The client code creates a hierarchical structure of departments and retrieves all employees from the root department.\n */\n"}]},{"title":"Decorator","examples":[{"codeFile":"patterns/structural/decorator/example","code":"// Component: Notification\ninterface Notification {\n  send(): string;\n}\n\n// Concrete Component: Base Notification\nclass BaseNotification implements Notification {\n  send(): string {\n    return 'Base notification: You have a new message!';\n  }\n}\n\n// Decorator: Notification Decorator\nabstract class NotificationDecorator implements Notification {\n  protected notification: Notification;\n\n  constructor(notification: Notification) {\n    this.notification = notification;\n  }\n\n  send(): string {\n    return this.notification.send();\n  }\n}\n\n// Concrete Decorator: Sound Notification\nclass SoundNotificationDecorator extends NotificationDecorator {\n  send(): string {\n    return `${super.send()} (Sound notification: Ding!)`;\n  }\n}\n\n// Concrete Decorator: Priority Notification\nclass PriorityNotificationDecorator extends NotificationDecorator {\n  send(): string {\n    return `${super.send()} (Priority notification: High priority!)`;\n  }\n}\n\n// Client code\nconst baseNotification: Notification = new BaseNotification();\nconsole.log(baseNotification.send());\n\nconst soundNotification: Notification = new SoundNotificationDecorator(baseNotification);\nconsole.log(soundNotification.send());\n\nconst priorityNotification: Notification = new PriorityNotificationDecorator(baseNotification);\nconsole.log(priorityNotification.send());\n\nconst soundAndPriorityNotification: Notification = new PriorityNotificationDecorator(new SoundNotificationDecorator(baseNotification));\nconsole.log(soundAndPriorityNotification.send());\n\n/**\n * The Notification interface defines the common method for sending notifications.\n *\n * BaseNotification represents the base notification without any additional features.\n *\n * NotificationDecorator is an abstract class that serves as the base class for concrete decorators.\n * It holds a reference to the wrapped notification.\n *\n * SoundNotificationDecorator adds sound notification functionality to the base notification.\n *\n * PriorityNotificationDecorator adds priority notification functionality to the base notification.\n *\n * The client code demonstrates how we can dynamically add sound notification, priority notification,\n * or both to the base notification. Each decorator enhances the behavior of the base notification\n * without modifying its implementation.\n */\n"}]},{"title":"Facade","examples":[{"codeFile":"patterns/structural/facade/example","code":"// Subsystem: Flight Booking\nclass FlightBookingSystem {\n  bookFlight(origin: string, destination: string): string {\n    return `Flight booked from ${origin} to ${destination}`;\n  }\n}\n\n// Subsystem: Hotel Booking\nclass HotelBookingSystem {\n  bookHotel(location: string, checkInDate: Date, checkOutDate: Date): string {\n    return `Hotel booked at ${location} from ${checkInDate.toDateString()} to ${checkOutDate.toDateString()}`;\n  }\n}\n\n// Subsystem: Car Rental\nclass CarRentalSystem {\n  rentCar(location: string, startDate: Date, endDate: Date): string {\n    return `Car rented at ${location} from ${startDate.toDateString()} to ${endDate.toDateString()}`;\n  }\n}\n\n// Facade: TravelFacade\nclass TravelFacade {\n  private flightBookingSystem: FlightBookingSystem;\n  private hotelBookingSystem: HotelBookingSystem;\n  private carRentalSystem: CarRentalSystem;\n\n  constructor() {\n    this.flightBookingSystem = new FlightBookingSystem();\n    this.hotelBookingSystem = new HotelBookingSystem();\n    this.carRentalSystem = new CarRentalSystem();\n  }\n\n  bookTravel(origin: string, destination: string, location: string, checkInDate: Date, checkOutDate: Date, startDate: Date, endDate: Date): string {\n    const flightDetails = this.flightBookingSystem.bookFlight(origin, destination);\n    const hotelDetails = this.hotelBookingSystem.bookHotel(location, checkInDate, checkOutDate);\n    const carDetails = this.carRentalSystem.rentCar(location, startDate, endDate);\n\n    return `${flightDetails}\\n${hotelDetails}\\n${carDetails}`;\n  }\n}\n\n// Client code\nconst travelFacade = new TravelFacade();\nconst bookingDetails = travelFacade.bookTravel('New York', 'Los Angeles', 'Hilton', new Date('2023-12-15'), new Date('2023-12-20'), new Date('2023-12-15'), new Date('2023-12-20'));\nconsole.log(bookingDetails);\n\n/**\n * The FlightBookingSystem, HotelBookingSystem, and CarRentalSystem classes represent the\n * subsystems of flight booking, hotel booking, and car rental, respectively.\n *\n * The TravelFacade class provides a simplified interface for booking a complete travel\n * package. It encapsulates the complexities of interacting with the subsystems.\n *\n * The client code interacts with the TravelFacade to book a complete travel package without\n * directly interacting with the subsystems.\n */\n"}]},{"title":"Flyweight","examples":[{"codeFile":"patterns/structural/flyweight/example","code":"// Flyweight: Character\nclass Character {\n  constructor(private character: string) { }\n\n  display(font: string, size: number): string {\n    return `Character: ${this.character}, Font: ${font}, Size: ${size}`;\n  }\n}\n\n// Flyweight Factory: CharacterFactory\nclass CharacterFactory {\n  private characters: { [key: string]: Character } = {};\n\n  getCharacter(character: string): Character {\n    if (!this.characters[character]) {\n      this.characters[character] = new Character(character);\n    }\n    return this.characters[character];\n  }\n}\n\n// Client code\nconst characterFactory = new CharacterFactory();\n\n// Text document\nconst text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\";\n\n// Rendering text with flyweight characters\nconst renderedText: string[] = [];\n\nfor (const char of text) {\n  const character = characterFactory.getCharacter(char);\n  renderedText.push(character.display('Arial', 12)); // Assume same font and size for simplicity\n}\n\n// Displaying rendered text\nconsole.log(renderedText.join('\\n'));\n\n\n/**\n * The Character class represents the flyweight object for a character. It contains intrinsic\n * state (the character itself).\n *\n * The CharacterFactory class acts as a flyweight factory, creating and managing flyweight\n * objects. It ensures that each character is shared among multiple instances.\n *\n * In the client code, we create a text document and render it using flyweight characters.\n * Instead of creating a new character object for each character in the text, we retrieve\n * existing flyweight characters from the factory, saving memory and improving performance.\n */\n"}]},{"title":"Proxy","examples":[{"codeFile":"patterns/structural/proxy/example","code":"// Subject: Interface representing the common behavior of RealSubject and Proxy\ninterface IHttpServer {\n  request(url: string): Promise<string>;\n}\n\n// RealSubject: The actual HTTP server implementation\nclass HttpServer implements IHttpServer {\n  async request(url: string): Promise<string> {\n    // Simulating HTTP request to the actual server\n    return `Response from server for URL: ${url}`;\n  }\n}\n\n// Proxy: Proxy server that intercepts requests before forwarding them to the real server\nclass ProxyServer implements IHttpServer {\n  private httpServer: HttpServer;\n\n  constructor() {\n    this.httpServer = new HttpServer();\n  }\n\n  async request(url: string): Promise<string> {\n    // Additional logic can be added here, e.g., caching, access control, logging\n    console.log(`Proxy: Intercepted request for URL: ${url}`);\n\n    // Forward the request to the real server\n    const response = await this.httpServer.request(url);\n\n    // Additional processing on the response can be done here\n\n    return response;\n  }\n}\n\n// Client code\nasync function testProxy() {\n  const proxy = new ProxyServer();\n\n  // Client sends a request to the proxy server\n  const response = await proxy.request(\"https://example.com\");\n\n  console.log(response);\n}\n\n// Test the proxy\ntestProxy();\n\n/**\n * The IHttpServer interface defines the common behavior for both the HttpServer and ProxyServer classes.\n *\n * The HttpServer class represents the real HTTP server implementation. It implements the request method\n * to send HTTP requests to the actual server.\n *\n * The ProxyServer class acts as a proxy server. It intercepts requests before forwarding them to the real\n * server. The request method of the proxy performs additional tasks such as logging, caching, or access\n * control before delegating the request to the real server.\n *\n * In the client code, we instantiate a ProxyServer object and send a request to it. The proxy intercepts\n * the request, performs any necessary processing, and then forwards the request to the real server.\n * Finally, it returns the response to the client.\n */\n"}]}]},"principles":{"principles_solid":[{"title":"Single Responsibility","examples":[{"title":"Good Example","codeFile":"principles/solid/single-responsibility/good-example","code":"#include <iostream>\n#include <string>\n\n// Employee class responsible only for storing employee data\nclass Employee {\nprivate:\n  std::string name;\n  std::string position;\n  double salary;\n\npublic:\n  Employee(const std::string &name, const std::string &position, double salary)\n      : name(name), position(position), salary(salary) {}\n\n  std::string getName() const { return name; }\n\n  std::string getPosition() const { return position; }\n\n  double getSalary() const { return salary; }\n};\n\n// Printer class responsible only for printing employee information\nclass EmployeePrinter {\npublic:\n  void print(const Employee &employee) const {\n    std::cout << \"Name: \" << employee.getName() << std::endl;\n    std::cout << \"Position: \" << employee.getPosition() << std::endl;\n    std::cout << \"Salary: $\" << employee.getSalary() << std::endl;\n  }\n};\n\n// Example usage\nint main() {\n  Employee employee(\"John Doe\", \"Software Engineer\", 50000);\n  EmployeePrinter printer;\n  printer.print(employee);\n\n  return 0;\n}\n"},{"title":"Bad Example","codeFile":"principles/solid/single-responsibility/bad-example","code":"#include <iostream>\n#include <string>\n\n// Employee class responsible for both storing employee data and printing\n// employee information\nclass Employee {\nprivate:\n  std::string name;\n  std::string position;\n  double salary;\n\npublic:\n  Employee(const std::string &name, const std::string &position, double salary)\n      : name(name), position(position), salary(salary) {}\n\n  // Method that violates SRP by including printing functionality\n  void print() const {\n    std::cout << \"Name: \" << name << std::endl;\n    std::cout << \"Position: \" << position << std::endl;\n    std::cout << \"Salary: $\" << salary << std::endl;\n  }\n};\n\n// Example usage\nint main() {\n  Employee employee(\"John Doe\", \"Software Engineer\", 50000);\n  employee\n      .print(); // The employee object handles both data storage and printing\n\n  return 0;\n}\n"}]},{"title":"Open-Closed","examples":[{"title":"Good Example","codeFile":"principles/solid/open-closed/good-example","code":"#include <cmath> // For M_PI and std::pow\n#include <iostream>\n\n// Abstract base class Shape\nclass Shape {\npublic:\n  virtual double computeArea() const = 0; // Pure virtual function\n  virtual ~Shape() {} // Virtual destructor for proper cleanup\n};\n\n// Derived class Rectangle from Shape\nclass Rectangle : public Shape {\nprivate:\n  double width;\n  double height;\n\npublic:\n  Rectangle(double width, double height)\n      : width(width), height(height) {} // Constructor\n\n  double computeArea() const override { // Override computeArea for Rectangle\n    return width * height;\n  }\n};\n\n// Derived class Circle from Shape\nclass Circle : public Shape {\nprivate:\n  double radius;\n\npublic:\n  Circle(double radius) : radius(radius) {} // Constructor\n\n  double computeArea() const override { // Override computeArea for Circle\n    return M_PI * std::pow(radius, 2);\n  }\n};\n\n// Example usage\nint main() {\n  Rectangle rectangle(10, 5); // Create a Rectangle object\n  Circle circle(3);           // Create a Circle object\n\n  std::cout << \"Area of rectangle: \" << rectangle.computeArea() << std::endl;\n  std::cout << \"Area of circle: \" << circle.computeArea() << std::endl;\n\n  return 0;\n}\n"},{"title":"Bad Example","codeFile":"principles/solid/open-closed/bad-example","code":"#include <cmath> // For M_PI\n#include <iostream>\n\n// Rectangle class with width and height\nclass Rectangle {\npublic:\n  double width;\n  double height;\n};\n\n// Circle class with radius\nclass Circle {\npublic:\n  double radius;\n};\n\n// AreaCalculator class with a method to compute the area of shapes\nclass AreaCalculator {\npublic:\n  double computeArea(void *shape, char shapeType) {\n    if (shapeType == 'R') { // Rectangle\n      auto *rectangle = static_cast<Rectangle *>(shape);\n      return rectangle->width * rectangle->height;\n    } else if (shapeType == 'C') { // Circle\n      auto *circle = static_cast<Circle *>(shape);\n      return M_PI * circle->radius * circle->radius;\n    }\n\n    return 0; // Return 0 if shape is unknown\n  }\n};\n\n// Example usage\nint main() {\n  Rectangle rectangle = {10, 5};\n  Circle circle = {3};\n\n  AreaCalculator calculator;\n\n  std::cout << \"Area of rectangle: \" << calculator.computeArea(&rectangle, 'R')\n            << std::endl;\n  std::cout << \"Area of circle: \" << calculator.computeArea(&circle, 'C')\n            << std::endl;\n\n  return 0;\n}\n"}]},{"title":"Liskov Substitution","examples":[{"title":"Good Example","codeFile":"principles/solid/liskov-substitution/good-example","code":"#include <iostream>\n\n// Base class Bird with a fly method\nclass Bird {\npublic:\n  virtual void fly() const { std::cout << \"Bird is flying\" << std::endl; }\n  virtual ~Bird() {} // Virtual destructor for proper cleanup of derived objects\n};\n\n// Derived class Duck from Bird, adds quacking behavior\nclass Duck : public Bird {\npublic:\n  void quack() const { std::cout << \"Duck is quacking\" << std::endl; }\n};\n\n// Derived class Goose from Bird, replaces flying with swimming\nclass Goose : public Bird {\npublic:\n  void swim() const { std::cout << \"Goose is swimming\" << std::endl; }\n  void fly() const override {\n    std::cout << \"Goose is flying\"\n              << std::endl; // Goose can also fly, corrected \"Penguin\" to\n                            // \"Goose\" for consistency\n  }\n};\n\n// Function to make any bird fly\nvoid makeBirdFly(const Bird &bird) { bird.fly(); }\n\n// Example usage\nint main() {\n  Duck duck;\n  Goose goose;\n\n  makeBirdFly(duck);  // Output: Bird is flying\n  makeBirdFly(goose); // Output: Goose is flying, adjusted to reflect Goose's\n                      // ability to fly\n\n  return 0;\n}\n"},{"title":"Bad Example","codeFile":"principles/solid/liskov-substitution/bad-example","code":"#include <iostream>\n#include <stdexcept> // For std::runtime_error\n\nclass Bird {\npublic:\n  virtual void fly() const { std::cout << \"Bird is flying\" << std::endl; }\n  virtual ~Bird() {} // Ensure proper cleanup of derived objects\n};\n\nclass Ostrich : public Bird {\npublic:\n  void fly() const override {\n    throw std::runtime_error(\n        \"Can't fly\"); // Ostrich, being a Bird, should not alter the expected\n                      // behavior of the fly method\n  }\n};\n\n// Function to attempt to make any bird fly\nvoid makeBirdFly(const Bird &bird) {\n  try {\n    bird.fly();\n  } catch (const std::runtime_error &e) {\n    std::cerr << \"Error: \" << e.what() << std::endl;\n  }\n}\n\n// Example usage\nint main() {\n  Bird bird;\n  Ostrich ostrich;\n\n  makeBirdFly(bird);    // Expected to fly without issues\n  makeBirdFly(ostrich); // Expected to throw a runtime error\n\n  return 0;\n}\n"}]},{"title":"Interface Segregation","examples":[{"title":"Good Example","codeFile":"principles/solid/interface-segregation/good-example","code":"#include <iostream>\n\n// Interface for printing functionality\nclass Printer {\npublic:\n  virtual void printDocument() = 0;\n  virtual ~Printer() {}\n};\n\n// Interface for faxing functionality\nclass Fax {\npublic:\n  virtual void faxDocument() = 0;\n  virtual ~Fax() {}\n};\n\n// Interface for scanning functionality\nclass Scanner {\npublic:\n  virtual void scanDocument() = 0;\n  virtual ~Scanner() {}\n};\n\n// Simple printer only implements the Printer interface\nclass SimplePrinter : public Printer {\npublic:\n  void printDocument() override {\n    std::cout << \"Printing document...\" << std::endl;\n  }\n};\n\n// Multifunctional printer implements all interfaces\nclass MultifunctionalPrinter : public Printer, public Fax, public Scanner {\npublic:\n  void printDocument() override {\n    std::cout << \"Printing document...\" << std::endl;\n  }\n\n  void faxDocument() override {\n    std::cout << \"Faxing document...\" << std::endl;\n  }\n\n  void scanDocument() override {\n    std::cout << \"Scanning document...\" << std::endl;\n  }\n};\n\n// Example usage\nint main() {\n  SimplePrinter simplePrinter;\n  simplePrinter.printDocument();\n\n  MultifunctionalPrinter multiPrinter;\n  multiPrinter.printDocument();\n  multiPrinter.faxDocument();\n  multiPrinter.scanDocument();\n\n  return 0;\n}\n"},{"title":"Bad Example","codeFile":"principles/solid/interface-segregation/bad-example","code":"#include <iostream>\n#include <stdexcept> // For std::runtime_error\n\n// Abstract class representing a machine that can print, fax, and scan documents\nclass Machine {\npublic:\n  virtual void printDocument() = 0;\n  virtual void faxDocument() = 0;\n  virtual void scanDocument() = 0;\n  virtual ~Machine() {}\n};\n\n// OldPrinter only supports printing, but it's forced to implement faxing and\n// scanning\nclass OldPrinter : public Machine {\npublic:\n  void printDocument() override {\n    std::cout << \"Printing document...\" << std::endl;\n  }\n\n  void faxDocument() override {\n    throw std::runtime_error(\"This printer cannot fax documents.\");\n  }\n\n  void scanDocument() override {\n    throw std::runtime_error(\"This printer cannot scan documents.\");\n  }\n};\n\n// Example usage\nint main() {\n  OldPrinter oldPrinter;\n  oldPrinter.printDocument();\n\n  try {\n    oldPrinter.faxDocument();\n  } catch (const std::runtime_error &e) {\n    std::cerr << \"Error: \" << e.what() << std::endl;\n  }\n\n  try {\n    oldPrinter.scanDocument();\n  } catch (const std::runtime_error &e) {\n    std::cerr << \"Error: \" << e.what() << std::endl;\n  }\n\n  return 0;\n}\n"}]},{"title":"Dependency Inversion","examples":[{"title":"Good Example","codeFile":"principles/solid/interface-segregation/good-example","code":"#include <iostream>\n\n// Interface for printing functionality\nclass Printer {\npublic:\n  virtual void printDocument() = 0;\n  virtual ~Printer() {}\n};\n\n// Interface for faxing functionality\nclass Fax {\npublic:\n  virtual void faxDocument() = 0;\n  virtual ~Fax() {}\n};\n\n// Interface for scanning functionality\nclass Scanner {\npublic:\n  virtual void scanDocument() = 0;\n  virtual ~Scanner() {}\n};\n\n// Simple printer only implements the Printer interface\nclass SimplePrinter : public Printer {\npublic:\n  void printDocument() override {\n    std::cout << \"Printing document...\" << std::endl;\n  }\n};\n\n// Multifunctional printer implements all interfaces\nclass MultifunctionalPrinter : public Printer, public Fax, public Scanner {\npublic:\n  void printDocument() override {\n    std::cout << \"Printing document...\" << std::endl;\n  }\n\n  void faxDocument() override {\n    std::cout << \"Faxing document...\" << std::endl;\n  }\n\n  void scanDocument() override {\n    std::cout << \"Scanning document...\" << std::endl;\n  }\n};\n\n// Example usage\nint main() {\n  SimplePrinter simplePrinter;\n  simplePrinter.printDocument();\n\n  MultifunctionalPrinter multiPrinter;\n  multiPrinter.printDocument();\n  multiPrinter.faxDocument();\n  multiPrinter.scanDocument();\n\n  return 0;\n}\n"},{"title":"Bad Example","codeFile":"principles/solid/interface-segregation/bad-example","code":"#include <iostream>\n#include <stdexcept> // For std::runtime_error\n\n// Abstract class representing a machine that can print, fax, and scan documents\nclass Machine {\npublic:\n  virtual void printDocument() = 0;\n  virtual void faxDocument() = 0;\n  virtual void scanDocument() = 0;\n  virtual ~Machine() {}\n};\n\n// OldPrinter only supports printing, but it's forced to implement faxing and\n// scanning\nclass OldPrinter : public Machine {\npublic:\n  void printDocument() override {\n    std::cout << \"Printing document...\" << std::endl;\n  }\n\n  void faxDocument() override {\n    throw std::runtime_error(\"This printer cannot fax documents.\");\n  }\n\n  void scanDocument() override {\n    throw std::runtime_error(\"This printer cannot scan documents.\");\n  }\n};\n\n// Example usage\nint main() {\n  OldPrinter oldPrinter;\n  oldPrinter.printDocument();\n\n  try {\n    oldPrinter.faxDocument();\n  } catch (const std::runtime_error &e) {\n    std::cerr << \"Error: \" << e.what() << std::endl;\n  }\n\n  try {\n    oldPrinter.scanDocument();\n  } catch (const std::runtime_error &e) {\n    std::cerr << \"Error: \" << e.what() << std::endl;\n  }\n\n  return 0;\n}\n"}]}],"principles_other":[{"title":"Don't Repeat Yourself (DRY)","examples":[{"title":"Good Example","codeFile":"principles/other/dry/good-example","code":"// Using default parameters and arrow functions for repeated logic\nfloat addTax(float price, float rate = 0.05) { return price + (price * rate); };\n"},{"title":"Bad Example","codeFile":"principles/other/dry/bad-example","code":"float addTaxForFood(float price) { return price + (price * 0.05); };\nfloat addTaxForElectronics(float price) { return price + (price * 0.05); };\n"}]},{"title":"Keep It Simple Stupid (KISS)","examples":[{"title":"Good Example","codeFile":"principles/other/kiss/good-example","code":"#include <iostream>\n\n// Function to check if a number is even\nbool isEven(int num) { return num % 2 == 0; }\n\n// Example usage\nint main() {\n  int num = 4;\n\n  std::cout << \"isEven(\" << num << \"): \" << (isEven(num) ? \"true\" : \"false\")\n            << std::endl;\n\n  return 0;\n}\n"},{"title":"Bad Example","codeFile":"principles/other/kiss/bad-example","code":"// there is no need for absolute value here\n#include <cmath> // For std::abs\n#include <iostream>\n\n// Function to check if a number is even, using std::abs\nbool isEven(int num) { return num % std::abs(2) == 0; }\n"}]},{"title":"You Aren't Gonna Need It (YAGNI)","examples":[{"codeFile":"principles/other/yagni/bad-example","code":"#include <exception>\n#include <iostream>\n#include <stdexcept>\n\nclass Calculator {\npublic:\n  double add(double a, double b) { return a + b; }\n\n  // Do not define methods unless they are used\n\n  double multiply(double a, double b) { return a * b; }\n\n  double divide(double a, double b) {\n    if (b == 0) {\n      throw new std::runtime_error(\"Division by zero is not allowed.\");\n    }\n    return a / b;\n  }\n\n  double subtract(double a, double b) { return a - b; }\n}\n"}]},{"title":"Law of Demeter (Principle of Least Knowledge)","examples":[{"title":"Good Example","codeFile":"principles/other/demeter/good-example","code":"#include <iostream>\n\nclass Wallet {\nprivate:\n  int money;\n\npublic:\n  Wallet() : money(100) {}\n\n  int getAmount() const { return money; }\n};\n\nclass Person {\nprivate:\n  Wallet wallet;\n\npublic:\n  Person() : wallet() {}\n\n  int getMoneyAmount() const { return wallet.getAmount(); }\n};\n\n// Assuming we have a struct or class for items to purchase\nclass Item {\npublic:\n  int price;\n\n  Item(int price) : price(price) {}\n};\n\nvoid purchase(const Item &item, const Person &buyer) {\n  if (buyer.getMoneyAmount() >= item.price) {\n    // Implement the purchase logic here...\n  }\n}\n\n// Example usage\nint main() {\n  Person buyer;\n  Item item(50); // Assume an item costs 50\n\n  purchase(item, buyer);\n\n  return 0;\n}\n"},{"title":"Bad Example","codeFile":"principles/other/demeter/bad-example","code":"#include <iostream>\n\nclass Wallet {\npublic:\n  struct Money {\n    int amount;\n  } money;\n\n  Wallet() { money.amount = 100; }\n};\n\nclass Person {\npublic:\n  Wallet wallet;\n\n  Person() : wallet() {}\n};\n\n// Assuming we have a struct or class for items to purchase\nclass Item {\npublic:\n  int price;\n\n  Item(int price) : price(price) {}\n};\n\nvoid purchase(const Item &item, const Person &buyer) {\n  if (buyer.wallet.money.amount >= item.price) {\n    // Implement the purchase logic here...\n  }\n}\n\n// Example usage\nint main() {\n  Person buyer;\n  Item item(50); // Assume an item costs 50\n\n  purchase(item, buyer);\n\n  return 0;\n}\n"}]},{"title":"Separation of Concerns","examples":[{"title":"Good Example","codeFile":"principles/other/separation/good-example","code":"#include <iostream>\n#include <string>\n#include <vector>\n\n// Authentication service\nclass AuthenticationService {\npublic:\n  bool login(const std::string &username, const std::string &password) {\n    // Authentication logic here\n    return true; // Dummy implementation\n  }\n\n  void logout() {\n    // Logout logic here\n  }\n};\n\n// Data service\nclass DataService {\npublic:\n  std::vector<int>\n  fetchData() { // Using std::vector<int> as a placeholder for any data type\n    // Data retrieval logic here\n    return {}; // Dummy implementation\n  }\n};\n\n// User controller\nclass UserController {\nprivate:\n  AuthenticationService &authService;\n\npublic:\n  UserController(AuthenticationService &authService)\n      : authService(authService) {}\n\n  bool loginUser(const std::string &username, const std::string &password) {\n    return authService.login(username, password);\n  }\n\n  void logoutUser() { authService.logout(); }\n};\n\n// Data controller\nclass DataController {\nprivate:\n  DataService &dataService;\n\npublic:\n  DataController(DataService &dataService) : dataService(dataService) {}\n\n  std::vector<int> getData() { return dataService.fetchData(); }\n};\n\n// Example usage\nint main() {\n  AuthenticationService authService;\n  DataService dataService;\n\n  UserController userController(authService);\n  DataController dataController(dataService);\n\n  // Simulate user login/logout\n  userController.loginUser(\"username\", \"password\");\n  userController.logoutUser();\n\n  // Retrieve data\n  auto data = dataController.getData();\n  std::cout << \"Data fetched. Size: \" << data.size() << std::endl;\n\n  return 0;\n}\n"},{"title":"Bad Example","codeFile":"principles/other/separation/bad-example","code":"#include <iostream>\n#include <string>\n#include <vector>\n\n// Authentication service\nclass AuthenticationService {\npublic:\n  bool login(const std::string &username, const std::string &password) {\n    // Authentication logic here\n    return true; // Dummy implementation\n  }\n\n  void logout() {\n    // Logout logic here\n  }\n};\n\n// Data service\nclass DataService {\npublic:\n  std::vector<int>\n  fetchData() { // Using std::vector<int> as a placeholder for any data type\n    // Data retrieval logic here\n    return {}; // Dummy implementation\n  }\n};\n\n// CombinedController class is responsible for both user authentication and data\n// retrieval\nclass CombinedController {\nprivate:\n  AuthenticationService &authService;\n  DataService &dataService;\n\npublic:\n  CombinedController(AuthenticationService &authService,\n                     DataService &dataService)\n      : authService(authService), dataService(dataService) {}\n\n  bool loginUser(const std::string &username, const std::string &password) {\n    // Authentication logic here\n    const bool isAuthenticated = authService.login(username, password);\n    if (isAuthenticated) {\n      // Retrieve user data (mixing concerns)\n      auto userData = dataService.fetchData();\n      std::cout << \"User data fetched. Size: \" << userData.size() << std::endl;\n    }\n    return isAuthenticated;\n  }\n\n  void logoutUser() {\n    // Logout logic here\n    authService.logout();\n  }\n};\n\n// Example usage\nint main() {\n  AuthenticationService authService;\n  DataService dataService;\n\n  CombinedController combinedController(authService, dataService);\n\n  // Simulate user login/logout\n  combinedController.loginUser(\"username\", \"password\");\n  combinedController.logoutUser();\n\n  return 0;\n}\n\n/**\n * The usage of std::vector<int> as a placeholder for fetched data illustrates\n * how to work with collections in C++, though in a real-world scenario, the\n * type and contents of the collection would depend on the specific\n * application's requirements.\n */\n"}]}]}}