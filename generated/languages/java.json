{"name":"Java","code":"java","ext":"java","birth":1995,"death":"N/A","inspiredBy":["C++","Simula67","Smalltalk","Ada 83","Mesa","Eiffel"],"inspiring":["Scala","Kotlin","Groovy","Clojure","J#"],"description":"Java is a widely used object-oriented programming language and computing platform first released by Sun Microsystems in 1995.\nIt follows the Write Once, Run Anywhere (WORA) principle, meaning that Java code compiled on one platform can run on any platform\nthat supports Java without the need for recompilation. Java applications are compiled to bytecode, which can run on any Java Virtual Machine (JVM).\nJava is used in a variety of computing platforms, from embedded devices and mobile phones to enterprise servers and supercomputers.\nJava's syntax is similar to C and C++, but it has fewer low-level facilities. Java is designed to be easy to use and is widely taught in\neducational institutions as an introductory programming language. It is also known for its strong security features, portability, and an extensive standard library\n(the Java Standard Edition (SE) API). Over the years, Java has evolved to support functional programming features such as lambda expressions and streams.\nThe language's architecture-neutral and garbage-collected environment, along with its robustness and scalability, have made it a popular choice for building\nenterprise-level applications, Android apps, and large systems.\n","patterns":{"patterns_behavioural":[{"title":"Chain Of Responsibility","examples":[{"codeFile":"patterns/behavioural/chain-of-responsibility/example","code":"// SupportHandler.java\ninterface SupportHandler {\n  void setNextHandler(SupportHandler handler);\n  String handleRequest(String request);\n}\n\n// Level1Support.java\nclass Level1Support implements SupportHandler {\n  private SupportHandler nextHandler;\n\n  @Override\n  public void setNextHandler(SupportHandler handler) {\n    this.nextHandler = handler;\n  }\n\n  @Override\n  public String handleRequest(String request) {\n    if (request.contains(\"basic\")) {\n      return \"Level 1 Support: Issue resolved at basic level.\";\n    } else if (this.nextHandler != null) {\n      return this.nextHandler.handleRequest(request);\n    } else {\n      return null; // No more handlers in the chain\n    }\n  }\n}\n\n// Level2Support.java\nclass Level2Support implements SupportHandler {\n  private SupportHandler nextHandler;\n\n  @Override\n  public void setNextHandler(SupportHandler handler) {\n    this.nextHandler = handler;\n  }\n\n  @Override\n  public String handleRequest(String request) {\n    if (request.contains(\"advanced\")) {\n      return \"Level 2 Support: Issue resolved at advanced level.\";\n    } else if (this.nextHandler != null) {\n      return this.nextHandler.handleRequest(request);\n    } else {\n      return null; // No more handlers in the chain\n    }\n  }\n}\n\n// Level3Support.java\nclass Level3Support implements SupportHandler {\n  @Override\n  public String handleRequest(String request) {\n    if (request.contains(\"bug\")) {\n      return \"Level 3 Support: Issue resolved at development level.\";\n    } else {\n      return \"Level 3 Support: Unable to resolve the issue.\";\n    }\n  }\n\n  @Override\n  public void setNextHandler(SupportHandler handler) {\n    throw new UnsupportedOperationException(\"Level 3 Support is the highest level and does not have a next handler.\");\n  }\n}\n\n// Main.java (Client code)\npublic class Main {\n  public static void main(String[] args) {\n    // Create instances of support handlers\n    Level1Support level1 = new Level1Support();\n    Level2Support level2 = new Level2Support();\n    Level3Support level3 = new Level3Support();\n\n    // Chain the handlers together\n    level1.setNextHandler(level2);\n    level2.setNextHandler(level3);\n\n    // Simulate support requests\n    String request1 = \"Fix basic login issue\";\n    String request2 = \"Debug advanced performance problem\";\n    String request3 = \"Investigate bug causing application crash\";\n\n    // Process requests through the chain of responsibility\n    System.out.println(level1.handleRequest(request1)); // Output: Level 1 Support: Issue resolved at basic level.\n    System.out.println(level1.handleRequest(request2)); // Output: Level 2 Support: Issue resolved at advanced level.\n    System.out.println(level1.handleRequest(request3)); // Output: Level 3 Support: Issue resolved at development level.\n  }\n}\n\n\n/**\n * This code demonstrates how the Chain of Responsibility pattern can be used in a support\n * ticket system. The SupportHandler interface defines the contract for handling support\n * requests, and concrete implementations (Level1Support, Level2Support, and Level3Support)\n * represent different levels of support. Each handler decides whether it can handle a\n * request or should pass it to the next handler in the chain.\n */\n"}]},{"title":"Command","examples":[{"codeFile":"patterns/behavioural/command/example","code":"// Command.java\ninterface Command {\n  void execute();\n}\n\n// Light.java (Receiver)\nclass Light {\n  public void turnOn() {\n    System.out.println(\"Light is on\");\n  }\n\n  public void turnOff() {\n    System.out.println(\"Light is off\");\n  }\n}\n\n// TurnOnCommand.java (Concrete Command)\nclass TurnOnCommand implements Command {\n  private Light light;\n\n  public TurnOnCommand(Light light) {\n    this.light = light;\n  }\n\n  @Override\n  public void execute() {\n    this.light.turnOn();\n  }\n}\n\n// TurnOffCommand.java (Concrete Command)\nclass TurnOffCommand implements Command {\n  private Light light;\n\n  public TurnOffCommand(Light light) {\n    this.light = light;\n  }\n\n  @Override\n  public void execute() {\n    this.light.turnOff();\n  }\n}\n\n// RemoteControl.java (Invoker)\nclass RemoteControl {\n  private Command[] commands = new Command[2]; // Assuming one slot for each command for simplicity\n\n  public void setCommand(int slot, Command command) {\n    this.commands[slot] = command;\n  }\n\n  public void executeCommand(int slot) {\n    if (commands[slot] != null) {\n      commands[slot].execute();\n    }\n  }\n}\n\n// Main.java (Client code)\npublic class Main {\n  public static void main(String[] args) {\n    Light light = new Light(); // Receiver\n\n    Command turnOnCommand = new TurnOnCommand(light); // Concrete Command\n    Command turnOffCommand = new TurnOffCommand(light); // Concrete Command\n\n    RemoteControl remoteControl = new RemoteControl(); // Invoker\n    remoteControl.setCommand(0, turnOnCommand);\n    remoteControl.setCommand(1, turnOffCommand);\n\n    remoteControl.executeCommand(0); // Executes TurnOnCommand\n    remoteControl.executeCommand(1); // Executes TurnOffCommand\n  }\n}\n\n\n/**\n * This code demonstrates how the Command pattern can be used in a remote control\n * system to control a light. The Command interface defines the contract for executing\n * commands, and concrete command classes (TurnOnCommand and TurnOffCommand) encapsulate\n * the actions to be performed on the Light receiver object. The RemoteControl acts as\n * the invoker, which holds and triggers the commands. Pressing buttons on the remote\n * control executes the corresponding commands, resulting in the light being turned on\n * and off.\n */\n"}]},{"title":"Iterator","examples":[{"codeFile":"patterns/behavioural/iterator/example","code":"// CustomIterator.java\npublic class CustomIterator<T> {\n  private T[] collection;\n  private int index;\n\n  public CustomIterator(T[] collection) {\n    this.collection = collection;\n    this.index = 0;\n  }\n\n  public T next() {\n    return collection[index++];\n  }\n\n  public boolean hasNext() {\n    return index < collection.length;\n  }\n}\n\n// Main.java (Client code)\npublic class Main {\n  public static void main(String[] args) {\n    // Using an array of Object to mix integers and strings, similar to the TypeScript example\n    Object[] items = {1, \"two\", 3, \"four\", 5};\n    CustomIterator<Object> iterator = new CustomIterator<>(items);\n\n    while (iterator.hasNext()) {\n      System.out.println(iterator.next());\n    }\n  }\n}\n\n\n/**\n * In this example, the Iterator pattern is used to iterate over a collection of books\n * stored in a BookCollection. The Iterator interface defines methods for checking if\n * there are more elements (hasNext) and retrieving the next element (next). The\n * ArrayIterator class provides a concrete implementation of the iterator for an array\n * of books. The BookCollection class implements the Iterable interface, which allows\n * it to create iterators for iterating over its collection of books. Finally, in the\n * client code, we create a BookCollection, add books to it, and iterate over the\n * collection using the iterator, printing each book's name.\n */\n"}]},{"title":"Mediator","examples":[{"codeFile":"patterns/behavioural/mediator/example","code":"// ChatMediator.java\ninterface ChatMediator {\n  void sendMessage(String message, User user);\n}\n\n// ChatRoom.java\nclass ChatRoom implements ChatMediator {\n  @Override\n  public void sendMessage(String message, User user) {\n    System.out.println(\"[\" + user.getName() + \"] sends message: \" + message);\n  }\n}\n\n// User.java\ninterface User {\n  void send(String message);\n  void receive(String message);\n  String getName();\n}\n\n// ChatUser.java\nclass ChatUser implements User {\n  private String name;\n  private ChatMediator mediator;\n\n  public ChatUser(String name, ChatMediator mediator) {\n    this.name = name;\n    this.mediator = mediator;\n  }\n\n  @Override\n  public void send(String message) {\n    System.out.println(\"[\" + this.name + \"] sends message: \" + message);\n    this.mediator.sendMessage(message, this);\n  }\n\n  @Override\n  public void receive(String message) {\n    System.out.println(\"[\" + this.name + \"] received message: \" + message);\n  }\n\n  @Override\n  public String getName() {\n    return this.name;\n  }\n}\n\n// Main.java (Client code)\npublic class Main {\n  public static void main(String[] args) {\n    ChatMediator chatMediator = new ChatRoom();\n\n    User user1 = new ChatUser(\"User1\", chatMediator);\n    User user2 = new ChatUser(\"User2\", chatMediator);\n\n    user1.send(\"Hello, User2!\");\n    user2.send(\"Hi, User1!\");\n  }\n}\n\n/**\n * In this example, the Mediator pattern is used to facilitate communication between\n * users in a chat room. The ChatMediator interface defines a method sendMessage for\n * sending messages to users. The ChatRoom class provides a concrete implementation\n * of the mediator for managing communication between users in the chat room.\n *\n * The User interface defines methods send and receive for sending and receiving messages,\n * respectively, as well as a method getName for getting the user's name. The ChatUser\n * class implements the User interface and interacts with the mediator to send and\n * receive messages.\n *\n * In the client code, we create a chat room mediator and two chat users. Users can send\n * messages to each other by calling the send method, which delegates the message sending\n * to the mediator. When a message is received, the mediator distributes it to the\n * appropriate user's receive method.\n */\n"}]},{"title":"Memento","examples":[{"codeFile":"patterns/behavioural/memento/example","code":"// Editor.java (Originator)\npublic class Editor {\n  private String text;\n\n  public Editor(String text) {\n    this.text = text;\n  }\n\n  public void setText(String text) {\n    this.text = text;\n  }\n\n  public String getText() {\n    return text;\n  }\n\n  public Memento save() {\n    return new Memento(this.text);\n  }\n\n  public void restore(Memento memento) {\n    this.text = memento.getState();\n  }\n}\n\n// Memento.java\npublic class Memento {\n  private final String state;\n\n  public Memento(String state) {\n    this.state = state;\n  }\n\n  public String getState() {\n    return state;\n  }\n}\n\n// History.java (Caretaker)\npublic class History {\n  private java.util.List<Memento> mementos = new java.util.ArrayList<>();\n\n  public void addMemento(Memento memento) {\n    mementos.add(memento);\n  }\n\n  public Memento getLatestMemento() {\n    if (mementos.isEmpty()) {\n      throw new IllegalStateException(\"No mementos available\");\n    }\n    return mementos.get(mementos.size() - 1);\n  }\n}\n\n// Main.java (Client code)\npublic class Main {\n  public static void main(String[] args) {\n    Editor editor = new Editor(\"Initial text\");\n    History history = new History();\n\n    history.addMemento(editor.save());\n    editor.setText(\"Modified text\");\n    history.addMemento(editor.save());\n\n    editor.restore(history.getLatestMemento());\n    System.out.println(editor.getText()); // Output: Modified text\n  }\n}\n\n/**\n * In this example, the Editor class represents an object whose state can be modified. The save\n * method creates a memento containing the current state of the editor, and the restore method\n * restores the editor's state from a given memento.\n *\n * The Memento class represents the stored state of the editor at a particular point in time.\n *\n * The History class is responsible for maintaining a list of mementos. It provides methods\n * to add a memento to the history and retrieve the most recent memento.\n *\n * In the client code, we create an editor object and a history object. We modify the editor's\n * state, save it to a memento, modify it again, and then restore it to the previous state using\n * the memento stored in the history.\n */\n"}]},{"title":"Observer","examples":[{"codeFile":"patterns/behavioural/observer/example","code":"// Subject.java\ninterface Subject {\n    void subscribe(Observer observer);\n    void unsubscribe(Observer observer);\n    void notifyObservers(String data);\n}\n\n// ConcreteSubject.java\nclass ConcreteSubject implements Subject {\n    private java.util.List<Observer> observers = new java.util.ArrayList<>();\n\n    @Override\n    public void subscribe(Observer observer) {\n        observers.add(observer);\n    }\n\n    @Override\n    public void unsubscribe(Observer observer) {\n        observers.remove(observer);\n    }\n\n    @Override\n    public void notifyObservers(String data) {\n        for (Observer observer : observers) {\n            observer.update(data);\n        }\n    }\n}\n\n// Observer.java\ninterface Observer {\n    void update(String data);\n}\n\n// ConcreteObserver.java\nclass ConcreteObserver implements Observer {\n    @Override\n    public void update(String data) {\n        System.out.println(\"Observer received data: \" + data);\n    }\n}\n\n// Main.java (Client code)\npublic class Main {\n    public static void main(String[] args) {\n        ConcreteSubject subject = new ConcreteSubject();\n        Observer observer1 = new ConcreteObserver();\n        Observer observer2 = new ConcreteObserver();\n\n        subject.subscribe(observer1);\n        subject.subscribe(observer2);\n\n        subject.notifyObservers(\"Hello Observers!\");\n\n        subject.unsubscribe(observer2);\n        subject.notifyObservers(\"Goodbye Observers!\");\n    }\n}\n\n\n/**\n * In this example, the Editor class represents an object whose state can be modified.\n * The save method creates a memento containing the current state of the editor, and\n * the restore method restores the editor's state from a given memento.\n *\n * The Memento class represents the stored state of the editor at a particular point in time.\n * The History class is responsible for maintaining a list of mementos. It provides\n * methods to add a memento to the history and retrieve the most recent memento.\n *\n * In the client code, we create an editor object and a history object. We modify the\n * editor's state, save it to a memento, modify it again, and then restore it to the\n * previous state using the memento stored in the history.\n */\n"}]},{"title":"State","examples":[{"codeFile":"patterns/behavioural/state/example","code":"// TrafficLightState.java\ninterface TrafficLightState {\n  void changeState(TrafficLight trafficLight);\n}\n\n// RedState.java\nclass RedState implements TrafficLightState {\n  @Override\n  public void changeState(TrafficLight trafficLight) {\n    System.out.println(\"Traffic light is now RED. Stop!\");\n    // In a real application, consider using a Timer for state transition\n  }\n}\n\n// YellowState.java\nclass YellowState implements TrafficLightState {\n  @Override\n  public void changeState(TrafficLight trafficLight) {\n    System.out.println(\"Traffic light is now YELLOW. Prepare to stop or proceed with caution.\");\n    // In a real application, consider using a Timer for state transition\n  }\n}\n\n// GreenState.java\nclass GreenState implements TrafficLightState {\n  @Override\n  public void changeState(TrafficLight trafficLight) {\n    System.out.println(\"Traffic light is now GREEN. Go!\");\n    // In a real application, consider using a Timer for state transition\n  }\n}\n\n// TrafficLight.java\nclass TrafficLight {\n  private TrafficLightState state;\n\n  public TrafficLight() {\n    // Initial state is Red\n    this.state = new RedState();\n    this.state.changeState(this);\n  }\n\n  public void setState(TrafficLightState state) {\n    this.state = state;\n    this.state.changeState(this);\n  }\n}\n\n// Main.java (Client code)\npublic class Main {\n  public static void main(String[] args) {\n    TrafficLight trafficLight = new TrafficLight();\n\n    // Manually trigger state transitions\n    trafficLight.setState(new GreenState());\n    trafficLight.setState(new YellowState());\n    trafficLight.setState(new RedState());\n  }\n}\n\n/**\n * The TrafficLightState interface defines the common behavior for all traffic light states.\n * Each concrete state implements this interface and provides its own implementation of the\n * changeState method.\n *\n * Concrete state classes (RedState, YellowState, and GreenState) represent different states\n * of the traffic light and define how the traffic light behaves in each state.\n *\n * The TrafficLight class acts as the context and maintains a reference to the current state.\n * It provides a method setState to change the state of the traffic light.\n *\n * In the client code, we create a TrafficLight object and change its state to simulate the\n * behavior of a traffic light system.\n */\n"}]},{"title":"Strategy","examples":[{"codeFile":"patterns/behavioural/strategy/example","code":"// PaymentStrategy.java\ninterface PaymentStrategy {\n  void pay(int amount);\n}\n\n// CreditCardPaymentStrategy.java\nclass CreditCardPaymentStrategy implements PaymentStrategy {\n  private String cardNumber;\n  private String expiryDate;\n  private String cvv;\n\n  public CreditCardPaymentStrategy(String cardNumber, String expiryDate, String cvv) {\n    this.cardNumber = cardNumber;\n    this.expiryDate = expiryDate;\n    this.cvv = cvv;\n  }\n\n  @Override\n  public void pay(int amount) {\n    System.out.println(\"Processing credit card payment of $\" + amount + \" with card number \" + this.cardNumber);\n    // Logic to process payment via credit card\n  }\n}\n\n// PayPalPaymentStrategy.java\nclass PayPalPaymentStrategy implements PaymentStrategy {\n  private String email;\n  private String password;\n\n  public PayPalPaymentStrategy(String email, String password) {\n    this.email = email;\n    this.password = password;\n  }\n\n  @Override\n  public void pay(int amount) {\n    System.out.println(\"Processing PayPal payment of $\" + amount + \" with email \" + this.email);\n    // Logic to process payment via PayPal\n  }\n}\n\n// PaymentProcessor.java (Context)\nclass PaymentProcessor {\n  private PaymentStrategy paymentStrategy;\n\n  public void setPaymentStrategy(PaymentStrategy paymentStrategy) {\n    this.paymentStrategy = paymentStrategy;\n  }\n\n  public void processPayment(int amount) {\n    if (this.paymentStrategy != null) {\n      this.paymentStrategy.pay(amount);\n    } else {\n      System.out.println(\"Payment strategy not set. Please select a payment method.\");\n    }\n  }\n}\n\n// Main.java (Client code)\npublic class Main {\n  public static void main(String[] args) {\n    PaymentProcessor paymentProcessor = new PaymentProcessor();\n\n    // Select a payment method (strategy) dynamically\n    PaymentStrategy creditCardStrategy = new CreditCardPaymentStrategy(\"1234 5678 9012 3456\", \"12/25\", \"123\");\n    paymentProcessor.setPaymentStrategy(creditCardStrategy);\n    paymentProcessor.processPayment(100);\n\n    // Change payment method (strategy)\n    PaymentStrategy payPalStrategy = new PayPalPaymentStrategy(\"example@example.com\", \"password\");\n    paymentProcessor.setPaymentStrategy(payPalStrategy);\n    paymentProcessor.processPayment(50);\n  }\n}\n\n/**\n * The PaymentStrategy interface defines the common behavior for all payment strategies. Each concrete payment\n * strategy class implements this interface and provides its own implementation of the pay method.\n *\n * Concrete strategy classes (CreditCardPaymentStrategy and PayPalPaymentStrategy) represent different payment\n * methods and define how payments are processed for each method.\n *\n * The PaymentProcessor class acts as the context and maintains a reference to the current payment strategy.\n * It provides a setter method setPaymentStrategy to dynamically set the payment strategy, and a processPayment\n * method to process payments using the selected strategy.\n *\n * In the client code, we create a PaymentProcessor object and dynamically select the payment method (strategy)\n * based on user input. We then process payments using the selected strategy.\n *\n */\n"}]},{"title":"Template Method","examples":[{"codeFile":"patterns/behavioural/template-method/example","code":"// Breakfast.java\nabstract class Breakfast {\n  // Template method\n  public final void prepare() {\n    boilWater();\n    addIngredients();\n    cook();\n    serve();\n  }\n\n  // Abstract methods to be implemented by subclasses\n  abstract void addIngredients();\n  abstract void cook();\n\n  // Concrete methods\n  void boilWater() {\n    System.out.println(\"Boiling water...\");\n  }\n\n  void serve() {\n    System.out.println(\"Breakfast is served!\");\n  }\n}\n\n// OmeletteBreakfast.java\nclass OmeletteBreakfast extends Breakfast {\n  @Override\n  void addIngredients() {\n    System.out.println(\"Adding eggs, cheese, and vegetables to the pan.\");\n  }\n\n  @Override\n  void cook() {\n    System.out.println(\"Cooking the omelette until golden brown.\");\n  }\n}\n\n// PancakeBreakfast.java\nclass PancakeBreakfast extends Breakfast {\n  @Override\n  void addIngredients() {\n    System.out.println(\"Mixing flour, eggs, milk, and sugar to make the batter.\");\n  }\n\n  @Override\n  void cook() {\n    System.out.println(\"Pouring the batter onto the griddle and flipping until cooked.\");\n  }\n}\n\n// Main.java (Client code)\npublic class Main {\n  public static void main(String[] args) {\n    System.out.println(\"Preparing Omelette Breakfast:\");\n    Breakfast omeletteBreakfast = new OmeletteBreakfast();\n    omeletteBreakfast.prepare();\n\n    System.out.println(\"\\nPreparing Pancake Breakfast:\");\n    Breakfast pancakeBreakfast = new PancakeBreakfast();\n    pancakeBreakfast.prepare();\n  }\n}\n\n/**\n * In this example, we have an abstract class Breakfast representing the template method pattern. It defines\n * the steps of preparing breakfast in the prepare() method, which serves as the template method. The abstract\n * methods addIngredients() and cook() are placeholders for the specific steps that vary between different\n * types of breakfasts.\n *\n * Subclasses such as OmeletteBreakfast and PancakeBreakfast extend the Breakfast class and implement the\n * abstract methods to provide specific implementations for adding ingredients and cooking. The template\n * method prepare() orchestrates the sequence of steps required to prepare each type of breakfast.\n *\n */\n"}]},{"title":"Visitor","examples":[{"codeFile":"patterns/behavioural/visitor/example","code":"// AnimalVisitor.java\ninterface AnimalVisitor {\n  void visitLion(Lion lion);\n  void visitElephant(Elephant elephant);\n  void visitGiraffe(Giraffe giraffe);\n}\n\n// AnimalFeeder.java\nclass AnimalFeeder implements AnimalVisitor {\n  @Override\n  public void visitLion(Lion lion) {\n    System.out.println(\"Feeding meat to \" + lion.getName() + \".\");\n  }\n\n  @Override\n  public void visitElephant(Elephant elephant) {\n    System.out.println(\"Feeding hay to \" + elephant.getName() + \".\");\n  }\n\n  @Override\n  public void visitGiraffe(Giraffe giraffe) {\n    System.out.println(\"Feeding leaves to \" + giraffe.getName() + \".\");\n  }\n}\n\n// Animal.java\ninterface Animal {\n  void accept(AnimalVisitor visitor);\n  String getName();\n}\n\n// Lion.java\nclass Lion implements Animal {\n  private String name;\n\n  public Lion(String name) {\n    this.name = name;\n  }\n\n  @Override\n  public String getName() {\n    return this.name;\n  }\n\n  @Override\n  public void accept(AnimalVisitor visitor) {\n    visitor.visitLion(this);\n  }\n}\n\n// Elephant.java\nclass Elephant implements Animal {\n  private String name;\n\n  public Elephant(String name) {\n    this.name = name;\n  }\n\n  @Override\n  public String getName() {\n    return this.name;\n  }\n\n  @Override\n  public void accept(AnimalVisitor visitor) {\n    visitor.visitElephant(this);\n  }\n}\n\n// Giraffe.java\nclass Giraffe implements Animal {\n  private String name;\n\n  public Giraffe(String name) {\n    this.name = name;\n  }\n\n  @Override\n  public String getName() {\n    return this.name;\n  }\n\n  @Override\n  public void accept(AnimalVisitor visitor) {\n    visitor.visitGiraffe(this);\n  }\n}\n\n// Zoo.java\nclass Zoo {\n  private java.util.List<Animal> animals = new java.util.ArrayList<>();\n\n  public void addAnimal(Animal animal) {\n    animals.add(animal);\n  }\n\n  public void performOperation(AnimalVisitor visitor) {\n    for (Animal animal : animals) {\n      animal.accept(visitor);\n    }\n  }\n}\n\n// Main.java (Client code)\npublic class Main {\n  public static void main(String[] args) {\n    Zoo zoo = new Zoo();\n    zoo.addAnimal(new Lion(\"Simba\"));\n    zoo.addAnimal(new Elephant(\"Dumbo\"));\n    zoo.addAnimal(new Giraffe(\"Melman\"));\n\n    AnimalFeeder feeder = new AnimalFeeder();\n    zoo.performOperation(feeder);\n  }\n}\n\n\n/**\n * The AnimalVisitor interface defines the operations that can be performed on different types of animals.\n *\n * The AnimalFeeder class is a concrete visitor that implements feeding operations for lions, elephants,\n * and giraffes.\n *\n * The Animal interface represents animals, and concrete animal classes (Lion, Elephant, and Giraffe)\n * implement this interface and define how they accept a visitor.\n *\n * The Zoo class represents the object structure that contains a collection of animals. It has methods to\n * add animals and perform an operation (feeding in this case) using a visitor.\n *\n * Finally, in the client code, we create a zoo, add animals to it, create a visitor (animal feeder), and\n * then perform the feeding operation on each animal in the zoo using the visitor.\n */\n"}]}],"patterns_creational":[{"title":"Factory Method","examples":[{"codeFile":"patterns/creational/factory-method/example","code":"// Vehicle.java\ninterface Vehicle {\n  void drive();\n}\n\n// Car.java\nclass Car implements Vehicle {\n  @Override\n  public void drive() {\n    System.out.println(\"Driving a car...\");\n  }\n}\n\n// Truck.java\nclass Truck implements Vehicle {\n  @Override\n  public void drive() {\n    System.out.println(\"Driving a truck...\");\n  }\n}\n\n// VehicleFactory.java\nabstract class VehicleFactory {\n  abstract Vehicle createVehicle();\n\n  public void deliverVehicle() {\n    Vehicle vehicle = createVehicle();\n    System.out.println(\"Delivering the vehicle...\");\n    vehicle.drive();\n  }\n}\n\n// CarFactory.java\nclass CarFactory extends VehicleFactory {\n  @Override\n  Vehicle createVehicle() {\n    System.out.println(\"Creating a car...\");\n    return new Car();\n  }\n}\n\n// TruckFactory.java\nclass TruckFactory extends VehicleFactory {\n  @Override\n  Vehicle createVehicle() {\n    System.out.println(\"Creating a truck...\");\n    return new Truck();\n  }\n}\n\n// Main.java (Client code)\npublic class Main {\n  public static void main(String[] args) {\n    VehicleFactory carFactory = new CarFactory();\n    carFactory.deliverVehicle();\n\n    VehicleFactory truckFactory = new TruckFactory();\n    truckFactory.deliverVehicle();\n  }\n}\n\n/**\n * The Vehicle interface defines a common interface for all vehicles, which includes a drive() method.\n *\n * The Car and Truck classes are concrete implementations of the Vehicle interface.\n *\n * The VehicleFactory class is an abstract class representing a creator. It declares the createVehicle()\n * method, which serves as the Factory Method for creating vehicles. The deliverVehicle() method is a\n * common operation that uses the Factory Method to create and deliver a vehicle.\n *\n * The CarFactory and TruckFactory classes are concrete implementations of the VehicleFactory class.\n * They override the createVehicle() method to create specific types of vehicles (i.e., cars and trucks).\n *\n */\n"}]},{"title":"Abstract Factory","examples":[{"codeFile":"patterns/creational/abstract-factory/example","code":"// Abstract Factory interface\ninterface FurnitureFactory {\n  createChair(): Chair;\n  createTable(): Table;\n}\n\n// Concrete Factory 1: Modern Furniture Factory\nclass ModernFurnitureFactory implements FurnitureFactory {\n  createChair(): Chair {\n    return new ModernChair();\n  }\n\n  createTable(): Table {\n    return new ModernTable();\n  }\n}\n\n// Concrete Factory 2: Vintage Furniture Factory\nclass VintageFurnitureFactory implements FurnitureFactory {\n  createChair(): Chair {\n    return new VintageChair();\n  }\n\n  createTable(): Table {\n    return new VintageTable();\n  }\n}\n\n// Abstract Product: Chair\ninterface Chair {\n  sitOn(): void;\n}\n\n// Concrete Product: Modern Chair\nclass ModernChair implements Chair {\n  sitOn(): void {\n    console.log(\"Sitting on a modern chair.\");\n  }\n}\n\n// Concrete Product: Vintage Chair\nclass VintageChair implements Chair {\n  sitOn(): void {\n    console.log(\"Sitting on a vintage chair.\");\n  }\n}\n\n// Abstract Product: Table\ninterface Table {\n  putOn(): void;\n}\n\n// Concrete Product: Modern Table\nclass ModernTable implements Table {\n  putOn(): void {\n    console.log(\"Putting something on a modern table.\");\n  }\n}\n\n// Concrete Product: Vintage Table\nclass VintageTable implements Table {\n  putOn(): void {\n    console.log(\"Putting something on a vintage table.\");\n  }\n}\n\n// Client code\nfunction createFurniture(factory: FurnitureFactory): void {\n  const chair = factory.createChair();\n  const table = factory.createTable();\n\n  console.log(\"Created furniture:\");\n  chair.sitOn();\n  table.putOn();\n}\n\n// Creating modern furniture\nconsole.log(\"Creating modern furniture:\");\ncreateFurniture(new ModernFurnitureFactory());\n\n// Creating vintage furniture\nconsole.log(\"\\nCreating vintage furniture:\");\ncreateFurniture(new VintageFurnitureFactory());\n\n/**\n * The FurnitureFactory interface declares methods for creating chairs and tables.\n *\n * Concrete factories (ModernFurnitureFactory and VintageFurnitureFactory) implement the\n * FurnitureFactory interface to produce modern and vintage furniture, respectively.\n *\n * The Chair interface declares a method for sitting on a chair, and concrete chair classes\n * (ModernChair and VintageChair) implement this interface.\n *\n * The Table interface declares a method for putting something on a table, and concrete table\n * classes (ModernTable and VintageTable) implement this interface.\n * The createFurniture function acts as a client and receives a FurnitureFactory as a parameter.\n * It creates a chair and a table using the factory and then performs actions on the created furniture.\n *\n */\n"}]},{"title":"Builder","examples":[{"codeFile":"patterns/creational/builder/example","code":"// Computer.java (Product)\nclass Computer {\n  private String cpu;\n  private int ram;\n  private int storage;\n  private String gpu;\n  private int screenSize;\n\n  public Computer(String cpu, int ram, int storage, String gpu, int screenSize) {\n    this.cpu = cpu;\n    this.ram = ram;\n    this.storage = storage;\n    this.gpu = gpu;\n    this.screenSize = screenSize;\n  }\n\n  public void displaySpecs() {\n    System.out.println(\"CPU: \" + this.cpu);\n    System.out.println(\"RAM: \" + this.ram + \" GB\");\n    System.out.println(\"Storage: \" + this.storage + \" GB\");\n    System.out.println(\"GPU: \" + this.gpu);\n    System.out.println(\"Screen Size: \" + this.screenSize + \" inches\");\n  }\n}\n\n// ComputerBuilder.java (Builder interface)\ninterface ComputerBuilder {\n  void setCPU(String cpu);\n  void setRAM(int ram);\n  void setStorage(int storage);\n  void setGPU(String gpu);\n  void setScreenSize(int screenSize);\n  Computer getResult();\n}\n\n// GamingComputerBuilder.java (Concrete Builder)\nclass GamingComputerBuilder implements ComputerBuilder {\n  private Computer computer;\n\n  public GamingComputerBuilder() {\n    // Initialize with default values\n    computer = new Computer(\"\", 0, 0, \"\", 0);\n  }\n\n  @Override\n  public void setCPU(String cpu) { this.computer = new Computer(cpu, computer.getRam(), computer.getStorage(), computer.getGpu(), computer.getScreenSize()); }\n\n  @Override\n  public void setRAM(int ram) { this.computer = new Computer(computer.getCpu(), ram, computer.getStorage(), computer.getGpu(), computer.getScreenSize()); }\n\n  @Override\n  public void setStorage(int storage) { this.computer = new Computer(computer.getCpu(), computer.getRam(), storage, computer.getGpu(), computer.getScreenSize()); }\n\n  @Override\n  public void setGPU(String gpu) { this.computer = new Computer(computer.getCpu(), computer.getRam(), computer.getStorage(), gpu, computer.getScreenSize()); }\n\n  @Override\n  public void setScreenSize(int screenSize) { this.computer = new Computer(computer.getCpu(), computer.getRam(), computer.getStorage(), computer.getGpu(), screenSize); }\n\n  @Override\n  public Computer getResult() {\n    return computer;\n  }\n}\n\n// ComputerBuilderDirector.java (Director)\nclass ComputerBuilderDirector {\n  private ComputerBuilder builder;\n\n  public ComputerBuilderDirector(ComputerBuilder builder) {\n    this.builder = builder;\n  }\n\n  public void constructGamingComputer() {\n    builder.setCPU(\"Intel Core i9\");\n    builder.setRAM(32);\n    builder.setStorage(1000);\n    builder.setGPU(\"NVIDIA GeForce RTX 3080\");\n    builder.setScreenSize(27);\n  }\n}\n\n// Main.java (Client code)\npublic class Main {\n  public static void main(String[] args) {\n    ComputerBuilder builder = new GamingComputerBuilder();\n    ComputerBuilderDirector director = new ComputerBuilderDirector(builder);\n    director.constructGamingComputer();\n    Computer gamingComputer = builder.getResult();\n    System.out.println(\"Gaming Computer Specifications:\");\n    gamingComputer.displaySpecs();\n  }\n}\n\n/**\n * The Computer class represents the product we want to build, which is a custom computer with\n * various specifications like CPU, RAM, storage, GPU, and screen size.\n *\n * The ComputerBuilder interface defines methods for setting each component of the computer.\n *\n * The GamingComputerBuilder class is a concrete builder that implements the ComputerBuilder\n * interface to construct a gaming computer with specific configurations.\n *\n * The ComputerBuilderDirector class is responsible for directing the construction process using\n * a builder.\n *\n * The client code creates a GamingComputerBuilder, passes it to the director, and instructs the\n * director to construct a gaming computer. Finally, it retrieves the constructed gaming computer\n * and displays its specifications.\n *\n */\n"}]},{"title":"Prototype","examples":[{"codeFile":"patterns/creational/prototype/example","code":"// UserProfile.java\ninterface UserProfile {\n  UserProfile clone();\n  void customizeProfile(UserProfileSettings settings);\n  void displayProfile();\n}\n\n// DefaultUserProfile.java\nclass DefaultUserProfile implements UserProfile {\n  private String username;\n  private String bio;\n  private String profilePicture;\n\n  public DefaultUserProfile(String username, String bio, String profilePicture) {\n    this.username = username;\n    this.bio = bio;\n    this.profilePicture = profilePicture;\n  }\n\n  @Override\n  public UserProfile clone() {\n    return new DefaultUserProfile(this.username, this.bio, this.profilePicture);\n  }\n\n  @Override\n  public void customizeProfile(UserProfileSettings settings) {\n    if (settings.username != null) {\n      this.username = settings.username;\n    }\n    if (settings.bio != null) {\n      this.bio = settings.bio;\n    }\n    if (settings.profilePicture != null) {\n      this.profilePicture = settings.profilePicture;\n    }\n  }\n\n  @Override\n  public void displayProfile() {\n    System.out.println(\"Username: \" + this.username);\n    System.out.println(\"Bio: \" + this.bio);\n    System.out.println(\"Profile Picture: \" + this.profilePicture);\n  }\n}\n\n// UserProfileSettings.java\nclass UserProfileSettings {\n  String username;\n  String bio;\n  String profilePicture;\n\n  public UserProfileSettings(String username, String bio, String profilePicture) {\n    this.username = username;\n    this.bio = bio;\n    this.profilePicture = profilePicture;\n  }\n}\n\n// Main.java (Client code)\npublic class Main {\n  public static void main(String[] args) {\n    DefaultUserProfile defaultProfile = new DefaultUserProfile(\"user123\", \"Welcome to my profile!\", \"default.jpg\");\n\n    // Clone the default profile to create a customized profile\n    UserProfile customizedProfile = defaultProfile.clone();\n    customizedProfile.customizeProfile(new UserProfileSettings(null, \"I'm a software developer.\", \"avatar.jpg\"));\n\n    // Display both profiles\n    System.out.println(\"Default Profile:\");\n    defaultProfile.displayProfile();\n\n    System.out.println(\"\\nCustomized Profile:\");\n    customizedProfile.displayProfile();\n  }\n}\n\n\n/**\n * The UserProfile interface defines methods for cloning a profile, customizing profile settings, and\n * displaying the profile.\n *\n * The DefaultUserProfile class is a concrete implementation of the UserProfile interface. It represents\n * the default user profile with properties like username, bio, and profile picture. The clone()\n * method creates a copy of the profile, and the customizeProfile() method allows modifying profile\n * settings.\n *\n * The UserProfileSettings interface defines optional settings that can be customized in a user profile.\n *\n * In the client code, we create a default user profile and then clone it to create a customized profile\n * with updated settings. Both profiles can be displayed independently, demonstrating the use of the\n * Prototype pattern to create new objects by copying existing ones.\n */\n"}]},{"title":"Singleton","examples":[{"codeFile":"patterns/creational/singleton/example","code":"public class Logger {\n  private static Logger instance;\n  private java.util.List<String> logHistory = new java.util.ArrayList<>();\n\n  // Private constructor to prevent instantiation from outside the class\n  private Logger() { }\n\n  // Static method to retrieve the singleton instance\n  public static Logger getInstance() {\n    if (instance == null) {\n      instance = new Logger();\n    }\n    return instance;\n  }\n\n  // Method to log messages\n  public void log(String message) {\n    String timestamp = java.time.LocalDateTime.now().toString();\n    String logEntry = \"[\" + timestamp + \"] \" + message;\n    logHistory.add(logEntry);\n    System.out.println(logEntry);\n  }\n\n  // Method to retrieve log history\n  public java.util.List<String> getLogHistory() {\n    return logHistory;\n  }\n}\n\n// Main.java (Client code)\npublic class Main {\n  public static void main(String[] args) {\n    Logger logger1 = Logger.getInstance();\n    Logger logger2 = Logger.getInstance();\n\n    System.out.println(logger1 == logger2); // Output: true, both references point to the same instance\n\n    logger1.log(\"User logged in\");\n    logger2.log(\"Data saved to database\");\n\n    System.out.println(logger1.getLogHistory());\n  }\n}\n\n/**\n * The Logger class has a private static instance property that holds the single instance of the logger.\n *\n * The constructor is made private to prevent instantiation from outside the class.\n *\n * The getInstance() method is a static method that returns the singleton instance of the logger. It\n * ensures that only one instance of the logger is created throughout the application.\n *\n * The log() method logs a message along with a timestamp and adds the log entry to the logHistory array.\n *\n * The getLogHistory() method retrieves the log history.\n *\n * In the client code, both logger1 and logger2 references point to the same instance of the logger\n * obtained using the getInstance() method.\n *\n * Logging messages using either logger1 or logger2 will result in consistent logging behavior, and the\n * log history can be retrieved from either instance.\n */\n"}]}],"patterns_structural":[{"title":"Adapter","examples":[{"codeFile":"patterns/structural/adapter/example","code":"// Mp3Player.java (Adaptee)\nclass Mp3Player {\n  public void playMp3(String fileName) {\n    System.out.println(\"Playing MP3 file: \" + fileName);\n  }\n}\n\n// AudioPlayer.java (Target interface)\ninterface AudioPlayer {\n  void play(String fileName);\n}\n\n// OggToMp3Adapter.java (Adapter)\nclass OggToMp3Adapter implements AudioPlayer {\n  private Mp3Player mp3Player;\n\n  public OggToMp3Adapter() {\n    this.mp3Player = new Mp3Player();\n  }\n\n  @Override\n  public void play(String fileName) {\n    // Convert OGG to MP3 and play using the MP3 player\n    System.out.println(\"Converting OGG file '\" + fileName + \"' to MP3 format\");\n    String mp3FileName = convertToMp3(fileName);\n    mp3Player.playMp3(mp3FileName);\n  }\n\n  private String convertToMp3(String fileName) {\n    // Simulate conversion process (replace extension)\n    return fileName.replace(\".ogg\", \".mp3\");\n  }\n}\n\n// Main.java (Client code)\npublic class Main {\n  public static void main(String[] args) {\n    AudioPlayer audioPlayer = new OggToMp3Adapter();\n\n    // Play MP3 file\n    audioPlayer.play(\"audio1.mp3\");\n\n    // Play OGG file (automatically converted to MP3)\n    audioPlayer.play(\"audio2.ogg\");\n  }\n}\n\n/**\n * Mp3Player represents the existing audio player that can play MP3 files.\n *\n * AudioPlayer is the target interface that defines the unified interface expected by the\n * client application for playing audio files.\n *\n * OggToMp3Adapter is the adapter class that implements the AudioPlayer interface. It internally\n * uses the Mp3Player to play MP3 files but converts OGG files to MP3 format before delegating to\n * the Mp3Player.\n *\n * In the client code, the application interacts with the AudioPlayer interface, unaware of whether\n * it's playing MP3 or OGG files. When playing an OGG file, the adapter automatically converts it\n * to MP3 format before playing it using the Mp3Player.\n *\n */\n"}]},{"title":"Bridge","examples":[{"codeFile":"patterns/structural/bridge/example","code":"// Abstraction: Vehicle\n// Workshop.java (Implementor)\ninterface Workshop {\n  void work();\n}\n\n// PaintWorkshop.java (Concrete Implementor)\nclass PaintWorkshop implements Workshop {\n  @Override\n  public void work() {\n    System.out.println(\"Painting vehicle\");\n  }\n}\n\n// RepairWorkshop.java (Concrete Implementor)\nclass RepairWorkshop implements Workshop {\n  @Override\n  public void work() {\n    System.out.println(\"Repairing vehicle\");\n  }\n}\n\n// Vehicle.java (Abstraction)\nabstract class Vehicle {\n  protected Workshop workshop;\n\n  protected Vehicle(Workshop workshop) {\n    this.workshop = workshop;\n  }\n\n  abstract void manufacture();\n}\n\n// Car.java (Refined Abstraction)\nclass Car extends Vehicle {\n  public Car(Workshop workshop) {\n    super(workshop);\n  }\n\n  @Override\n  void manufacture() {\n    System.out.print(\"Manufacturing car. \");\n    workshop.work();\n  }\n}\n\n// Truck.java (Refined Abstraction)\nclass Truck extends Vehicle {\n  public Truck(Workshop workshop) {\n    super(workshop);\n  }\n\n  @Override\n  void manufacture() {\n    System.out.print(\"Manufacturing truck. \");\n    workshop.work();\n  }\n}\n\n// Main.java (Client code)\npublic class Main {\n  public static void main(String[] args) {\n    Vehicle car = new Car(new PaintWorkshop());\n    car.manufacture(); // Output: Manufacturing car. Painting vehicle\n\n    Vehicle truck = new Truck(new RepairWorkshop());\n    truck.manufacture(); // Output: Manufacturing truck. Repairing vehicle\n  }\n}\n\n/**\n * The Vehicle class represents the abstraction, which is extended by Car and Truck.\n *\n * The Workshop interface represents the implementor, defining the work method.\n *\n * PaintWorkshop and RepairWorkshop are concrete implementations of the Workshop interface.\n *\n * Each vehicle can be associated with a specific workshop using composition, and it delegates the work to that workshop.\n */\n"}]},{"title":"Composite","examples":[{"codeFile":"patterns/structural/composite/example","code":"import java.util.ArrayList;\nimport java.util.List;\n\n// Department.java (Component)\ninterface Department {\n  String getName();\n  List<String> getEmployees();\n}\n\n// IndividualDepartment.java (Leaf)\nclass IndividualDepartment implements Department {\n  private String name;\n  private List<String> employees;\n\n  public IndividualDepartment(String name, List<String> employees) {\n    this.name = name;\n    this.employees = employees;\n  }\n\n  @Override\n  public String getName() {\n    return name;\n  }\n\n  @Override\n  public List<String> getEmployees() {\n    return employees;\n  }\n}\n\n// CompositeDepartment.java (Composite)\nclass CompositeDepartment implements Department {\n  private String name;\n  private List<Department> departments;\n\n  public CompositeDepartment(String name) {\n    this.name = name;\n    this.departments = new ArrayList<>();\n  }\n\n  public void addDepartment(Department department) {\n    departments.add(department);\n  }\n\n  public void removeDepartment(Department department) {\n    departments.remove(department);\n  }\n\n  @Override\n  public String getName() {\n    return name;\n  }\n\n  @Override\n  public List<String> getEmployees() {\n    List<String> employees = new ArrayList<>();\n    for (Department department : departments) {\n      employees.addAll(department.getEmployees());\n    }\n    return employees;\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    IndividualDepartment salesDepartment = new IndividualDepartment(\"Sales Department\", List.of(\"John\", \"Alice\", \"Bob\"));\n    IndividualDepartment marketingDepartment = new IndividualDepartment(\"Marketing Department\", List.of(\"Emily\", \"David\"));\n    IndividualDepartment engineeringDepartment = new IndividualDepartment(\"Engineering Department\", List.of(\"Michael\", \"Sarah\", \"Chris\"));\n\n    CompositeDepartment headDepartment = new CompositeDepartment(\"Head Department\");\n    headDepartment.addDepartment(salesDepartment);\n    headDepartment.addDepartment(marketingDepartment);\n\n    CompositeDepartment parentEngineeringDepartment = new CompositeDepartment(\"Parent Engineering Department\");\n    parentEngineeringDepartment.addDepartment(engineeringDepartment);\n\n    CompositeDepartment rootDepartment = new CompositeDepartment(\"Root Department\");\n    rootDepartment.addDepartment(headDepartment);\n    rootDepartment.addDepartment(parentEngineeringDepartment);\n\n    // Get all employees in the root department\n    System.out.println(\"Employees in the root department:\");\n    List<String> employees = rootDepartment.getEmployees();\n    for (String employee : employees) {\n      System.out.println(employee);\n    }\n  }\n}\n\n\n/**\n * The Department interface defines the common methods for both individual departments and composite departments.\n *\n * IndividualDepartment represents an individual department with a name and a list of employees.\n *\n * CompositeDepartment represents a composite department that can contain sub-departments. It maintains a\n * list of departments and delegates the getEmployees method to its sub-departments recursively.\n *\n * The client code creates a hierarchical structure of departments and retrieves all employees from the root department.\n */\n"}]},{"title":"Decorator","examples":[{"codeFile":"patterns/structural/decorator/example","code":"// Notification.java (Component)\ninterface Notification {\n  String send();\n}\n\n// BaseNotification.java (Concrete Component)\nclass BaseNotification implements Notification {\n  @Override\n  public String send() {\n    return \"Base notification: You have a new message!\";\n  }\n}\n\n// NotificationDecorator.java (Decorator)\nabstract class NotificationDecorator implements Notification {\n  protected Notification notification;\n\n  protected NotificationDecorator(Notification notification) {\n    this.notification = notification;\n  }\n\n  @Override\n  public String send() {\n    return notification.send();\n  }\n}\n\n// SoundNotificationDecorator.java (Concrete Decorator)\nclass SoundNotificationDecorator extends NotificationDecorator {\n  public SoundNotificationDecorator(Notification notification) {\n    super(notification);\n  }\n\n  @Override\n  public String send() {\n    return super.send() + \" (Sound notification: Ding!)\";\n  }\n}\n\n// PriorityNotificationDecorator.java (Concrete Decorator)\nclass PriorityNotificationDecorator extends NotificationDecorator {\n  public PriorityNotificationDecorator(Notification notification) {\n    super(notification);\n  }\n\n  @Override\n  public String send() {\n    return super.send() + \" (Priority notification: High priority!)\";\n  }\n}\n\n// Main.java (Client code)\npublic class Main {\n  public static void main(String[] args) {\n    Notification baseNotification = new BaseNotification();\n    System.out.println(baseNotification.send());\n\n    Notification soundNotification = new SoundNotificationDecorator(baseNotification);\n    System.out.println(soundNotification.send());\n\n    Notification priorityNotification = new PriorityNotificationDecorator(baseNotification);\n    System.out.println(priorityNotification.send());\n\n    Notification soundAndPriorityNotification = new PriorityNotificationDecorator(new SoundNotificationDecorator(baseNotification));\n    System.out.println(soundAndPriorityNotification.send());\n  }\n}\n\n/**\n * The Notification interface defines the common method for sending notifications.\n *\n * BaseNotification represents the base notification without any additional features.\n *\n * NotificationDecorator is an abstract class that serves as the base class for concrete decorators.\n * It holds a reference to the wrapped notification.\n *\n * SoundNotificationDecorator adds sound notification functionality to the base notification.\n *\n * PriorityNotificationDecorator adds priority notification functionality to the base notification.\n *\n * The client code demonstrates how we can dynamically add sound notification, priority notification,\n * or both to the base notification. Each decorator enhances the behavior of the base notification\n * without modifying its implementation.\n */\n"}]},{"title":"Facade","examples":[{"codeFile":"patterns/structural/facade/example","code":"// Subsystem: Flight Booking\nclass FlightBookingSystem {\n  bookFlight(origin: string, destination: string): string {\n    return `Flight booked from ${origin} to ${destination}`;\n  }\n}\n\n// Subsystem: Hotel Booking\nclass HotelBookingSystem {\n  bookHotel(location: string, checkInDate: Date, checkOutDate: Date): string {\n    return `Hotel booked at ${location} from ${checkInDate.toDateString()} to ${checkOutDate.toDateString()}`;\n  }\n}\n\n// Subsystem: Car Rental\nclass CarRentalSystem {\n  rentCar(location: string, startDate: Date, endDate: Date): string {\n    return `Car rented at ${location} from ${startDate.toDateString()} to ${endDate.toDateString()}`;\n  }\n}\n\n// Facade: TravelFacade\nclass TravelFacade {\n  private flightBookingSystem: FlightBookingSystem;\n  private hotelBookingSystem: HotelBookingSystem;\n  private carRentalSystem: CarRentalSystem;\n\n  constructor() {\n    this.flightBookingSystem = new FlightBookingSystem();\n    this.hotelBookingSystem = new HotelBookingSystem();\n    this.carRentalSystem = new CarRentalSystem();\n  }\n\n  bookTravel(origin: string, destination: string, location: string, checkInDate: Date, checkOutDate: Date, startDate: Date, endDate: Date): string {\n    const flightDetails = this.flightBookingSystem.bookFlight(origin, destination);\n    const hotelDetails = this.hotelBookingSystem.bookHotel(location, checkInDate, checkOutDate);\n    const carDetails = this.carRentalSystem.rentCar(location, startDate, endDate);\n\n    return `${flightDetails}\\n${hotelDetails}\\n${carDetails}`;\n  }\n}\n\n// Client code\nconst travelFacade = new TravelFacade();\nconst bookingDetails = travelFacade.bookTravel('New York', 'Los Angeles', 'Hilton', new Date('2023-12-15'), new Date('2023-12-20'), new Date('2023-12-15'), new Date('2023-12-20'));\nconsole.log(bookingDetails);\n\n/**\n * The FlightBookingSystem, HotelBookingSystem, and CarRentalSystem classes represent the\n * subsystems of flight booking, hotel booking, and car rental, respectively.\n *\n * The TravelFacade class provides a simplified interface for booking a complete travel\n * package. It encapsulates the complexities of interacting with the subsystems.\n *\n * The client code interacts with the TravelFacade to book a complete travel package without\n * directly interacting with the subsystems.\n */\n"}]},{"title":"Flyweight","examples":[{"codeFile":"patterns/structural/flyweight/example","code":"// Flyweight: Character\nclass Character {\n  constructor(private character: string) { }\n\n  display(font: string, size: number): string {\n    return `Character: ${this.character}, Font: ${font}, Size: ${size}`;\n  }\n}\n\n// Flyweight Factory: CharacterFactory\nclass CharacterFactory {\n  private characters: { [key: string]: Character } = {};\n\n  getCharacter(character: string): Character {\n    if (!this.characters[character]) {\n      this.characters[character] = new Character(character);\n    }\n    return this.characters[character];\n  }\n}\n\n// Client code\nconst characterFactory = new CharacterFactory();\n\n// Text document\nconst text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\";\n\n// Rendering text with flyweight characters\nconst renderedText: string[] = [];\n\nfor (const char of text) {\n  const character = characterFactory.getCharacter(char);\n  renderedText.push(character.display('Arial', 12)); // Assume same font and size for simplicity\n}\n\n// Displaying rendered text\nconsole.log(renderedText.join('\\n'));\n\n\n/**\n * The Character class represents the flyweight object for a character. It contains intrinsic\n * state (the character itself).\n *\n * The CharacterFactory class acts as a flyweight factory, creating and managing flyweight\n * objects. It ensures that each character is shared among multiple instances.\n *\n * In the client code, we create a text document and render it using flyweight characters.\n * Instead of creating a new character object for each character in the text, we retrieve\n * existing flyweight characters from the factory, saving memory and improving performance.\n */\n"}]},{"title":"Proxy","examples":[{"codeFile":"patterns/structural/proxy/example","code":"// Subject: Interface representing the common behavior of RealSubject and Proxy\ninterface IHttpServer {\n  request(url: string): Promise<string>;\n}\n\n// RealSubject: The actual HTTP server implementation\nclass HttpServer implements IHttpServer {\n  async request(url: string): Promise<string> {\n    // Simulating HTTP request to the actual server\n    return `Response from server for URL: ${url}`;\n  }\n}\n\n// Proxy: Proxy server that intercepts requests before forwarding them to the real server\nclass ProxyServer implements IHttpServer {\n  private httpServer: HttpServer;\n\n  constructor() {\n    this.httpServer = new HttpServer();\n  }\n\n  async request(url: string): Promise<string> {\n    // Additional logic can be added here, e.g., caching, access control, logging\n    console.log(`Proxy: Intercepted request for URL: ${url}`);\n\n    // Forward the request to the real server\n    const response = await this.httpServer.request(url);\n\n    // Additional processing on the response can be done here\n\n    return response;\n  }\n}\n\n// Client code\nasync function testProxy() {\n  const proxy = new ProxyServer();\n\n  // Client sends a request to the proxy server\n  const response = await proxy.request(\"https://example.com\");\n\n  console.log(response);\n}\n\n// Test the proxy\ntestProxy();\n\n/**\n * The IHttpServer interface defines the common behavior for both the HttpServer and ProxyServer classes.\n *\n * The HttpServer class represents the real HTTP server implementation. It implements the request method\n * to send HTTP requests to the actual server.\n *\n * The ProxyServer class acts as a proxy server. It intercepts requests before forwarding them to the real\n * server. The request method of the proxy performs additional tasks such as logging, caching, or access\n * control before delegating the request to the real server.\n *\n * In the client code, we instantiate a ProxyServer object and send a request to it. The proxy intercepts\n * the request, performs any necessary processing, and then forwards the request to the real server.\n * Finally, it returns the response to the client.\n */\n"}]}],"patterns_proprietary":[{"title":"Null Object","description":[{"variant":"subtitle1","content":"The Null Object pattern is used to provide a non-functional object in place of null. This reduces the need for null check code throughout your application. It's particularly useful when an operation requires an object, but a meaningful object is not available or applicable.\n"}],"examples":[{"code":"interface Log {\n    void info(String msg);\n    void warn(String msg);\n}\n\nclass ConsoleLog implements Log {\n    public void info(String msg) {\n        System.out.println(\"Info: \" + msg);\n    }\n\n    public void warn(String msg) {\n        System.out.println(\"Warn: \" + msg);\n    }\n}\n\nclass NullLog implements Log {\n    public void info(String msg) { }\n    public void warn(String msg) { }\n}\n\nclass Application {\n    private Log log;\n\n    public Application(Log log) {\n        this.log = log == null ? new NullLog() : log;\n    }\n\n    public void doSomething() {\n        log.info(\"Doing something\");\n    }\n}\n"}]},{"title":"Dependency Injection","description":[{"variant":"subtitle1","content":"Dependency Injection (DI) is a design pattern used to implement IoC (Inversion of Control), allowing for the creation of dependent objects outside of a class and providing those objects to a class in different ways. DI can be implemented in various ways: constructor injection, method injection, or property injection.\n"}],"examples":[{"code":"interface MessageService {\n    void sendMessage(String message, String receiver);\n}\n\nclass EmailService implements MessageService {\n    public void sendMessage(String message, String receiver) {\n        // logic to send email\n        System.out.println(\"Email sent to \" + receiver + \" with message=\" + message);\n    }\n}\n\nclass Consumer {\n    private MessageService messageService;\n\n    // constructor injection\n    public Consumer(MessageService service) {\n        this.messageService = service;\n    }\n\n    public void processMessages(String msg, String rec) {\n        // do some msg validation, manipulation logic etc\n        this.messageService.sendMessage(msg, rec);\n    }\n}\n\nclass MyApplication {\n    public static void main(String[] args) {\n        MessageService service = new EmailService();\n        Consumer app = new Consumer(service);\n        app.processMessages(\"Hi Pankaj\", \"pankaj@abc.com\");\n    }\n}\n"}]}]},"principles":{"principles_solid":[{"title":"Single Responsibility","examples":[{"title":"Good Example","codeFile":"principles/solid/single-responsibility/good-example","code":"public class Employee {\n  private String name;\n  private String position;\n  private double salary;\n\n  public Employee(String name, String position, double salary) {\n    this.name = name;\n    this.position = position;\n    this.salary = salary;\n  }\n\n  public String getName() {\n    return name;\n  }\n\n  public String getPosition() {\n    return position;\n  }\n\n  public double getSalary() {\n    return salary;\n  }\n}\n\npublic class EmployeePrinter {\n  public void print(Employee employee) {\n    System.out.println(\"Name: \" + employee.getName());\n    System.out.println(\"Position: \" + employee.getPosition());\n    System.out.println(\"Salary: \" + employee.getSalary());\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    Employee employee = new Employee(\"John Doe\", \"Software Engineer\", 50000);\n    EmployeePrinter printer = new EmployeePrinter();\n    printer.print(employee);\n  }\n}\n"},{"title":"Bad Example","codeFile":"principles/solid/single-responsibility/bad-example","code":"public class Employee {\n  private String name;\n  private String position;\n  private double salary;\n\n  public Employee(String name, String position, double salary) {\n    this.name = name;\n    this.position = position;\n    this.salary = salary;\n  }\n\n  // This method violates the Single Responsibility Principle\n  public void print() {\n    System.out.println(\"Name: \" + this.name);\n    System.out.println(\"Position: \" + this.position);\n    System.out.println(\"Salary: \" + this.salary);\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    Employee employee = new Employee(\"John Doe\", \"Software Engineer\", 50000);\n    employee.print(); // Mixing data management with presentation logic\n  }\n}\n"}]},{"title":"Open-Closed","examples":[{"title":"Good Example","codeFile":"principles/solid/open-closed/good-example","code":"abstract class Shape {\n  abstract double computeArea();\n}\n\nclass Rectangle extends Shape {\n  private double width;\n  private double height;\n\n  public Rectangle(double width, double height) {\n    this.width = width;\n    this.height = height;\n  }\n\n  @Override\n  double computeArea() {\n    return this.width * this.height;\n  }\n}\n\nclass Circle extends Shape {\n  private double radius;\n\n  public Circle(double radius) {\n    this.radius = radius;\n  }\n\n  @Override\n  double computeArea() {\n    return Math.PI * Math.pow(this.radius, 2);\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    Shape rectangle = new Rectangle(5, 10);\n    Shape circle = new Circle(7);\n\n    System.out.println(\"Area of the rectangle: \" + rectangle.computeArea());\n    System.out.println(\"Area of the circle: \" + circle.computeArea());\n  }\n}\n\n"},{"title":"Bad Example","codeFile":"principles/solid/open-closed/bad-example","code":"class Rectangle {\n  double width;\n  double height;\n\n  public Rectangle(double width, double height) {\n    this.width = width;\n    this.height = height;\n  }\n}\n\nclass Circle {\n  double radius;\n\n  public Circle(double radius) {\n    this.radius = radius;\n  }\n}\n\nclass AreaCalculator {\n  public double computeArea(Object shape) {\n    if (shape instanceof Rectangle) {\n      Rectangle rectangle = (Rectangle) shape;\n      return rectangle.width * rectangle.height;\n    } else if (shape instanceof Circle) {\n      Circle circle = (Circle) shape;\n      return Math.PI * circle.radius * circle.radius;\n    }\n\n    throw new IllegalArgumentException(\"Unknown shape\");\n  }\n}\n"}]},{"title":"Liskov Substitution","examples":[{"title":"Good Example","codeFile":"principles/solid/liskov-substitution/good-example","code":"class Bird {\n  public void fly() {\n    System.out.println(\"Bird is flying\");\n  }\n}\n\nclass Duck extends Bird {\n  public void quack() {\n    System.out.println(\"Duck is quacking\");\n  }\n}\n\n// Renaming Goose to Penguin for clarity, given the behavior\nclass Penguin extends Bird {\n  // Removing the fly method override to adhere to LSP\n  public void swim() {\n    System.out.println(\"Penguin is swimming\");\n  }\n}\n\npublic class Main {\n  public static void makeBirdFly(Bird bird) {\n    bird.fly();\n  }\n\n  public static void main(String[] args) {\n    Duck duck = new Duck();\n    Penguin penguin = new Penguin();\n\n    makeBirdFly(duck); // Output: Bird is flying\n    // This next line is a problem for LSP, so we shouldn't attempt to make a penguin fly.\n    // makeBirdFly(penguin); // This would incorrectly imply penguins can fly, which violates LSP.\n  }\n}\n"},{"title":"Bad Example","codeFile":"principles/solid/liskov-substitution/bad-example","code":"class Bird {\n  public void fly() {\n    // Implementation that allows flying\n    System.out.println(\"Bird is flying\");\n  }\n}\n\nclass Ostrich extends Bird {\n  @Override\n  public void fly() {\n    // Ostrich should not fly according to real-world behavior, so this implementation is problematic\n    throw new UnsupportedOperationException(\"Can't fly\");\n  }\n}\n\npublic class Main {\n  public static void makeItFly(Bird flyer) {\n    flyer.fly();\n  }\n\n  public static void main(String[] args) {\n    Sparrow sparrow = new Sparrow();\n    Ostrich ostrich = new Ostrich();\n\n    makeItFly(sparrow); // Works fine\n    makeItFly(ostrich); // This line will throw an error\n  }\n}\n"},{"title":"Good Example (Refined)","codeFile":"principles/solid/liskov-substitution/good-example-refined","code":"interface Flyable {\n    void fly();\n}\n\nclass Bird {\n}\n\nclass Duck extends Bird implements Flyable {\n    public void fly() {\n        System.out.println(\"Duck is flying\");\n    }\n\n    public void quack() {\n        System.out.println(\"Duck is quacking\");\n    }\n}\n\nclass Penguin extends Bird {\n    public void swim() {\n        System.out.println(\"Penguin is swimming\");\n    }\n}\n\npublic class Main {\n    public static void makeItFly(Flyable flyer) {\n        flyer.fly();\n    }\n\n    public static void main(String[] args) {\n        Duck duck = new Duck();\n        Penguin penguin = new Penguin();\n\n        makeItFly(duck); // Correctly applies only to birds that can fly\n        // Penguins don't implement Flyable, so we don't try to make them fly.\n    }\n}\n"},{"title":"Bad Example (Refined)","codeFile":"principles/solid/liskov-substitution/bad-example-refined","code":"interface Flyable {\n    void fly();\n}\n\nclass Bird {\n    // Base class without fly method\n}\n\nclass Sparrow extends Bird implements Flyable {\n    @Override\n    public void fly() {\n        System.out.println(\"Sparrow is flying\");\n    }\n}\n\nclass Ostrich extends Bird {\n    // Ostrich does not implement Flyable, avoiding the LSP violation\n}\n\npublic class Main {\n    public static void makeItFly(Flyable flyer) {\n        flyer.fly();\n    }\n\n    public static void main(String[] args) {\n        Sparrow sparrow = new Sparrow();\n        Ostrich ostrich = new Ostrich();\n\n        makeItFly(sparrow); // Works fine\n        // makeItFly(ostrich); // This line is now a compile-time error, which is preferable.\n    }\n}\n"}]},{"title":"Interface Segregation","examples":[{"title":"Good Example","codeFile":"principles/solid/interface-segregation/good-example","code":"interface Printer {\n  void printDocument();\n}\n\ninterface Fax {\n  void faxDocument();\n}\n\ninterface Scanner {\n  void scanDocument();\n}\n\nclass SimplePrinter implements Printer {\n  @Override\n  public void printDocument() {\n    System.out.println(\"Printing document...\");\n  }\n}\n\nclass MultifunctionalPrinter implements Printer, Fax, Scanner {\n  @Override\n  public void printDocument() {\n    System.out.println(\"Printing document...\");\n  }\n\n  @Override\n  public void faxDocument() {\n    System.out.println(\"Faxing document...\");\n  }\n\n  @Override\n  public void scanDocument() {\n    System.out.println(\"Scanning document...\");\n  }\n}\n"},{"title":"Bad Example","codeFile":"principles/solid/interface-segregation/bad-example","code":"interface Machine {\n  void printDocument();\n  void faxDocument();\n  void scanDocument();\n}\n\nclass OldPrinter implements Machine {\n  @Override\n  public void printDocument() {\n    System.out.println(\"Printing document...\");\n  }\n\n  @Override\n  public void faxDocument() {\n    throw new UnsupportedOperationException(\"This printer cannot fax documents.\");\n  }\n\n  @Override\n  public void scanDocument() {\n    throw new UnsupportedOperationException(\"This printer cannot scan documents.\");\n  }\n}\n"}]},{"title":"Dependency Inversion","examples":[{"title":"Good Example","codeFile":"principles/solid/interface-segregation/good-example","code":"interface Printer {\n  void printDocument();\n}\n\ninterface Fax {\n  void faxDocument();\n}\n\ninterface Scanner {\n  void scanDocument();\n}\n\nclass SimplePrinter implements Printer {\n  @Override\n  public void printDocument() {\n    System.out.println(\"Printing document...\");\n  }\n}\n\nclass MultifunctionalPrinter implements Printer, Fax, Scanner {\n  @Override\n  public void printDocument() {\n    System.out.println(\"Printing document...\");\n  }\n\n  @Override\n  public void faxDocument() {\n    System.out.println(\"Faxing document...\");\n  }\n\n  @Override\n  public void scanDocument() {\n    System.out.println(\"Scanning document...\");\n  }\n}\n"},{"title":"Bad Example","codeFile":"principles/solid/interface-segregation/bad-example","code":"interface Machine {\n  void printDocument();\n  void faxDocument();\n  void scanDocument();\n}\n\nclass OldPrinter implements Machine {\n  @Override\n  public void printDocument() {\n    System.out.println(\"Printing document...\");\n  }\n\n  @Override\n  public void faxDocument() {\n    throw new UnsupportedOperationException(\"This printer cannot fax documents.\");\n  }\n\n  @Override\n  public void scanDocument() {\n    throw new UnsupportedOperationException(\"This printer cannot scan documents.\");\n  }\n}\n"}]}],"principles_other":[{"title":"Don't Repeat Yourself (DRY)","examples":[{"title":"Good Example","codeFile":"principles/other/dry/good-example","code":"public class TaxCalculator {\n    public static double addTax(double price) {\n        return addTax(price, 0.05); // Default tax rate\n    }\n\n    public static double addTax(double price, double rate) {\n        return price + (price * rate);\n    }\n}\n"},{"title":"Bad Example","codeFile":"principles/other/dry/bad-example","code":"public class TaxCalculator {\n    public static double addTaxForFood(double price) {\n        return price + (price * 0.05);\n    }\n\n    public static double addTaxForElectronics(double price) {\n        return price + (price * 0.05);\n    }\n}\n"}]},{"title":"Keep It Simple Stupid (KISS)","examples":[{"title":"Good Example","codeFile":"principles/other/kiss/good-example","code":"public class NumberUtils {\n    public static boolean isEven(int num) {\n        return num % 2 == 0;\n    }\n}\n"},{"title":"Bad Example","codeFile":"principles/other/kiss/bad-example","code":"public class NumberUtils {\n    // there is no need for absolute value here\n    public static boolean isEven(int num) {\n        return num % Math.abs(2) == 0;\n    }\n}\n\n\n"}]},{"title":"You Aren't Gonna Need It (YAGNI)","examples":[{"title":"Good Example","codeFile":"principles/other/yagni/good-example","code":"class Calculator {\n  float add(float a, float b) {\n    return a + b;\n  }\n}\n"},{"title":"Bad Example","codeFile":"principles/other/yagni/bad-example","code":"class Calculator {\n  float add(float a, float b) {\n    return a + b;\n  }\n\n  // Do not define methods unless they are used\n\n  float multiply(float a, float b) {\n    return a * b;\n  }\n\n  float divide(float a, float b) {\n    if (b === 0) {\n      throw new Error(\"Division by zero is not allowed.\");\n    }\n    return a / b;\n  }\n\n  float subtract(float a, float b) {\n    return a - b;\n  }\n}\n"}]},{"title":"Law of Demeter (Principle of Least Knowledge)","examples":[{"title":"Good Example","codeFile":"principles/other/yagni/good-example","code":"class Calculator {\n  float add(float a, float b) {\n    return a + b;\n  }\n}\n"},{"title":"Bad Example","codeFile":"principles/other/yagni/bad-example","code":"class Calculator {\n  float add(float a, float b) {\n    return a + b;\n  }\n\n  // Do not define methods unless they are used\n\n  float multiply(float a, float b) {\n    return a * b;\n  }\n\n  float divide(float a, float b) {\n    if (b === 0) {\n      throw new Error(\"Division by zero is not allowed.\");\n    }\n    return a / b;\n  }\n\n  float subtract(float a, float b) {\n    return a - b;\n  }\n}\n"}]},{"title":"Separation of Concerns","examples":[{"title":"Good Example","codeFile":"principles/other/separation/good-example","code":"// Authentication Service\npublic class AuthenticationService {\n  public boolean login(String username, String password) {\n    // Authentication logic here\n    return true; // Dummy implementation\n  }\n\n  public void logout() {\n    // Logout logic here\n  }\n}\n\n// Data Service\npublic class DataService {\n  public Object[] fetchData() {\n    // Data retrieval logic here\n    return new Object[]{}; // Dummy implementation\n  }\n}\n\n/**\n * - `AuthenticationService` and `DataService` are responsible for handling authentication and data retrieval, respectively.\n * - `UserController` and `DataController` serve as intermediaries between the HTTP layer (not shown) and the services.\n * - Each component has a single responsibility, promoting modularity, testability, and maintainability.\n *\n */\n\n// User controller\npublic class UserController {\n  private AuthenticationService authService;\n\n  public UserController(AuthenticationService authService) {\n    this.authService = authService;\n  }\n\n  public boolean loginUser(String username, String password) {\n    return this.authService.login(username, password);\n  }\n\n  public void logoutUser() {\n    this.authService.logout();\n  }\n}\n\n// Data Controller\npublic class DataController {\n  private DataService dataService;\n\n  public DataController(DataService dataService) {\n    this.dataService = dataService;\n  }\n\n  public Object[] getData() {\n    return this.dataService.fetchData();\n  }\n}\n\n// Usage\npublic class Main {\n  public static void main(String[] args) {\n    AuthenticationService authService = new AuthenticationService();\n    DataService dataService = new DataService();\n\n    UserController userController = new UserController(authService);\n    DataController dataController = new DataController(dataService);\n\n    // Simulate user login/logout\n    userController.loginUser(\"username\", \"password\");\n    userController.logoutUser();\n\n    // Retrieve data\n    Object[] data = dataController.getData();\n    System.out.println(data.length); // Example output, could be expanded to display actual data\n  }\n}\n"},{"title":"Bad Example","codeFile":"principles/other/separation/bad-example","code":"// Authentication Service\npublic class AuthenticationService {\n  public boolean login(String username, String password) {\n    // Authentication logic here\n    return true; // Dummy implementation\n  }\n\n  public void logout() {\n    // Logout logic here\n  }\n}\n\n// Data Service\npublic class DataService {\n  public Object[] fetchData() {\n    // Data retrieval logic here\n    return new Object[]{}; // Dummy implementation\n  }\n}\n\n/**\n * - The `CombinedController` class is responsible for both user authentication and data retrieval.\n * - The loginUser method not only handles authentication but also retrieves user data directly\n *   from the `DataService`, violating the Single Responsibility Principle and mixing concerns.\n * - This violates the principle of Separation of Concerns and makes the code harder to maintain, test, and understand.\n */\n\npublic class CombinedController {\n  private AuthenticationService authService;\n  private DataService dataService;\n\n  public CombinedController(AuthenticationService authService, DataService dataService) {\n    this.authService = authService;\n    this.dataService = dataService;\n  }\n\n  public boolean loginUser(String username, String password) {\n    // Authentication logic here\n    boolean isAuthenticated = this.authService.login(username, password);\n    if (isAuthenticated) {\n      // Retrieve user data (mixing concerns)\n      Object[] userData = this.dataService.fetchData();\n      System.out.println(userData);\n    }\n    return isAuthenticated;\n  }\n\n  public void logoutUser() {\n    // Logout logic here\n    this.authService.logout();\n  }\n}\n\npublic class Main {\n  public static void main(String[] args) {\n    AuthenticationService authService = new AuthenticationService();\n    DataService dataService = new DataService();\n\n    CombinedController combinedController = new CombinedController(authService, dataService);\n\n    // Simulate user login/logout\n    combinedController.loginUser(\"username\", \"password\");\n    combinedController.logoutUser();\n  }\n}\n\n// Usage\nconst authService = new AuthenticationService();\nconst dataService = new DataService();\n\nconst combinedController = new CombinedController(authService, dataService);\n\n// Simulate user login/logout\ncombinedController.loginUser(\"username\", \"password\");\ncombinedController.logoutUser();\n"}]}],"principles_proprietary":[{"title":"Effective Java by Joshua Bloch","description":[{"variant":"subtitle1","content":"While not a single principle, \"Effective Java\" is a seminal book by Joshua Bloch that outlines numerous best practices for writing robust, performant, and readable Java code. Some key takeaways include:\n<ul>\n  <li>Consider static factory methods instead of constructors. This can lead to more readable code and more flexible object creation strategies.</li>\n  <li>Favor composition over inheritance. This encourages better encapsulation and avoids issues related to inheritance breaking encapsulation.</li>\n  <li>Use Enums instead of int constants. Enums provide a more robust, type-safe way of representing fixed sets of constants.</li>\n</ul>\n"}],"examples":[{"title":"Static Factory Methods Instead of Constructors","code":"// A static factory method valueOf is provided to create instances of BooleanValue.\n// This approach offers several advantages over public constructors, such as the\n// ability to return cached instances, return instances of a subclass, and the\n// clarity of method names over overloaded constructors.\npublic class BooleanValue {\n    private final boolean value;\n\n    private BooleanValue(boolean value) {\n        this.value = value;\n    }\n\n    public static BooleanValue valueOf(boolean value) {\n        return new BooleanValue(value);\n    }\n}\n"},{"title":"Favor Composition Over Inheritance","code":"// The Animal class uses composition to delegate the makeNoise behavior to a NoiseMaker\n// object, rather than inheriting from different animal classes. This approach is more\n// flexible and avoids the tight coupling and fragility associated with inheritance.\npublic class Animal {\n    private final NoiseMaker noiseMaker;\n\n    public Animal(NoiseMaker noiseMaker) {\n        this.noiseMaker = noiseMaker;\n    }\n\n    public void makeNoise() {\n        noiseMaker.makeNoise();\n    }\n}\n\ninterface NoiseMaker {\n    void makeNoise();\n}\n\nclass Bark implements NoiseMaker {\n    public void makeNoise() {\n        System.out.println(\"Bark\");\n    }\n}\n\nclass Meow implements NoiseMaker {\n    public void makeNoise() {\n        System.out.println(\"Meow\");\n    }\n}\n"},{"title":"Use Enums Instead of int Constants","code":"public enum Day {\n    MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY;\n}\n"}]},{"title":"Java Concurrency Practices","description":[{"variant":"subtitle1","content":"Given Java's strong emphasis on concurrent and multi-threaded programming, following best practices in this area is crucial:\n<ul>\n  <li>Prefer immutability for shared objects in a concurrent context. Immutable objects are thread-safe by design.</li>\n  <li>Use existing concurrency utilities over 'low-level' thread management. Java's java.util.concurrent package provides high-level concurrency utilities that are safer and more expressive than manual synchronization and thread management.</li>\n</ul>\n"}],"examples":[{"code":"function Person(firstName) {\n  this.firstName = firstName;\n}\nPerson.prototype.sayHello = function() {\n  return \"Hello, I'm \" + this.firstName;\n};\nconst john = new Person(\"John\");\nconsole.log(john.sayHello()); // \"Hello, I'm John\"\n"}]},{"title":"Java Memory Management","description":[{"variant":"subtitle1","content":"Understanding and applying best practices related to Java's garbage collection and memory management can significantly impact application performance:\n<ul>\n  <li>Minimize unnecessary object creation. While Java's garbage collection simplifies memory management, unnecessary object creation can lead to memory bloat and increased GC overhead.</li>\n  <li>Be mindful of memory leaks. Even in a garbage-collected language like Java, it's possible to create memory leaks through unintended object references.</li>\n</ul>\n"}],"examples":[{"code":"// Avoid creating unnecessary objects (like wrapping a string with a new String object)\n// when you can use the existing object's methods directly.\npublic class StringUtilities {\n    public static String toUpperCase(String input) {\n        // Bad: Creates a new String object unnecessarily\n        // return new String(input).toUpperCase();\n\n        // Good: Avoids unnecessary object creation\n        return input.toUpperCase();\n    }\n}\n"}]},{"title":"Java Collections Framework (JCF) Best Practices","description":[{"variant":"subtitle1","content":"The JCF is a cornerstone of Java programming, and using it effectively is key to efficient Java code:\n<ul>\n  <li>Choose the right collection type for the job. Different types of collections (Lists, Sets, Maps, etc.) are optimized for different types of operations; choosing the right one can lead to more efficient code.</li>\n  <li>Prefer interfaces to concrete implementations in APIs. This makes your code more flexible and able to work with different concrete implementations.</li>\n</ul>\n"}],"examples":[]},{"title":"Java 8 and Beyond Features","description":[{"variant":"subtitle1","content":"Java 8 introduced several significant features that encourage a more functional programming style. Best practices around these features can lead to more concise and expressive code:\n<ul>\n  <li>Leverage lambda expressions and streams for clear, concise code. These features can greatly reduce boilerplate, especially when processing collections.</li>\n  <li>Use Optional to represent optional values. This can help avoid null checks and NullPointerExceptions.</li>\n</ul>\n"}],"examples":[{"title":"Use Lambda Expressions and Streams","code":"// This example uses a stream to transform a list of names to uppercase and then print them.\n// It showcases the concise and expressive capabilities of lambda expressions and streams\n// in Java 8 and beyond.\nList<String> names = Arrays.asList(\"John\", \"Jane\", \"Doe\", \"Sarah\");\nList<String> uppercaseNames = names.stream()\n                                    .map(String::toUpperCase)\n                                    .collect(Collectors.toList());\n\nuppercaseNames.forEach(System.out::println);\n"},{"title":"Use Optional to Represent Optional Values","code":"// The Optional class is used to represent a name value that may or may not be present.\n// This approach avoids null checks and makes the code more expressive and safer by explicitly\n// handling the case where the value might be absent.\npublic class User {\n    private final String name;\n\n    public User(String name) {\n        this.name = name;\n    }\n\n    public Optional<String> getName() {\n        return Optional.ofNullable(name);\n    }\n}\n\n// Usage\nUser user = new User(null);\nuser.getName().ifPresent(System.out::println); // Does nothing if name is null\n"}]}]}}