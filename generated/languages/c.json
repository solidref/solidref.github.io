{"name":"C","code":"c","ext":"c","birth":1972,"death":"N/A","inspiredBy":["b","algol","assembly","fortran","pascal"],"inspiring":["c++","java","javascript","c#","python","ruby","perl","php","objective-c"],"description":"C is a general-purpose, procedural computer programming language supporting structured programming,\nlexical variable scope, and recursion, while a static type system prevents unintended operations.\nDeveloped by Dennis Ritchie at Bell Labs, C was originally designed for writing system software\nlike operating systems, compilers, and editors. It has since become one of the most widely used\nprogramming languages. C is an efficient and powerful language, known for its performance and\ncontrol over system resources. Despite its age, C remains popular for both system-level and\napplication programming, forming the basis for more modern languages like C++, C#, and Objective-C.\nIt's also commonly used in embedded systems, operating systems like Linux and Windows, and complex\napplications requiring high performance. The languageâ€™s influence is evident in numerous other\nprogramming languages and it remains a fundamental part of software development history.\n","patterns":{"patterns_behavioural":[{"title":"Chain Of Responsibility","examples":[{"codeFile":"patterns/behavioural/chain-of-responsibility/example","code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/* Define the structure for a support handler */\nstruct SupportHandler;\ntypedef struct SupportHandler SupportHandler;\n\nstruct SupportHandler {\n    SupportHandler* nextHandler;\n    char* (*handleRequest)(SupportHandler* self, const char* request);\n};\n\n/* Forward declaration of functions to set the next handler and handle requests */\nvoid setNextHandler(SupportHandler* handler, SupportHandler* next);\nchar* handleRequest(SupportHandler* handler, const char* request);\n\n/* Level 1 Support */\nchar* Level1Support_handleRequest(SupportHandler* self, const char* request) {\n    if (strstr(request, \"basic\")) {\n        return \"Level 1 Support: Issue resolved at basic level.\";\n    } else if (self->nextHandler) {\n        return self->nextHandler->handleRequest(self->nextHandler, request);\n    } else {\n        return NULL;\n    }\n}\n\nSupportHandler* Level1Support_new() {\n    SupportHandler* handler = (SupportHandler*)malloc(sizeof(SupportHandler));\n    if (!handler) return NULL;\n    handler->nextHandler = NULL;\n    handler->handleRequest = Level1Support_handleRequest;\n    return handler;\n}\n\n/* Level 2 Support */\nchar* Level2Support_handleRequest(SupportHandler* self, const char* request) {\n    if (strstr(request, \"advanced\")) {\n        return \"Level 2 Support: Issue resolved at advanced level.\";\n    } else if (self->nextHandler) {\n        return self->nextHandler->handleRequest(self->nextHandler, request);\n    } else {\n        return NULL;\n    }\n}\n\nSupportHandler* Level2Support_new() {\n    SupportHandler* handler = (SupportHandler*)malloc(sizeof(SupportHandler));\n    if (!handler) return NULL;\n    handler->nextHandler = NULL;\n    handler->handleRequest = Level2Support_handleRequest;\n    return handler;\n}\n\n/* Level 3 Support */\nchar* Level3Support_handleRequest(SupportHandler* self, const char* request) {\n    if (strstr(request, \"bug\")) {\n        return \"Level 3 Support: Issue resolved at development level.\";\n    } else {\n        return \"Level 3 Support: Unable to resolve the issue.\";\n    }\n}\n\nSupportHandler* Level3Support_new() {\n    SupportHandler* handler = (SupportHandler*)malloc(sizeof(SupportHandler));\n    if (!handler) return NULL;\n    handler->nextHandler = NULL;\n    handler->handleRequest = Level3Support_handleRequest;\n    return handler;\n}\n\nvoid setNextHandler(SupportHandler* handler, SupportHandler* next) {\n    if (handler) {\n        handler->nextHandler = next;\n    }\n}\n\n/* Client code simulates support requests */\nint main() {\n    SupportHandler* level1 = Level1Support_new();\n    SupportHandler* level2 = Level2Support_new();\n    SupportHandler* level3 = Level3Support_new();\n\n    setNextHandler(level1, level2);\n    setNextHandler(level2, level3);\n\n    const char* request1 = \"Fix basic login issue\";\n    const char* request2 = \"Debug advanced performance problem\";\n    const char* request3 = \"Investigate bug causing application crash\";\n\n    printf(\"%s\\n\", level1->handleRequest(level1, request1));\n    printf(\"%s\\n\", level1->handleRequest(level1, request2));\n    printf(\"%s\\n\", level1->handleRequest(level1, request3));\n\n    /* Cleanup */\n    free(level1);\n    free(level2);\n    free(level3);\n\n    return 0;\n}\n\n/**\n * This code demonstrates how the Chain of Responsibility pattern can be used in a support\n * ticket system. In C, structs and function pointers are utilized to mimic object\n * oriented behaviors like inheritance and polymorphism. Each \"SupportHandler\" struct\n * represents different levels of support. Each handler decides whether it can handle a\n * request or should pass it to the next handler in the chain. Unlike the original example,\n * dynamic memory allocation is used for creating handlers, emphasizing C's manual memory\n * management.\n */"}]},{"title":"Command","examples":[{"codeFile":"patterns/behavioural/command/example","code":"#include <stdio.h>\n#include <stdlib.h>\n\n// Forward declaration for mutual referencing\nstruct Command;\n\n// Define the command interface in C by structuring function pointers\ntypedef struct Command {\n  void (*execute)(struct Command*);\n  void *state; // Generic state to enable closure-like behavior\n} Command;\n\n// Receiver class that performs the actual actions\ntypedef struct Light {\n  void (*turnOn)(struct Light*);\n  void (*turnOff)(struct Light*);\n} Light;\n\n// Function implementations for the Light\nvoid lightTurnOn(Light *light) {\n  printf(\"Light is on\\n\");\n}\n\nvoid lightTurnOff(Light* light) {\n  printf(\"Light is off\\n\");\n}\n\n// Initializes a Light object\nLight* newLight() {\n  Light* light = (Light*)malloc(sizeof(Light));\n  light->turnOn = lightTurnOn;\n  light->turnOff = lightTurnOff;\n  return light;\n}\n\n// Concrete command to turn on the light\ntypedef struct {\n  Command base;\n  Light* light;\n} TurnOnCommand;\n\n// Concrete command to turn off the light\ntypedef struct {\n  Command base;\n  Light* light;\n} TurnOffCommand;\n\n// Execute methods for commands\nvoid turnOnExecute(Command* command) {\n  TurnOnCommand* cmd = (TurnOnCommand*)command;\n  cmd->light->turnOn(cmd->light);\n}\n\nvoid turnOffExecute(Command* command) {\n  TurnOffCommand* cmd = (TurnOffCommand*)command;\n  cmd->light->turnOff(cmd->light);\n}\n\n// Factory functions to create command instances\nCommand* newTurnOnCommand(Light* light) {\n  TurnOnCommand* cmd = (TurnOnCommand*)malloc(sizeof(TurnOnCommand));\n  cmd->base.execute = turnOnExecute;\n  cmd->light = light;\n  return (Command*)cmd;\n}\n\nCommand* newTurnOffCommand(Light* light) {\n  TurnOffCommand* cmd = (TurnOffCommand*)malloc(sizeof(TurnOffCommand));\n  cmd->base.execute = turnOffExecute;\n  cmd->light = light;\n  return (Command*)cmd;\n}\n\n// Invoker class that triggers the commands\ntypedef struct {\n  Command** commands;\n  int size;\n} RemoteControl;\n\n// Adds a command to the remote control\nvoid addCommand(RemoteControl* rc, Command* command) {\n  rc->commands[rc->size++] = command;\n}\n\n// Executes all added commands\nvoid executeCommands(RemoteControl* rc) {\n  for (int i = 0; i < rc->size; i++) {\n    rc->commands[i]->execute(rc->commands[i]);\n  }\n}\n\n// Initializes a RemoteControl object\nRemoteControl* newRemoteControl(int capacity) {\n  RemoteControl* rc = (RemoteControl*)malloc(sizeof(RemoteControl));\n  rc->commands = (Command**)malloc(sizeof(Command*) * capacity);\n  rc->size = 0;\n  return rc;\n}\n\n// Client code\nint main() {\n  Light* light = newLight();\n\n  Command* turnOnCommand = newTurnOnCommand(light);\n  Command* turnOffCommand = newTurnOffCommand(light);\n\n  RemoteControl* remoteControl = newRemoteControl(2);\n  addCommand(remoteControl, turnOnCommand);\n  addCommand(remoteControl, turnOffCommand);\n\n  // Press the buttons on the remote control to execute the commands\n  executeCommands(remoteControl);\n\n  // Clean up\n  free(light);\n  free(turnOnCommand);\n  free(turnOffCommand);\n  free(remoteControl->commands);\n  free(remoteControl);\n\n  return 0;\n}"}]},{"title":"Iterator","examples":[{"codeFile":"patterns/behavioural/iterator/example","code":"#include <stdio.h>\n#include <stdbool.h>\n\n// Forward declaration\ntypedef struct Iterator Iterator;\n\n// Iterator interface\nstruct Iterator {\n    void *collection;\n    int index;\n    int size;\n    void* (*next)(Iterator *self);\n    bool (*hasNext)(Iterator *self);\n};\n\n// Functions to implement Iterator's behavior\nvoid* next(Iterator *self) {\n    // Prevent accessing beyond the collection\n    if (self->index < self->size) {\n        // Assuming collection is an array of void pointers\n        void **items = (void**)self->collection;\n        return items[self->index++];\n    } else {\n        return NULL;\n    }\n}\n\nbool hasNext(Iterator *self) {\n    return self->index < self->size;\n}\n\n// Constructor for Iterator\nvoid initIterator(Iterator *iterator, void **collection, int size) {\n    iterator->collection = collection;\n    iterator->index = 0;\n    iterator->size = size;\n    iterator->next = next;\n    iterator->hasNext = hasNext;\n}\n\n// Example specific code\n// Here we use void pointers to simulate handling different types, which is not very \"C\", but illustrates versatility\nint main() {\n    // Client code\n    int i1 = 1, i3 = 3, i5 = 5;\n    char *s2 = \"two\", *s4 = \"four\";\n    void *items[] = {&i1, s2, &i3, s4, &i5};\n    int size = 5;\n\n    Iterator iterator;\n    initIterator(&iterator, items, size);\n\n    while (iterator.hasNext(&iterator)) {\n        // Type casting is required here due to the use of void pointers\n        void *item = iterator.next(&iterator);\n        if (item) {\n            // Determine the type of the item and print it accordingly, this is a crude attempt and not type-safe\n            if (item == s2 || item == s4) {\n                printf(\"%s\\n\", (char *)item);\n            } else {\n                printf(\"%d\\n\", *(int *)item);\n            }\n        }\n    }\n\n    /*\n     * In this C example, the Iterator pattern is adapted to iterate over a collection of mixed types (integers and strings in this case),\n     * illustrating how an iterator can be implemented in a language without generics. The Iterator structure provides methods to check if\n     * there are more elements (hasNext) and to retrieve the next element (next). By using void pointers and explicit initialization,\n     * the example demonstrates a way to work around the absence of class constructors and templates in C. It is a simplification to highlight\n     * the pattern's essence rather than a fully robust implementation suitable for all use cases.\n     */\n    return 0;\n}"}]},{"title":"Mediator","examples":[{"codeFile":"patterns/behavioural/mediator/example","code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Forward declaration\nstruct User;\n\n// Mediator Interface in C\ntypedef struct ChatMediator {\n  void (*sendMessage)(struct ChatMediator* self, const char* message, struct User* user);\n} ChatMediator;\n\n// User Interface in C\ntypedef struct User {\n  char* (*getName)(struct User* self);\n  void (*send)(struct User* self, const char* message);\n  void (*receive)(struct User* self, const char* message);\n  char name[50];\n  ChatMediator* mediator;\n} User;\n\n// Implement sendMessage for ChatMediator\nvoid chatRoomSendMessage(ChatMediator* self, const char* message, User* user) {\n  printf(\"[%s] sends message: %s\\n\", user->getName(user), message);\n}\n\n// Create ChatRoom as a type of ChatMediator\nChatMediator* newChatRoom() {\n  ChatMediator* newChatMediator = (ChatMediator*)malloc(sizeof(ChatMediator));\n  newChatMediator->sendMessage = chatRoomSendMessage;\n  return newChatMediator;\n}\n\n// User's Methods\nchar* getName(User* self) {\n  return self->name;\n}\n\nvoid send(User* self, const char* message) {\n  printf(\"[%s] sends message: %s\\n\", self->getName(self), message);\n  self->mediator->sendMessage(self->mediator, message, self);\n}\n\nvoid receive(User* self, const char* message) {\n  printf(\"[%s] received message: %s\\n\", self->getName(self), message);\n}\n\n// Constructor for ChatUser, derived from User\nUser* newUser(char* name, ChatMediator* mediator) {\n  User* newUser = (User*)malloc(sizeof(User));\n  strcpy(newUser->name, name);\n  newUser->mediator = mediator;\n  newUser->getName = getName;\n  newUser->send = send;\n  newUser->receive = receive;\n  return newUser;\n}\n\n// Main Function\nint main() {\n  // Creating a ChatMediator\n  ChatMediator* chatMediator = newChatRoom();\n\n  // Creating Users\n  User* user1 = newUser(\"User1\", chatMediator);\n  User* user2 = newUser(\"User2\", chatMediator);\n\n  // Sending Messages\n  user1->send(user1, \"Hello, User2!\");\n  user2->send(user2, \"Hi, User1!\");\n\n  // Cleanup\n  free(user1);\n  free(user2);\n  free(chatMediator);\n\n  return 0;\n}\n\n/**\n * In this C adaptation of the Mediator pattern example, communication between users in a chat room\n * is facilitated through the Mediator design pattern. The ChatMediator struct acts as an interface\n * for sending messages, with its concrete implementation in the ChatRoom. The sendMessage function\n * of the ChatRoom sends a message from one user to another.\n *\n * The User struct serves as an interface for chat participants, allowing them to send and receive\n * messages, and to return their names. The ChatUser is a concrete User that interacts with a mediator\n * to facilitate message sending and receiving.\n *\n * In the main function, a chat room mediator and two chat users are created. The users send messages to\n * each other through the mediator, demonstrating the decoupling of communication logic from the user objects\n * themselves, which is the core benefit of the Mediator pattern.\n */"}]},{"title":"Memento","examples":[{"codeFile":"patterns/behavioural/memento/example","code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Forward declaration for mutual references\ntypedef struct Memento Memento;\n\n// Editor Struct represents the object whose state needs to be saved and restored\ntypedef struct {\n    char* text;\n} Editor;\n\n// Editor function declarations\nvoid initEditor(Editor* editor, const char* text);\nvoid setText(Editor* editor, const char* text);\nconst char* getText(Editor* editor);\nMemento* save(Editor* editor);\nvoid restore(Editor* editor, Memento* memento);\n\n// Memento Struct represents the stored state of the editor\nstruct Memento {\n    char* state;\n};\n\n// Memento function declarations\nMemento* createMemento(const char* state);\nvoid destroyMemento(Memento* memento);\nconst char* getState(Memento* memento);\n\n// History Struct is responsible for keeping track of multiple mementos\ntypedef struct {\n    Memento** mementos;\n    int size;\n    int capacity;\n} History;\n\n// History function declarations\nvoid initHistory(History* history);\nvoid addMemento(History* history, Memento* memento);\nMemento* getLatestMemento(History* history);\nvoid clearHistory(History* history);\n\n// Editor functions\nvoid initEditor(Editor* editor, const char* text) {\n    editor->text = strdup(text);\n}\n\nvoid setText(Editor* editor, const char* text) {\n    free(editor->text);\n    editor->text = strdup(text);\n}\n\nconst char* getText(Editor* editor) {\n    return editor->text;\n}\n\nMemento* save(Editor* editor) {\n    return createMemento(editor->text);\n}\n\nvoid restore(Editor* editor, Memento* memento) {\n    setText(editor, getState(memento));\n}\n\n// Memento functions\nMemento* createMemento(const char* state) {\n    Memento* m = (Memento*)malloc(sizeof(Memento));\n    m->state = strdup(state);\n    return m;\n}\n\nvoid destroyMemento(Memento* memento) {\n    free(memento->state);\n    free(memento);\n}\n\nconst char* getState(Memento* memento) {\n    return memento->state;\n}\n\n// History functions\nvoid initHistory(History* history) {\n    history->size = 0;\n    history->capacity = 2;\n    history->mementos = (Memento**)malloc(sizeof(Memento*) * history->capacity);\n}\n\nvoid addMemento(History* history, Memento* memento) {\n    if (history->size >= history->capacity) {\n        history->capacity *= 2;\n        history->mementos = (Memento**)realloc(history->mementos, sizeof(Memento*) * history->capacity);\n    }\n    history->mementos[history->size++] = memento;\n}\n\nMemento* getLatestMemento(History* history) {\n    if (history->size == 0) {\n        printf(\"No mementos available\\n\");\n        exit(1);\n    }\n    return history->mementos[history->size - 1];\n}\n\nvoid clearHistory(History* history) {\n    for (int i = 0; i < history->size; i++) {\n        destroyMemento(history->mementos[i]);\n    }\n    free(history->mementos);\n    history->mementos = NULL;\n    history->size = 0;\n    history->capacity = 0;\n}\n\n// Main function demonstrating the Memento pattern in C\nint main() {\n    Editor editor;\n    History history;\n    \n    initEditor(&editor, \"Initial text\");\n    initHistory(&history);\n    \n    // Add a memento to the history\n    addMemento(&history, save(&editor));\n    \n    // Modify the text\n    setText(&editor, \"Modified text\");\n    \n    // Add another memento to the history\n    addMemento(&history, save(&editor));\n    \n    // Restore the editor's state to a previous memento\n    restore(&editor, getLatestMemento(&history));\n    \n    printf(\"%s\\n\", getText(&editor)); // Output: Modified text (restored from the previous state)\n    \n    clearHistory(&history);\n    free(editor.text);\n    \n    return 0;\n}\n"}]},{"title":"Observer","examples":[{"codeFile":"patterns/behavioural/observer/example","code":"#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct Observer Observer;\ntypedef struct Subject Subject;\n\nstruct Observer {\n    void (*update)(Observer* self, void* data);\n};\n\nstruct Subject {\n    void (*subscribe)(Subject* self, Observer* observer);\n    void (*unsubscribe)(Subject* self, Observer* observer);\n    void (*notify)(Subject* self, void* data);\n    Observer** observers;\n    int observerCount;\n};\n\nvoid subscribe(Subject* self, Observer* observer) {\n    self->observers = realloc(self->observers, sizeof(Observer*) * (self->observerCount + 1));\n    self->observers[self->observerCount++] = observer;\n}\n\nvoid unsubscribe(Subject* self, Observer* observer) {\n    for(int i = 0; i < self->observerCount; i++) {\n        if(self->observers[i] == observer) {\n            for(int j = i; j < self->observerCount - 1; j++) {\n                self->observers[j] = self->observers[j + 1];\n            }\n            self->observerCount--;\n            self->observers = realloc(self->observers, sizeof(Observer*) * self->observerCount);\n            break;\n        }\n    }\n}\n\nvoid notify(Subject* self, void* data) {\n    for(int i = 0; i < self->observerCount; i++) {\n        self->observers[i]->update(self->observers[i], data);\n    }\n}\n\ntypedef struct {\n    Subject base;\n} ConcreteSubject;\n\ntypedef struct {\n    Observer base;\n} ConcreteObserver;\n\nvoid ConcreteObserver_update(Observer* self, void* data) {\n    printf(\"Observer received data: %s\\n\", (char*)data);\n}\n\nObserver* new_ConcreteObserver() {\n    ConcreteObserver* observer = malloc(sizeof(ConcreteObserver));\n    observer->base.update = ConcreteObserver_update;\n    return (Observer*)observer;\n}\n\nSubject* new_ConcreteSubject() {\n    ConcreteSubject* subject = malloc(sizeof(ConcreteSubject));\n    subject->base.subscribe = subscribe;\n    subject->base.unsubscribe = unsubscribe;\n    subject->base.notify = notify;\n    subject->base.observers = NULL;\n    subject->base.observerCount = 0;\n    return (Subject*)subject;\n}\n\nint main() {\n    Subject* subject = new_ConcreteSubject();\n    \n    Observer* observer1 = new_ConcreteObserver();\n    Observer* observer2 = new_ConcreteObserver();\n\n    subject->subscribe(subject, observer1);\n    subject->subscribe(subject, observer2);\n\n    subject->notify(subject, \"Hello Observers!\");\n\n    subject->unsubscribe(subject, observer2);\n    subject->notify(subject, \"Goodbye Observers!\");\n\n    free(observer1);\n    free(observer2);\n    free(subject->observers);\n    free(subject);\n\n    return 0;\n}"}]},{"title":"State","examples":[{"codeFile":"patterns/behavioural/state/example","code":"#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\n// Forward declarations\nstruct TrafficLight;\nstruct TrafficLightState;\n\n// Function pointer type for state change behavior\ntypedef void (*ChangeStateFn)(struct TrafficLight*);\n\n// TrafficLightState struct (acts as an interface in C)\ntypedef struct TrafficLightState {\n    ChangeStateFn changeState;\n} TrafficLightState;\n\n// Function prototypes for state change implementations\nvoid RedStateChange(struct TrafficLight* trafficLight);\nvoid YellowStateChange(struct TrafficLight* trafficLight);\nvoid GreenStateChange(struct TrafficLight* trafficLight);\n\n// Concrete states\ntypedef struct {\n    TrafficLightState base;\n} RedState;\n\ntypedef struct {\n    TrafficLightState base;\n} YellowState;\n\ntypedef struct {\n    TrafficLightState base;\n} GreenState;\n\n// TrafficLight Context\ntypedef struct TrafficLight {\n    TrafficLightState* state;\n    RedState redState;\n    YellowState yellowState;\n    GreenState greenState;\n} TrafficLight;\n\n// TrafficLight method to change its state\nvoid TrafficLightSetState(TrafficLight* trafficLight, TrafficLightState* newState) {\n    trafficLight->state = newState;\n    newState->changeState(trafficLight);\n}\n\n// Concrete state implementations\nvoid RedStateChange(TrafficLight* trafficLight) {\n    printf(\"Traffic light is now RED. Stop!\\n\");\n    sleep(3);\n    TrafficLightSetState(trafficLight, (TrafficLightState*)&trafficLight->yellowState);\n}\n\nvoid YellowStateChange(TrafficLight* trafficLight) {\n    printf(\"Traffic light is now YELLOW. Prepare to stop or proceed with caution.\\n\");\n    sleep(2);\n    TrafficLightSetState(trafficLight, (TrafficLightState*)&trafficLight->greenState);\n}\n\nvoid GreenStateChange(TrafficLight* trafficLight) {\n    printf(\"Traffic light is now GREEN. Go!\\n\");\n    sleep(4);\n    TrafficLightSetState(trafficLight, (TrafficLightState*)&trafficLight->redState);\n}\n\n// Constructor-like functions for the states\nvoid InitRedState(RedState* state) {\n    state->base.changeState = RedStateChange;\n}\n\nvoid InitYellowState(YellowState* state) {\n    state->base.changeState = YellowStateChange;\n}\n\nvoid InitGreenState(GreenState* state) {\n    state->base.changeState = GreenStateChange;\n}\n\n// Constructor for TrafficLight\nvoid InitTrafficLight(TrafficLight* trafficLight) {\n    InitRedState(&trafficLight->redState);\n    InitYellowState(&trafficLight->yellowState);\n    InitGreenState(&trafficLight->greenState);\n    trafficLight->state = (TrafficLightState*)&trafficLight->redState; // Initial state is Red\n    trafficLight->state->changeState(trafficLight);\n}\n\n// Client code\nint main() {\n    TrafficLight trafficLight;\n    InitTrafficLight(&trafficLight);\n\n    return 0;\n}\n"}]},{"title":"Strategy","examples":[{"codeFile":"patterns/behavioural/strategy/example","code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Definition for \"PaymentStrategy\" behavior\ntypedef struct PaymentStrategy_s PaymentStrategy;\nstruct PaymentStrategy_s {\n    void (*pay)(PaymentStrategy*, int amount);\n};\n\n// CreditCardPaymentStrategy\n\ntypedef struct {\n    PaymentStrategy base; // Base type to simulate inheritance\n    char* cardNumber;\n    char* expiryDate;\n    char* cvv;\n} CreditCardPaymentStrategy;\n\nvoid CreditCardPay(PaymentStrategy* strategy, int amount) {\n    CreditCardPaymentStrategy* self = (CreditCardPaymentStrategy*)strategy;\n    printf(\"Processing credit card payment of $%d with card number %s\\n\", amount, self->cardNumber);\n    // Logic to process payment via credit card\n}\n\nCreditCardPaymentStrategy* NewCreditCardPaymentStrategy(char* cardNumber, char* expiryDate, char* cvv) {\n    CreditCardPaymentStrategy* strategy = (CreditCardPaymentStrategy*)malloc(sizeof(CreditCardPaymentStrategy));\n    strategy->base.pay = CreditCardPay;\n    strategy->cardNumber = strdup(cardNumber);\n    strategy->expiryDate = strdup(expiryDate);\n    strategy->cvv = strdup(cvv);\n    return strategy;\n}\n\n// PayPalPaymentStrategy\n\ntypedef struct {\n    PaymentStrategy base; // Base type to simulate inheritance\n    char* email;\n    char* password;\n} PayPalPaymentStrategy;\n\nvoid PayPalPay(PaymentStrategy* strategy, int amount) {\n    PayPalPaymentStrategy* self = (PayPalPaymentStrategy*)strategy;\n    printf(\"Processing PayPal payment of $%d with email %s\\n\", amount, self->email);\n    // Logic to process payment via PayPal\n}\n\nPayPalPaymentStrategy* NewPayPalPaymentStrategy(char* email, char* password) {\n    PayPalPaymentStrategy* strategy = (PayPalPaymentStrategy*)malloc(sizeof(PayPalPaymentStrategy));\n    strategy->base.pay = PayPalPay;\n    strategy->email = strdup(email);\n    strategy->password = strdup(password);\n    return strategy;\n}\n\n// PaymentProcessor\n\ntypedef struct {\n    PaymentStrategy* strategy; // Current payment strategy\n} PaymentProcessor;\n\nvoid SetPaymentStrategy(PaymentProcessor* processor, PaymentStrategy* strategy) {\n    processor->strategy = strategy;\n}\n\nvoid ProcessPayment(PaymentProcessor* processor, int amount) {\n    if (processor->strategy) {\n        processor->strategy->pay(processor->strategy, amount);\n    } else {\n        printf(\"Payment strategy not set. Please select a payment method.\\n\");\n    }\n}\n\n/********* Client Code *********/\n\nint main() {\n    PaymentProcessor processor = {0};\n\n    // Select a payment method (strategy) dynamically\n    CreditCardPaymentStrategy* creditCardStrategy = NewCreditCardPaymentStrategy(\"1234 5678 9012 3456\", \"12/25\", \"123\");\n    SetPaymentStrategy(&processor, (PaymentStrategy*)creditCardStrategy);\n    ProcessPayment(&processor, 100);\n\n    // Change payment method (strategy)\n    PayPalPaymentStrategy* payPalStrategy = NewPayPalPaymentStrategy(\"example@example.com\", \"password\");\n    SetPaymentStrategy(&processor, (PaymentStrategy*)payPalStrategy);\n    ProcessPayment(&processor, 50);\n\n    // Cleanup\n    free(creditCardStrategy->cardNumber);\n    free(creditCardStrategy->expiryDate);\n    free(creditCardStrategy->cvv);\n    free(creditCardStrategy);\n\n    free(payPalStrategy->email);\n    free(payPalStrategy->password);\n    free(payPalStrategy);\n\n    return 0;\n}"}]},{"title":"Template Method","examples":[{"codeFile":"patterns/behavioural/template-method/example","code":"#include <stdio.h>\n\n// Forward declaration of the structures\ntypedef struct Breakfast Breakfast;\ntypedef struct OmeletteBreakfast OmeletteBreakfast;\ntypedef struct PancakeBreakfast PancakeBreakfast;\n\n// Function pointers for polymorphic behavior\ntypedef void (*FuncPtrAddIngredients)(void);\ntypedef void (*FuncPtrCook)(void);\n\n// Breakfast structure, acting as an abstract base class\nstruct Breakfast {\n    FuncPtrAddIngredients addIngredients;\n    FuncPtrCook cook;\n};\n\n// Concrete methods\nvoid boilWater() {\n    printf(\"Boiling water...\\n\");\n}\n\nvoid serve() {\n    printf(\"Breakfast is served!\\n\");\n}\n\n// Template method\nvoid prepare(Breakfast *breakfast) {\n    boilWater();\n    breakfast->addIngredients();\n    breakfast->cook();\n    serve();\n}\n\n// OmeletteBreakfast functions implementing the required behavior\nvoid omeletteAddIngredients() {\n    printf(\"Adding eggs, cheese, and vegetables to the pan.\\n\");\n}\n\nvoid omeletteCook() {\n    printf(\"Cooking the omelette until golden brown.\\n\");\n}\n\n// PancakeBreakfast functions implementing the required behavior\nvoid pancakeAddIngredients() {\n    printf(\"Mixing flour, eggs, milk, and sugar to make the batter.\\n\");\n}\n\nvoid pancakeCook() {\n    printf(\"Pouring the batter onto the griddle and flipping until cooked.\\n\");\n}\n\n// Function to create an OmeletteBreakfast\nvoid initOmeletteBreakfast(OmeletteBreakfast *omeletteBreakfast) {\n    if (omeletteBreakfast != NULL) {\n        omeletteBreakfast->base.addIngredients = omeletteAddIngredients;\n        omeletteBreakfast->base.cook = omeletteCook;\n    }\n}\n\n// Function to create a PancakeBreakfast\nvoid initPancakeBreakfast(PancakeBreakfast *pancakeBreakfast) {\n    if (pancakeBreakfast != NULL) {\n        pancakeBreakfast->base.addIngredients = pancakeAddIngredients;\n        pancakeBreakfast->base.cook = pancakeCook;\n    }\n}\n\n// OmeletteBreakfast structure\nstruct OmeletteBreakfast {\n    Breakfast base;\n};\n\n// PancakeBreakfast structure\nstruct PancakeBreakfast {\n    Breakfast base;\n};\n\nint main() {\n    // Preparing Omelette Breakfast\n    printf(\"Preparing Omelette Breakfast:\\n\");\n    OmeletteBreakfast omeletteBreakfast;\n    initOmeletteBreakfast(&omeletteBreakfast);\n    prepare((Breakfast *)&omeletteBreakfast);\n\n    printf(\"\\nPreparing Pancake Breakfast:\\n\");\n    PancakeBreakfast pancakeBreakfast;\n    initPancakeBreakfast(&pancakeBreakfast);\n    prepare((Breakfast *)&pancakeBreakfast);\n\n    return 0;\n}"}]},{"title":"Visitor","examples":[{"codeFile":"patterns/behavioural/visitor/example","code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Forward declaration of structs to resolve circular dependency\ntypedef struct AnimalVisitor AnimalVisitor;\ntypedef struct Animal Animal;\n\n// Visitor interface function pointers\ntypedef void (*visitLionFunc)(Animal*, AnimalVisitor*);\ntypedef void (*visitElephantFunc)(Animal*, AnimalVisitor*);\ntypedef void (*visitGiraffeFunc)(Animal*, AnimalVisitor*);\n\n// Animal interface function pointer\ntypedef void (*acceptFunc)(Animal*, AnimalVisitor*);\n\nstruct AnimalVisitor {\n  visitLionFunc visitLion;\n  visitElephantFunc visitElephant;\n  visitGiraffeFunc visitGiraffe;\n};\n\nstruct Animal {\n  char* name;\n  acceptFunc accept;\n};\n\ntypedef struct {\n  Animal base;\n} Lion;\n\ntypedef struct {\n  Animal base;\n} Elephant;\n\ntypedef struct {\n  Animal base;\n} Giraffe;\n\n// AnimalFeeder functions\nvoid visitLion(Animal* lion, AnimalVisitor* visitor) {\n  printf(\"Feeding meat to %s.\\n\", lion->name);\n}\n\nvoid visitElephant(Animal* elephant, AnimalVisitor* visitor) {\n  printf(\"Feeding hay to %s.\\n\", elephant->name);\n}\n\nvoid visitGiraffe(Animal* giraffe, AnimalVisitor* visitor) {\n  printf(\"Feeding leaves to %s.\\n\", giraffe->name);\n}\n\nAnimalVisitor createAnimalFeeder() {\n  AnimalVisitor feeder = {visitLion, visitElephant, visitGiraffe};\n  return feeder;\n}\n\n// Animal accept functions\nvoid Lion_accept(Animal* lion, AnimalVisitor* visitor) {\n  visitor->visitLion(lion, visitor);\n}\n\nvoid Elephant_accept(Animal* elephant, AnimalVisitor* visitor) {\n  visitor->visitElephant(elephant, visitor);\n}\n\nvoid Giraffe_accept(Animal* giraffe, AnimalVisitor* visitor) {\n  visitor->visitGiraffe(giraffe, visitor);\n}\n\n// Constructors for animals\nLion* createLion(char* name) {\n  Lion* lion = (Lion*)malloc(sizeof(Lion));\n  lion->base.name = strdup(name);\n  lion->base.accept = Lion_accept;\n  return lion;\n}\n\nElephant* createElephant(char* name) {\n  Elephant* elephant = (Elephant*)malloc(sizeof(Elephant));\n  elephant->base.name = strdup(name);\n  elephant->base.accept = Elephant_accept;\n  return elephant;\n}\n\nGiraffe* createGiraffe(char* name) {\n  Giraffe* giraffe = (Giraffe*)malloc(sizeof(Giraffe));\n  giraffe->base.name = strdup(name);\n  giraffe->base.accept = Giraffe_accept;\n  return giraffe;\n}\n\n// Zoo structure and functions\ntypedef struct {\n  Animal** animals;\n  int animalCount;\n} Zoo;\n\nvoid Zoo_addAnimal(Zoo* zoo, Animal* animal) {\n  zoo->animals = realloc(zoo->animals, sizeof(Animal*) * (zoo->animalCount + 1));\n  zoo->animals[zoo->animalCount++] = animal;\n}\n\nvoid Zoo_performOperation(Zoo* zoo, AnimalVisitor visitor) {\n  for (int i = 0; i < zoo->animalCount; i++) {\n    zoo->animals[i]->accept(zoo->animals[i], &visitor);\n  }\n}\n\nint main() {\n  Zoo zoo = {NULL, 0};\n\n  // Adding animals to the zoo\n  Zoo_addAnimal(&zoo, (Animal*)createLion(\"Simba\"));\n  Zoo_addAnimal(&zoo, (Animal*)createElephant(\"Dumbo\"));\n  Zoo_addAnimal(&zoo, (Animal*)createGiraffe(\"Melman\"));\n\n  // Creating a visitor\n  AnimalVisitor feeder = createAnimalFeeder();\n\n  // Feeding the animals\n  Zoo_performOperation(&zoo, feeder);\n\n  // Cleanup\n  for(int i = 0; i < zoo.animalCount; i++) {\n    free(zoo.animals[i]->name);\n    free(zoo.animals[i]);\n  }\n  free(zoo.animals);\n\n  return 0;\n}"}]}],"patterns_creational":[{"title":"Factory Method","examples":[{"codeFile":"patterns/creational/factory-method/example","code":"#include <stdio.h>\n#include <stdlib.h>\n\n// Vehicle Types\ntypedef enum {\n    CAR,\n    TRUCK\n} VehicleType;\n\n// Vehicle interface equivalent in C\ntypedef struct Vehicle {\n    void (*drive)(struct Vehicle *);\n} Vehicle;\n\n// Function declarations for Car and Truck drive methods\nvoid driveCar(Vehicle *vehicle);\nvoid driveTruck(Vehicle *vehicle);\n\n// Car struct\ntypedef struct {\n    Vehicle base;\n    // Car-specific attributes can be added here\n} Car;\n\n// Truck struct\ntypedef struct {\n    Vehicle base;\n    // Truck-specific attributes can be added here\n} Truck;\n\n// Factory Method equivalent in C\nVehicle* createVehicle(VehicleType type) {\n    // Depending on the type parameter, instantiate a Car or Truck\n    switch (type) {\n        case CAR: {\n            Car *car = (Car *)malloc(sizeof(Car));\n            if (!car) return NULL;\n            car->base.drive = driveCar;\n            printf(\"Creating a car...\\n\");\n            return (Vehicle *)car;\n        }\n        case TRUCK: {\n            Truck *truck = (Truck *)malloc(sizeof(Truck));\n            if (!truck) return NULL;\n            truck->base.drive = driveTruck;\n            printf(\"Creating a truck...\\n\");\n            return (Vehicle *)truck;\n        }\n        default:\n            return NULL;\n    }\n}\n\n// Implementation of the drive method for Car\nvoid driveCar(Vehicle *vehicle) {\n    printf(\"Driving a car...\\n\");\n}\n\n// Implementation of the drive method for Truck\nvoid driveTruck(Vehicle *vehicle) {\n    printf(\"Driving a truck...\\n\");\n}\n\n// Deliver Vehicle function, which uses the \"factory method\"\nvoid deliverVehicle(VehicleType type) {\n    Vehicle *vehicle = createVehicle(type);\n    if (!vehicle) return;\n    printf(\"Delivering the vehicle...\\n\");\n    vehicle->drive(vehicle);\n    free(vehicle); // Clean up\n}\n\nint main() {\n    // Client code to use the factory for creating and delivering vehicles\n    \n    // Create and deliver a Car\n    deliverVehicle(CAR);\n    \n    // Create and deliver a Truck\n    deliverVehicle(TRUCK);\n\n    return 0;\n}\n\n/**\n * In C, the Vehicle interface is represented as a struct with function pointers for behavior,\n * allowing for polymorphic behavior similar to what interfaces provide in object-oriented languages.\n *\n * The \"drive\" function pointer in the Vehicle struct acts similarly to the drive() method in the Vehicle interface from the OOP example.\n *\n * Car and Truck structs are defined with a Vehicle as their first member, allowing them to be treated as Vehicles.\n * This pattern is known as \"inheritance\" in object-oriented programming, achieved here through composition and function pointers for polymorphic behavior.\n *\n * The global function `createVehicle` acts as the factory method, returning pointers to Vehicle based on the requested type.\n *\n * The `deliverVehicle` function demonstrates the use of the factory method to create and operate on vehicles without knowing their concrete types.\n *\n * The translation from an Object-Oriented Pattern to a procedural language like C demonstrates how polymorphism and encapsulation can be achieved through \n * structured programming techniques.\n */"}]},{"title":"Abstract Factory","examples":[{"codeFile":"patterns/creational/abstract-factory/example","code":"#include <stdio.h>\n#include <stdlib.h>\n\n/* Forward declarations for the functions and types */\ntypedef struct Chair Chair;\ntypedef struct Table Table;\ntypedef struct FurnitureFactory FurnitureFactory;\n\n/* Abstract Chair */\nstruct Chair {\n    void (*sitOn)(Chair*);\n};\n\n/* Abstract Table */\nstruct Table {\n    void (*putOn)(Table*);\n};\n\n/* Abstract FurnitureFactory */\nstruct FurnitureFactory {\n    Chair* (*createChair)();\n    Table* (*createTable)();\n};\n\n/* Concrete Modern Chair */\ntypedef struct {\n    Chair chair;\n} ModernChair;\n\nvoid sitOnModernChair(Chair* c) {\n    printf(\"Sitting on a modern chair.\\n\");\n}\n\n/* Concrete Vintage Chair */\ntypedef struct {\n    Chair chair;\n} VintageChair;\n\nvoid sitOnVintageChair(Chair* c) {\n    printf(\"Sitting on a vintage chair.\\n\");\n}\n\n/* Concrete Modern Table */\ntypedef struct {\n    Table table;\n} ModernTable;\n\nvoid putOnModernTable(Table* t) {\n    printf(\"Putting something on a modern table.\\n\");\n}\n\n/* Concrete Vintage Table */\ntypedef struct {\n    Table table;\n} VintageTable;\n\nvoid putOnVintageTable(Table* t) {\n    printf(\"Putting something on a vintage table.\\n\");\n}\n\n/* Concrete Factory: Modern Furniture Factory */\ntypedef struct {\n    FurnitureFactory factory;\n} ModernFurnitureFactory;\n\nChair* createModernChair() {\n    ModernChair* chair = (ModernChair*)malloc(sizeof(ModernChair));\n    chair->chair.sitOn = sitOnModernChair;\n    return (Chair*) chair;\n}\n\nTable* createModernTable() {\n    ModernTable* table = (ModernTable*)malloc(sizeof(ModernTable));\n    table->table.putOn = putOnModernTable;\n    return (Table*) table;\n}\n\n/* Concrete Factory: Vintage Furniture Factory */\ntypedef struct {\n    FurnitureFactory factory;\n} VintageFurnitureFactory;\n\nChair* createVintageChair() {\n    VintageChair* chair = (VintageChair*)malloc(sizeof(VintageChair));\n    chair->chair.sitOn = sitOnVintageChair;\n    return (Chair*) chair;\n}\n\nTable* createVintageTable() {\n    VintageTable* table = (VintageTable*)malloc(sizeof(VintageTable));\n    table->table.putOn = putOnVintageTable;\n    return (Table*) table;\n}\n\n/* Client code */\nvoid createFurniture(FurnitureFactory* factory) {\n    Chair* chair = factory->createChair();\n    Table* table = factory->createTable();\n\n    printf(\"Created furniture:\\n\");\n    chair->sitOn(chair);\n    table->putOn(table);\n\n    free(chair);\n    free(table);\n}\n\nint main(int argc, char* argv[]) {\n    /* Initializing the abstract factories */\n    ModernFurnitureFactory modernFactory = {{createModernChair, createModernTable}};\n    VintageFurnitureFactory vintageFactory = {{createVintageChair, createVintageTable}};\n\n    printf(\"Creating modern furniture:\\n\");\n    createFurniture((FurnitureFactory*)&modernFactory);\n\n    printf(\"\\nCreating vintage furniture:\\n\");\n    createFurniture((FurnitureFactory*)&vintageFactory);\n\n    return 0;\n}"}]},{"title":"Builder","examples":[{"codeFile":"patterns/creational/builder/example","code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct {\n    char *cpu;\n    int ram;\n    int storage;\n    char *gpu;\n    int screenSize;\n} Computer;\n\n// Function to display the specifications of the computer\nvoid displaySpecs(Computer *computer) {\n    printf(\"CPU: %s\\n\", computer->cpu);\n    printf(\"RAM: %d GB\\n\", computer->ram);\n    printf(\"Storage: %d GB\\n\", computer->storage);\n    printf(\"GPU: %s\\n\", computer->gpu);\n    printf(\"Screen Size: %d inches\\n\", computer->screenSize);\n}\n\ntypedef struct {\n    void (*setCPU)(Computer **, char*);\n    void (*setRAM)(Computer **, int);\n    void (*setStorage)(Computer **, int);\n    void (*setGPU)(Computer **, char*);\n    void (*setScreenSize)(Computer **, int);\n    Computer* (*getResult)(Computer **);\n} ComputerBuilder;\n\nvoid setCPU(Computer **computer, char *cpu) {\n    (*computer)->cpu = strdup(cpu);\n}\n\nvoid setRAM(Computer **computer, int ram) {\n    (*computer)->ram = ram;\n}\n\nvoid setStorage(Computer **computer, int storage) {\n    (*computer)->storage = storage;\n}\n\nvoid setGPU(Computer **computer, char *gpu) {\n    (*computer)->gpu = strdup(gpu);\n}\n\nvoid setScreenSize(Computer **computer, int screenSize) {\n    (*computer)->screenSize = screenSize;\n}\n\nComputer* getResult(Computer **computer) {\n    return *computer;\n}\n\n// Initializes a new computer with default values\nComputer* newComputer() {\n    Computer *comp = (Computer *)malloc(sizeof(Computer));\n    comp->cpu = \"\";\n    comp->ram = 0;\n    comp->storage = 0;\n    comp->gpu = \"\";\n    comp->screenSize = 0;\n    return comp;\n}\n\n// Initializes the ComputerBuilder for a computer with function pointers to the setters\nComputerBuilder* newComputerBuilder() {\n    ComputerBuilder *builder = (ComputerBuilder *)malloc(sizeof(ComputerBuilder));\n    builder->setCPU = setCPU;\n    builder->setRAM = setRAM;\n    builder->setStorage = setStorage;\n    builder->setGPU = setGPU;\n    builder->setScreenSize = setScreenSize;\n    builder->getResult = getResult;\n    return builder;\n}\n\n// Director that constructs the computer using the builder\nvoid constructGamingComputer(ComputerBuilder *builder, Computer **computer) {\n    builder->setCPU(computer, \"Intel Core i9\");\n    builder->setRAM(computer, 32);\n    builder->setStorage(computer, 1000);\n    builder->setGPU(computer, \"NVIDIA GeForce RTX 3080\");\n    builder->setScreenSize(computer, 27);\n}\n\n// Main function demonstrating the builder pattern\nint main() {\n    Computer *gamingComputer = newComputer();\n    ComputerBuilder *builder = newComputerBuilder();\n    constructGamingComputer(builder, &gamingComputer);\n    printf(\"Gaming Computer Specifications:\\n\");\n    displaySpecs(gamingComputer);\n\n    // Clean up\n    free(gamingComputer->cpu);\n    free(gamingComputer->gpu);\n    free(gamingComputer);\n    free(builder);\n\n    return 0;\n}"}]},{"title":"Prototype","examples":[{"codeFile":"patterns/creational/prototype/example","code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// UserProfile struct\ntypedef struct UserProfile UserProfile;\n\n// Function pointers within the UserProfile struct\nstruct UserProfile {\n    void (*clone)(UserProfile *this, UserProfile **target);\n    void (*customizeProfile)(UserProfile *this, const char *username, const char *bio, const char *profilePicture);\n    void (*displayProfile)(UserProfile *this);\n    // Attributes\n    char *username;\n    char *bio;\n    char *profilePicture;\n};\n\n// Function to clone a UserProfile\nvoid clone(UserProfile *this, UserProfile **target) {\n    *target = malloc(sizeof(UserProfile));\n    **target = *this;\n    (*target)->username = strdup(this->username);\n    (*target)->bio = strdup(this->bio);\n    (*target)->profilePicture = strdup(this->profilePicture);\n}\n\n// Function to customize UserProfile\nvoid customizeProfile(UserProfile *this, const char *username, const char *bio, const char *profilePicture) {\n    if (username) {\n        free(this->username);\n        this->username = strdup(username);\n    }\n    if (bio) {\n        free(this->bio);\n        this->bio = strdup(bio);\n    }\n    if (profilePicture) {\n        free(this->profilePicture);\n        this->profilePicture = strdup(profilePicture);\n    }\n}\n\n// Function to display UserProfile\nvoid displayProfile(UserProfile *this) {\n    printf(\"Username: %s\\n\", this->username);\n    printf(\"Bio: %s\\n\", this->bio);\n    printf(\"Profile Picture: %s\\n\", this->profilePicture);\n}\n\n// Factory for DefaultUserProfile\nvoid DefaultUserProfile(char *username, char *bio, char *profilePicture, UserProfile **profile) {\n    *profile = malloc(sizeof(UserProfile));\n    (*profile)->username = strdup(username);\n    (*profile)->bio = strdup(bio);\n    (*profile)->profilePicture = strdup(profilePicture);\n    (*profile)->clone = clone;\n    (*profile)->customizeProfile = customizeProfile;\n    (*profile)->displayProfile = displayProfile;\n}\n\n// Function to free UserProfile resources\nvoid FreeUserProfile(UserProfile *profile) {\n    free(profile->username);\n    free(profile->bio);\n    free(profile->profilePicture);\n    free(profile);\n}\n\nint main() {\n    // Create a default user profile\n    UserProfile *defaultProfile;\n    DefaultUserProfile(\"user123\", \"Welcome to my profile!\", \"default.jpg\", &defaultProfile);\n\n    // Clone the default profile to create a customized profile\n    UserProfile *customizedProfile;\n    defaultProfile->clone(defaultProfile, &customizedProfile);\n    customizedProfile->customizeProfile(customizedProfile, NULL, \"I'm a software developer.\", \"avatar.jpg\");\n\n    // Display both profiles\n    printf(\"Default Profile:\\n\");\n    defaultProfile->displayProfile(defaultProfile);\n\n    printf(\"\\nCustomized Profile:\\n\");\n    customizedProfile->displayProfile(customizedProfile);\n\n    // Free resources\n    FreeUserProfile(defaultProfile);\n    FreeUserProfile(customizedProfile);\n\n    return 0;\n}\n\n/**\n * Explanation of adaptation:\n * \n * - The UserProfile interface is represented by a struct in C, which includes function pointers for the clone,\n * customizeProfile, and displayProfile functions, along with username, bio, and profilePicture attributes.\n * \n * - The DefaultUserProfile class function initializes a UserProfile instance with provided values. The functions\n * clone, customizeProfile, and displayProfile are implemented to operate on UserProfile pointers.\n * \n * - The original object-oriented concepts like interfaces and inheritance don't directly map to C; thus, we use\n * structs and function pointers to achieve similar behavior.\n * \n * - Memory management is manual, using malloc for allocation and free for deallocation, along with the strdup\n * function for string copying.\n * \n * - This adaptation maintains the essence of the prototype design pattern, while adhering to C language idioms and practices.\n */"}]},{"title":"Singleton","examples":[{"codeFile":"patterns/creational/singleton/example","code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <time.h>\n\n#define MAX_HISTORY 1024\n#define MAX_LOG_LENGTH 256\n\ntypedef struct {\n    // Array of strings to store log history. In C, we manage memory allocation for strings dynamically.\n    char *logHistory[MAX_HISTORY];\n    int logCount;\n} Logger;\n\n// The Logger instance; static ensures it is only visible within this file.\nstatic Logger *instance = NULL;\n\n// Function declarations for the Logger. In C, we declare before defining these functions.\nstatic Logger *Logger_getInstance();\nstatic void Logger_log(Logger *self, const char *message);\nstatic void Logger_getLogHistory(Logger *self);\n\n// Private constructor equivalent in C. It initializes the Logger attributes.\nstatic Logger *Logger_init() {\n    Logger *logger = (Logger *)malloc(sizeof(Logger));\n    if (logger) {\n        for (int i = 0; i < MAX_HISTORY; i++) {\n            logger->logHistory[i] = NULL;\n        }\n        logger->logCount = 0;\n    }\n    return logger;\n}\n\n// Singleton getInstance() equivalent in C.\nstatic Logger *Logger_getInstance() {\n    if (instance == NULL) {\n        instance = Logger_init();\n    }\n    return instance;\n}\n\n// log() method equivalent in C.\nstatic void Logger_log(Logger *self, const char *message) {\n    if (self->logCount >= MAX_HISTORY) {\n        printf(\"Log history full\\n\");\n        return;\n    }\n\n    char *logEntry = (char *)malloc(MAX_LOG_LENGTH);\n    time_t now = time(NULL);\n    struct tm *t = localtime(&now);\n    // Generating timestamp format similar to ISO string in the original example\n    strftime(logEntry, MAX_LOG_LENGTH, \"[%Y-%m-%dT%H:%M:%SZ] \", t);\n    strcat(logEntry, message);\n\n    self->logHistory[self->logCount++] = logEntry;\n    printf(\"%s\\n\", logEntry);\n}\n\n// getLogHistory() method equivalent in C.\nstatic void Logger_getLogHistory(Logger *self) {\n    printf(\"Log History:\\n\");\n    for (int i = 0; i < self->logCount; i++) {\n        printf(\"%s\\n\", self->logHistory[i]);\n    }\n}\n\n// Method to clean up dynamically allocated log history.\nstatic void Logger_cleanup(Logger *logger) {\n    if (logger) {\n        for (int i = 0; i < logger->logCount; i++) {\n            free(logger->logHistory[i]);\n        }\n        free(logger);\n        instance = NULL;\n    }\n}\n\nint main() {\n    Logger *logger1 = Logger_getInstance();\n    Logger *logger2 = Logger_getInstance();\n\n    // Simulating original client code's output for comparison.\n    printf(\"Logger instances are the same: %s\\n\", (logger1 == logger2) ? \"true\" : \"false\");\n\n    Logger_log(logger1, \"User logged in\");\n    Logger_log(logger2, \"Data saved to database\");\n\n    Logger_getLogHistory(logger1);\n\n    Logger_cleanup(logger1); // Clean-up to prevent memory leaks in this example\n    return 0;\n}"}]}],"patterns_structural":[{"title":"Adapter","examples":[{"codeFile":"patterns/structural/adapter/example","code":"#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n// Adaptee: Existing MP3 player\n// Represents the existing audio player that can play MP3 files.\ntypedef struct {\n    void (*playMp3)(const char* fileName);\n} Mp3Player;\n\nvoid playMp3(const char* fileName) {\n    printf(\"Playing MP3 file: %s\\n\", fileName);\n}\n\nMp3Player createMp3Player() {\n    Mp3Player player;\n    player.playMp3 = playMp3;\n    return player;\n}\n\n// Target: Interface expected by the client (unified interface)\n// Defines the unified interface expected by the client application for playing audio files.\ntypedef struct {\n    void (*play)(const char* fileName);\n} AudioPlayer;\n\n// Adapter: Converts OGG audio files to MP3 format\n// Implements the AudioPlayer interface. It internally uses the Mp3Player to play MP3 files but converts OGG files to MP3 format before delegating to the Mp3Player.\ntypedef struct {\n    Mp3Player mp3Player;\n    void (*play)(const char* fileName);\n} OggToMp3Adapter;\n\nchar* convertToMp3(const char* fileName) {\n    // Simulate conversion process (replace extension)\n    char* mp3FileName = strdup(fileName);\n    char* ext = strrchr(mp3FileName, '.');\n    if (ext != NULL) strcpy(ext, \".mp3\");\n    return mp3FileName;\n}\n\nvoid adapterPlay(const char* fileName) {\n    printf(\"Converting OGG file '%s' to MP3 format\\n\", fileName);\n    char* mp3FileName = convertToMp3(fileName);\n    Mp3Player player = createMp3Player();\n    player.playMp3(mp3FileName);\n    free(mp3FileName);\n}\n\nOggToMp3Adapter createOggToMp3Adapter() {\n    OggToMp3Adapter adapter;\n    adapter.mp3Player = createMp3Player(); // might be unnecessary unless mp3Player needs initialization\n    adapter.play = adapterPlay;\n    return adapter;\n}\n\nint main() {\n    // Client code\n    OggToMp3Adapter adapter = createOggToMp3Adapter();\n    AudioPlayer audioPlayer;\n    audioPlayer.play = adapter.play;\n\n    // Play MP3 file\n    audioPlayer.play(\"audio1.mp3\");\n\n    // Play OGG file (automatically converted to MP3)\n    audioPlayer.play(\"audio2.ogg\");\n\n    return 0;\n}"}]},{"title":"Bridge","examples":[{"codeFile":"patterns/structural/bridge/example","code":"#include <stdio.h>\n#include <stdlib.h>\n\n/* Workshop interface (Implementor) */\ntypedef struct Workshop Workshop;\nstruct Workshop {\n    void (*work)(Workshop *);\n};\n\n/* Paint Workshop (Concrete Implementor) */\nvoid PaintWorkshop_work(Workshop *self) {\n    printf(\"Painting vehicle\\n\");\n}\n\nWorkshop* PaintWorkshop_new() {\n    Workshop* pws = (Workshop*)malloc(sizeof(Workshop));\n    pws->work = PaintWorkshop_work;\n    return pws;\n}\n\n/* Repair Workshop (Concrete Implementor) */\nvoid RepairWorkshop_work(Workshop *self) {\n    printf(\"Repairing vehicle\\n\");\n}\n\nWorkshop* RepairWorkshop_new() {\n    Workshop* rws = (Workshop*)malloc(sizeof(Workshop));\n    rws->work = RepairWorkshop_work;\n    return rws;\n}\n\n/* Vehicle (Abstraction) */\ntypedef struct Vehicle Vehicle;\nstruct Vehicle {\n    Workshop *workshop;\n    void (*manufacture)(Vehicle *);\n};\n\nvoid Vehicle_init(Vehicle *vehicle, Workshop *workshop) {\n    vehicle->workshop = workshop;\n}\n\n/* Car (Refined Abstraction) */\ntypedef struct {\n    Vehicle base;\n} Car;\n\nvoid Car_manufacture(Vehicle *vehicle) {\n    printf(\"Manufacturing car.\\n\");\n    vehicle->workshop->work(vehicle->workshop);\n}\n\nCar* Car_new(Workshop *workshop) {\n    Car* car = (Car*)malloc(sizeof(Car));\n    Vehicle_init((Vehicle *)car, workshop);\n    car->base.manufacture = Car_manufacture;\n    return car;\n}\n\n/* Truck (Refined Abstraction) */\ntypedef struct {\n    Vehicle base;\n} Truck;\n\nvoid Truck_manufacture(Vehicle *vehicle) {\n    printf(\"Manufacturing truck.\\n\");\n    vehicle->workshop->work(vehicle->workshop);\n}\n\nTruck* Truck_new(Workshop *workshop) {\n    Truck* truck = (Truck*)malloc(sizeof(Truck));\n    Vehicle_init((Vehicle *)truck, workshop);\n    truck->base.manufacture = Truck_manufacture;\n    return truck;\n}\n\n/* Client code */\nint main() {\n    Workshop *paintWorkshop = PaintWorkshop_new();\n    Vehicle *car = (Vehicle*) Car_new(paintWorkshop);\n    car->manufacture(car);\n\n    Workshop *repairWorkshop = RepairWorkshop_new();\n    Vehicle *truck = (Vehicle*) Truck_new(repairWorkshop);\n    truck->manufacture(truck);\n\n    free(paintWorkshop);\n    free(repairWorkshop);\n    free(car);\n    free(truck);\n\n    return 0;\n}\n\n/*\n * The Vehicle struct represents the abstraction, which is specialized by Car and Truck.\n *\n * The Workshop interface represents the implementor, defining the work function pointer.\n *\n * PaintWorkshop and RepairWorkshop are concrete implementations of the Workshop interface.\n *\n * Each vehicle can be associated with a specific workshop using function pointers for composition, delegating the work to the workshop.\n */"}]},{"title":"Composite","examples":[{"codeFile":"patterns/structural/composite/example","code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Forward declaration for Department_struct\nstruct Department_struct;\n\n// Defines a type for the function pointers to match the interface methods\ntypedef char* (*GetNameFunc)(struct Department_struct* self);\ntypedef char** (*GetEmployeesFunc)(struct Department_struct* self, int* count);\n\n// Department interface using function pointers\ntypedef struct Department_struct {\n    GetNameFunc getName;\n    GetEmployeesFunc getEmployees;\n    void* derivedObj; // Pointer to the derived object (Individual or Composite)\n} Department;\n\n// IndividualDepartment definition\ntypedef struct {\n    char* name;\n    char** employees;\n    int employeeCount;\n} IndividualDepartment;\n\n// CompositeDepartment definition\ntypedef struct {\n    char* name;\n    Department** departments;\n    int departmentCount;\n} CompositeDepartment;\n\n// IndividualDepartment method implementations\nchar* IndividualDepartment_getName(Department* self);\nchar** IndividualDepartment_getEmployees(Department* self, int* count);\n\n// CompositeDepartment method implementations\nchar* CompositeDepartment_getName(Department* self);\nvoid CompositeDepartment_addDepartment(Department* self, Department* department);\nvoid CompositeDepartment_removeDepartment(Department* self, Department* department);\nchar** CompositeDepartment_getEmployees(Department* self, int* count);\n\n// Department constructor prototypes\nDepartment* new_IndividualDepartment(char* name, char** employees, int employeeCount);\nDepartment* new_CompositeDepartment(char* name);\n\n// Utility functions\nchar** concatenateEmployeeLists(char** list1, int count1, char** list2, int count2, int* newCount);\n\n// Individual Department implementation\nchar* IndividualDepartment_getName(Department* self) {\n    IndividualDepartment* ind = (IndividualDepartment*)self->derivedObj;\n    return ind->name;\n}\n\nchar** IndividualDepartment_getEmployees(Department* self, int* count) {\n    IndividualDepartment* ind = (IndividualDepartment*)self->derivedObj;\n    *count = ind->employeeCount;\n    return ind->employees;\n}\n\nDepartment* new_IndividualDepartment(char* name, char** employees, int employeeCount) {\n    Department* dep = (Department*)malloc(sizeof(Department));\n    IndividualDepartment* ind = (IndividualDepartment*)malloc(sizeof(IndividualDepartment));\n\n    ind->name = strdup(name);\n    ind->employeeCount = employeeCount;\n    ind->employees = (char**)malloc(employeeCount * sizeof(char*));\n    for (int i = 0; i < employeeCount; ++i) {\n        ind->employees[i] = strdup(employees[i]);\n    }\n\n    dep->getName = IndividualDepartment_getName;\n    dep->getEmployees = IndividualDepartment_getEmployees;\n    dep->derivedObj = ind;\n    \n    return dep;\n}\n\n// Composite Department implementation\nchar* CompositeDepartment_getName(Department* self) {\n    CompositeDepartment* comp = (CompositeDepartment*)self->derivedObj;\n    return comp->name;\n}\n\nvoid CompositeDepartment_addDepartment(Department* self, Department* department) {\n    CompositeDepartment* comp = (CompositeDepartment*)self->derivedObj;\n    comp->departmentCount++;\n    comp->departments = (Department**)realloc(comp->departments, comp->departmentCount * sizeof(Department*));\n    comp->departments[comp->departmentCount - 1] = department;\n}\n\nvoid CompositeDepartment_removeDepartment(Department* self, Department* department) {\n    // Implementation omitted for brevity\n}\n\nchar** CompositeDepartment_getEmployees(Department* self, int* totalCount) {\n    *totalCount = 0;\n    CompositeDepartment* comp = (CompositeDepartment*)self->derivedObj;\n    char** employees = NULL;\n    \n    for (int i = 0; i < comp->departmentCount; ++i) {\n        int count;\n        char** departmentEmployees = comp->departments[i]->getEmployees(comp->departments[i], &count);\n        employees = concatenateEmployeeLists(employees, *totalCount, departmentEmployees, count, totalCount);\n    }\n\n    return employees;\n}\n\nDepartment* new_CompositeDepartment(char* name) {\n    Department* dep = (Department*)malloc(sizeof(Department));\n    CompositeDepartment* comp = (CompositeDepartment*)malloc(sizeof(CompositeDepartment));\n    \n    comp->name = strdup(name);\n    comp->departments = NULL;\n    comp->departmentCount = 0;\n\n    dep->getName = CompositeDepartment_getName;\n    dep->getEmployees = CompositeDepartment_getEmployees;\n    dep->derivedObj = comp;\n    \n    return dep;\n}\n\n// Helper function to concatenate two lists of strings\nchar** concatenateEmployeeLists(char** list1, int count1, char** list2, int count2, int* newCount) {\n    *newCount = count1 + count2;\n    char** newList = (char**)realloc(list1, (*newCount) * sizeof(char*));\n    for (int i = 0; i < count2; ++i) {\n        newList[count1 + i] = strdup(list2[i]);\n    }\n    return newList;\n}"}]},{"title":"Decorator","examples":[{"codeFile":"patterns/structural/decorator/example","code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/* Forward declarations */\ntypedef struct Notification Notification;\ntypedef struct NotificationVTable NotificationVTable;\n\n/* Component: Notification */\nstruct NotificationVTable {\n    char* (*send)(Notification*);\n};\n\nstruct Notification {\n    NotificationVTable* vtable;\n};\n\n/* Concrete Component: Base Notification */\nchar* BaseNotification_send(Notification* self) {\n    return \"Base notification: You have a new message!\";\n}\n\nNotificationVTable baseNotificationVTable = {\n    BaseNotification_send\n};\n\nNotification* newBaseNotification() {\n    Notification* notification = (Notification*)malloc(sizeof(Notification));\n    notification->vtable = &baseNotificationVTable;\n    return notification;\n}\n\n/* Decorator: Notification Decorator */\ntypedef struct {\n    Notification notification;\n    Notification* wrapped;\n} NotificationDecorator;\n\nchar* NotificationDecorator_send(Notification* self) {\n    NotificationDecorator* decorator = (NotificationDecorator*)self;\n    return decorator->wrapped->vtable->send(decorator->wrapped);\n}\n\n/* Concrete Decorator: Sound Notification */\nchar* SoundNotificationDecorator_send(Notification* self) {\n    NotificationDecorator* decorator = (NotificationDecorator*)self;\n    char* baseSend = decorator->wrapped->vtable->send(decorator->wrapped);\n    char* result = (char*)malloc(strlen(baseSend) + strlen(\" (Sound notification: Ding!)\") + 1);\n    strcpy(result, baseSend);\n    strcat(result, \" (Sound notification: Ding!)\");\n    return result;\n}\n\nNotificationVTable soundNotificationDecoratorVTable = {\n    SoundNotificationDecorator_send\n};\n\nNotification* newSoundNotificationDecorator(Notification* wrapped) {\n    NotificationDecorator* decorator = (NotificationDecorator*)malloc(sizeof(NotificationDecorator));\n    decorator->notification.vtable = &soundNotificationDecoratorVTable;\n    decorator->wrapped = wrapped;\n    return (Notification*)decorator;\n}\n\n/* Concrete Decorator: Priority Notification */\nchar* PriorityNotificationDecorator_send(Notification* self) {\n    NotificationDecorator* decorator = (NotificationDecorator*)self;\n    char* baseSend = decorator->wrapped->vtable->send(decorator->wrapped);\n    char* result = (char*)malloc(strlen(baseSend) + strlen(\" (Priority notification: High priority!)\") + 1);\n    strcpy(result, baseSend);\n    strcat(result, \" (Priority notification: High priority!)\");\n    return result;\n}\n\nNotificationVTable priorityNotificationDecoratorVTable = {\n    PriorityNotificationDecorator_send\n};\n\nNotification* newPriorityNotificationDecorator(Notification* wrapped) {\n    NotificationDecorator* decorator = (NotificationDecorator*)malloc(sizeof(NotificationDecorator));\n    decorator->notification.vtable = &priorityNotificationDecoratorVTable;\n    decorator->wrapped = wrapped;\n    return (Notification*)decorator;\n}\n\n/* Client code */\nint main() {\n    Notification* baseNotification = newBaseNotification();\n    printf(\"%s\\n\", baseNotification->vtable->send(baseNotification));\n\n    Notification* soundNotification = newSoundNotificationDecorator(baseNotification);\n    printf(\"%s\\n\", soundNotification->vtable->send(soundNotification));\n\n    Notification* priorityNotification = newPriorityNotificationDecorator(baseNotification);\n    printf(\"%s\\n\", priorityNotification->vtable->send(priorityNotification));\n    \n    Notification* soundAndPriorityNotification = newPriorityNotificationDecorator(newSoundNotificationDecorator(baseNotification));\n    printf(\"%s\\n\", soundAndPriorityNotification->vtable->send(soundAndPriorityNotification));\n    \n    return 0;\n}"}]},{"title":"Facade","examples":[{"codeFile":"patterns/structural/facade/example","code":"#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n\n// Helper function to format date as string\nchar* formatDate(const time_t date) {\n    static char buffer[11];\n    strftime(buffer, sizeof(buffer), \"%Y-%m-%d\", localtime(&date));\n    return buffer;\n}\n\n// Subsystem: Flight Booking\ntypedef struct {\n    char* (*bookFlight)(const char* origin, const char* destination);\n} FlightBookingSystem;\n\nchar* bookFlight(const char* origin, const char* destination) {\n    static char details[100];\n    snprintf(details, sizeof(details), \"Flight booked from %s to %s\", origin, destination);\n    return details;\n}\n\n// Subsystem: Hotel Booking\ntypedef struct {\n    char* (*bookHotel)(const char* location, const time_t checkInDate, const time_t checkOutDate);\n} HotelBookingSystem;\n\nchar* bookHotel(const char* location, const time_t checkInDate, const time_t checkOutDate) {\n    static char details[100];\n    snprintf(details, sizeof(details), \"Hotel booked at %s from %s to %s\", location, formatDate(checkInDate), formatDate(checkOutDate));\n    return details;\n}\n\n// Subsystem: Car Rental\ntypedef struct {\n    char* (*rentCar)(const char* location, const time_t startDate, const time_t endDate);\n} CarRentalSystem;\n\nchar* rentCar(const char* location, const time_t startDate, const time_t endDate) {\n    static char details[100];\n    snprintf(details, sizeof(details), \"Car rented at %s from %s to %s\", location, formatDate(startDate), formatDate(endDate));\n    return details;\n}\n\n// Facade: TravelFacade\ntypedef struct {\n    FlightBookingSystem flightBooking;\n    HotelBookingSystem hotelBooking;\n    CarRentalSystem carRental;\n} TravelFacade;\n\nTravelFacade createTravelFacade() {\n    TravelFacade facade = {\n        .flightBooking = { .bookFlight = bookFlight },\n        .hotelBooking = { .bookHotel = bookHotel },\n        .carRental = { .rentCar = rentCar }\n    };\n    return facade;\n}\n\nchar* bookTravel(TravelFacade* facade, const char* origin, const char* destination, const char* location, const time_t checkInDate, const time_t checkOutDate, const time_t startDate, const time_t endDate) {\n    static char details[300];\n    char* flightDetails = facade->flightBooking.bookFlight(origin, destination);\n    char* hotelDetails = facade->hotelBooking.bookHotel(location, checkInDate, checkOutDate);\n    char* carDetails = facade->carRental.rentCar(location, startDate, endDate);\n\n    snprintf(details, sizeof(details), \"%s\\n%s\\n%s\", flightDetails, hotelDetails, carDetails);\n    return details;\n}\n\nint main() {\n    // Setup travel dates\n    struct tm checkIn = { .tm_year = 2023 - 1900, .tm_mon = 12 - 1, .tm_mday = 15 };\n    struct tm checkOut = { .tm_year = 2023 - 1900, .tm_mon = 12 - 1, .tm_mday = 20 };\n    time_t checkInDate = mktime(&checkIn);\n    time_t checkOutDate = mktime(&checkOut);\n\n    // Initialize facade and book travel\n    TravelFacade travelFacade = createTravelFacade();\n    char* bookingDetails = bookTravel(&travelFacade, \"New York\", \"Los Angeles\", \"Hilton\", checkInDate, checkOutDate, checkInDate, checkOutDate);\n\n    // Print booking details\n    printf(\"%s\\n\", bookingDetails);\n\n    return 0;\n}\n\n/**\n * The FlightBookingSystem, HotelBookingSystem, and CarRentalSystem structs represent the\n * subsystems of flight booking, hotel booking, and car rental, respectively.\n *\n * The TravelFacade struct provides a simplified interface for booking a complete travel\n * package. It encapsulates the complexities of interacting with the subsystems.\n *\n * The client code interacts with the TravelFacade to book a complete travel package without\n * directly interacting with the subsystems.\n */"}]},{"title":"Flyweight","examples":[{"codeFile":"patterns/structural/flyweight/example","code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n// Forward declaration for Character struct to be used in CharacterFactory\ntypedef struct Character Character;\n\n// Character: Represents the Flyweight object.\nstruct Character {\n    char character;\n    // Display function to mimic the original class method, takes additional parameters for font and size\n    char* (*display)(struct Character* self, char* font, int size);\n};\n\n// Function to display the Character details\nchar* characterDisplay(Character* self, char* font, int size) {\n    char* result = (char*)malloc(100 * sizeof(char));\n    sprintf(result, \"Character: %c, Font: %s, Size: %d\", self->character, font, size);\n    return result;\n}\n\n// Creates a new Character instance with provided character\nCharacter* newCharacter(char character) {\n    Character* newChar = (Character*)malloc(sizeof(Character));\n    if (newChar != NULL) {\n        newChar->character = character;\n        newChar->display = characterDisplay;\n    }\n    return newChar;\n}\n\n// CharacterFactory: Acts as the Flyweight Factory, managing character instances.\nstruct CharacterFactory {\n    Character* characters[128]; // Assuming ASCII characters for simplicity\n};\n\n// Gets or creates a flyweight Character\nCharacter* getCharacter(struct CharacterFactory* factory, char character) {\n    if (factory->characters[(int)character] == NULL) {\n        factory->characters[(int)character] = newCharacter(character);\n    }\n    return factory->characters[(int)character];\n}\n\n// Initializes a CharacterFactory instance\nvoid initCharacterFactory(struct CharacterFactory* factory) {\n    for (int i = 0; i < 128; ++i) {\n        factory->characters[i] = NULL;\n    }\n}\n\n// Main function illustrating client code\nint main() {\n    struct CharacterFactory characterFactory;\n    initCharacterFactory(&characterFactory);\n\n    char* text = \"Lorem ipsum dolor sit amet, consectetur adipiscing elit.\";\n    char* renderedText[1000]; // Assuming a maximum of 1000 characters for rendering\n\n    int i = 0;\n    for (char* p = text; *p; ++p) {\n        Character* character = getCharacter(&characterFactory, *p);\n        renderedText[i++] = character->display(character, \"Arial\", 12); // Assume same font and size for simplicity\n    }\n\n    for (int j = 0; j < i; ++j) {\n        printf(\"%s\\n\", renderedText[j]);\n        free(renderedText[j]); // Free the allocated string after printing\n    }\n\n    // Clean up\n    for (int k = 0; k < 128; ++k) {\n        free(characterFactory.characters[k]);\n    }\n\n    return 0;\n}\n\n/**\n * In this C version of the Flyweight pattern example, the Character struct and related\n * functions represent the Flyweight object with intrinsic state (the character itself).\n * \n * The CharacterFactory struct acts as a Flyweight Factory, managing Character instances to ensure\n * shared use across different contexts.\n * \n * The main function simulates the client code that creates a text document and renders it by reusing\n * Flyweight Characters, thus optimizing memory use and performance.\n */"}]},{"title":"Proxy","examples":[{"codeFile":"patterns/structural/proxy/example","code":"#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/* IHttpServer: Struct representing the interface for common behavior of RealSubject and Proxy */\ntypedef struct IHttpServer {\n  char* (*request)(char* url);\n} IHttpServer;\n\n/* HttpServer: The actual HTTP server implementation */\nchar* HttpServer_request(char* url) {\n  // Simulating HTTP request to the actual server\n  char* response = (char *)malloc(1024 * sizeof(char));\n  snprintf(response, 1024, \"Response from server for URL: %s\", url);\n  return response;\n}\n\n/* ProxyServer: Proxy server that intercepts requests before forwarding them to the real server */\ntypedef struct {\n  IHttpServer* server; // Composition relationship\n} ProxyServer;\n\nchar* ProxyServer_request(ProxyServer* self, char* url) {\n  // Additional logic can be added here, e.g., caching, access control, logging\n  printf(\"Proxy: Intercepted request for URL: %s\\n\", url);\n\n  // Forward the request to the real server\n  char* response = self->server->request(url);\n\n  // Additional processing on the response can be done here\n\n  return response;\n}\n\n/* Function that initializes the ProxyServer struct including the IHttpServer behavior */\nvoid ProxyServer_init(ProxyServer* proxy, IHttpServer* server) {\n  proxy->server = server;\n}\n\nint main() {\n  /* Instantiate the IHttpServer behavior for HttpServer */\n  IHttpServer httpServer = {HttpServer_request};\n\n  /* Instantiate and initialize the ProxyServer */\n  ProxyServer proxy;\n  ProxyServer_init(&proxy, &httpServer);\n\n  /* Client code */\n  // Client sends a request to the proxy server\n  char* response = ProxyServer_request(&proxy, \"https://example.com\");\n  printf(\"%s\\n\", response);\n  free(response);\n\n  return 0;\n}\n\n/**\n * The IHttpServer struct defines the common behavior for both the HttpServer and the ProxyServer through function pointers.\n * The HttpServer represents the real HTTP server implementation. It implements the request function\n * to simulate sending HTTP requests to the actual server.\n * The ProxyServer struct acts as a proxy server. It intercepts requests before forwarding them to the real\n * server. The ProxyServer_request function performs additional tasks such as logging, caching, or access\n * control before delegating the request to the real server.\n * In the main function, we instantiate a ProxyServer struct and send a request to it. The proxy intercepts\n * the request, performs any necessary processing, and then forwards the request to the real server.\n * Finally, it returns the response to the client.\n */"}]}]},"principles":{"principles_solid":[{"title":"Single Responsibility Principle (SRP)","examples":[{"title":"Good Example","codeFile":"principles/solid/single-responsibility/good-example","code":"#include <stdio.h>\n\n// Employee structure responsible only for storing employee data\ntypedef struct {\n    char* name;\n    char* position;\n    int salary;\n} Employee;\n\n// Initialize an Employee instance\nEmployee create_employee(char* name, char* position, int salary) {\n    Employee emp;\n    emp.name = name;\n    emp.position = position;\n    emp.salary = salary;\n    return emp;\n}\n\n// Printer function responsible only for printing employee information\nvoid print_employee(Employee emp) {\n    printf(\"Name: %s\\n\", emp.name);\n    printf(\"Position: %s\\n\", emp.position);\n    printf(\"Salary: %d\\n\", emp.salary);\n}\n\n// Usage\nint main() {\n    Employee employee = create_employee(\"John Doe\", \"Software Engineer\", 50000);\n    print_employee(employee);\n\n    return 0;\n}"},{"title":"Bad Example","codeFile":"principles/solid/single-responsibility/bad-example","code":"#include <stdio.h>\n\n// Structure to hold employee information\ntypedef struct {\n    char* name;\n    char* position;\n    int salary;\n} Employee;\n\n// Function to print employee information\nvoid printEmployee(Employee emp) {\n    printf(\"Name: %s\\n\", emp.name);\n    printf(\"Position: %s\\n\", emp.position);\n    printf(\"Salary: %d\\n\", emp.salary);\n}\n\n// Usage example\nint main() {\n    Employee employee = {\"John Doe\", \"Software Engineer\", 50000};\n    printEmployee(employee);\n    return 0;\n}"}]},{"title":"Open/Closed Principle (OCP)","examples":[{"title":"Good Example","codeFile":"principles/solid/open-closed/good-example","code":"#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n// Abstract base \"class\" using structure for shape definitions\ntypedef struct Shape {\n    // Function pointer for computeArea\n    double (*computeArea)(struct Shape *self);\n} Shape;\n\n// Function to simulate abstract behavior for base computeArea\ndouble Shape_computeArea(Shape *self) {\n    printf(\"Must be implemented in subclasses\\n\");\n    exit(1);\n}\n\n// Rectangle \"class\"\ntypedef struct {\n    Shape base; // Inheritance simulated through composition\n    double width;\n    double height;\n} Rectangle;\n\n// Implementation of computeArea for Rectangle\ndouble Rectangle_computeArea(Shape *shape) {\n    Rectangle *self = (Rectangle *) shape;\n    return self->width * self->height;\n}\n\n// Constructor-like function for Rectangle\nRectangle *Rectangle_new(double width, double height) {\n    Rectangle *rect = (Rectangle *)malloc(sizeof(Rectangle));\n    rect->base.computeArea = Rectangle_computeArea;\n    rect->width = width;\n    rect->height = height;\n    return rect;\n}\n\n// Circle \"class\"\ntypedef struct {\n    Shape base; // Inheritance simulated through composition\n    double radius;\n} Circle;\n\n// Implementation of computeArea for Circle\ndouble Circle_computeArea(Shape *shape) {\n    Circle *self = (Circle *) shape;\n    return M_PI * pow(self->radius, 2);\n}\n\n// Constructor-like function for Circle\nCircle *Circle_new(double radius) {\n    Circle *circle = (Circle *)malloc(sizeof(Circle));\n    circle->base.computeArea = Circle_computeArea;\n    circle->radius = radius;\n    return circle;\n}\n\n// Utility functions to demonstrate polymorphic behavior\ndouble computeShapeArea(Shape *shape) {\n    return shape->computeArea(shape);\n}\n\nint main() {\n    // Demonstrating the use of Rectangle and Circle structs\n    Rectangle *rect = Rectangle_new(10, 20);\n    Circle *circle = Circle_new(5);\n\n    printf(\"The area of the Rectangle is: %f\\n\", computeShapeArea((Shape *)rect));\n    printf(\"The area of the Circle is: %f\\n\", computeShapeArea((Shape *)circle));\n\n    // Cleanup\n    free(rect);\n    free(circle);\n\n    return 0;\n}"},{"title":"Bad Example","codeFile":"principles/solid/open-closed/bad-example","code":"#include <stdio.h>\n#include <math.h>\n\n// Define a basic Shape interface that all shapes will implement\ntypedef struct {\n    double (*computeArea)(void*);\n} ShapeInterface;\n\n// Rectangle shape structure and its area computation function\ntypedef struct {\n    ShapeInterface *shapeInterface;\n    double width;\n    double height;\n} Rectangle;\n\ndouble computeAreaRectangle(void* data) {\n    Rectangle* rectangle = (Rectangle*)data;\n    return rectangle->width * rectangle->height;\n}\n\n// Circle shape structure and its area computation function\ntypedef struct {\n    ShapeInterface *shapeInterface;\n    double radius;\n} Circle;\n\ndouble computeAreaCircle(void* data) {\n    Circle* circle = (Circle*)data;\n    return M_PI * circle->radius * circle->radius;\n}\n\n// Function to initialize a Rectangle\nvoid initRectangle(Rectangle* rectangle, double width, double height) {\n    rectangle->width = width;\n    rectangle->height = height;\n    static ShapeInterface rectangleInterface = {computeAreaRectangle};\n    rectangle->shapeInterface = &rectangleInterface;\n}\n\n// Function to initialize a Circle\nvoid initCircle(Circle* circle, double radius) {\n    circle->radius = radius;\n    static ShapeInterface circleInterface = {computeAreaCircle};\n    circle->shapeInterface = &circleInterface;\n}\n\n// AreaCalculator's key function, now utilizes polymorphism for shape area computation\ndouble computeArea(ShapeInterface* shape) {\n    return shape->computeArea(shape);\n}\n\nint main() {\n    Rectangle myRectangle;\n    initRectangle(&myRectangle, 10.0, 5.0);\n\n    Circle myCircle;\n    initCircle(&myCircle, 7.0);\n\n    printf(\"Rectangle area: %f\\n\", computeArea(myRectangle.shapeInterface, &myRectangle));\n    printf(\"Circle area: %f\\n\", computeArea(myCircle.shapeInterface, &myCircle));\n\n    return 0;\n}"}]},{"title":"Liskov Substitution Principle (LSP)","examples":[{"title":"Good Example","codeFile":"principles/solid/liskov-substitution/good-example","code":"#include <stdio.h>\n\n// Base struct for Bird\ntypedef struct {\n    void (*fly)();\n} Bird;\n\n// Function to simulate bird flying\nvoid BirdFly() {\n    printf(\"Bird is flying\\n\");\n}\n\n// Duck struct inheriting from Bird\ntypedef struct {\n    Bird baseBird;\n    void (*quack)();\n} Duck;\n\n// Function to simulate duck quacking\nvoid DuckQuack() {\n    printf(\"Duck is quacking\\n\");\n}\n\n// Penguin struct inheriting from Bird\ntypedef struct {\n    Bird baseBird;\n    void (*swim)();\n} Goose;\n\n// Function to simulate goose swimming\nvoid GooseSwim() {\n    printf(\"Goose is swimming\\n\");\n}\n\n// Function to make any bird fly\nvoid makeBirdFly(Bird *bird) {\n    bird->fly();\n}\n\nint main() {\n    // Initialize duck with base class methods\n    Duck duck;\n    duck.baseBird.fly = BirdFly;\n    duck.quack = DuckQuack;\n\n    // Initialize goose with base class methods\n    Goose goose;\n    goose.baseBird.fly = BirdFly;\n    goose.swim = GooseSwim;\n\n    // Making duck and goose fly\n    makeBirdFly((Bird*)&duck);    // Output: Bird is flying\n    makeBirdFly((Bird*)&goose);   // Output: Bird is flying\n\n    return 0;\n}"},{"title":"Bad Example","codeFile":"principles/solid/liskov-substitution/bad-example","code":"#include <stdio.h>\n\n/* Defining a struct for Bird with a function pointer fly as part of its structure. */\ntypedef struct {\n    void (*fly)(void);\n} Bird;\n\n/* Bird's fly function, which would normally enable a bird to fly. */\nvoid birdFly() {\n    /* ... Flying logic for general birds */\n    printf(\"This bird flies.\\n\");\n}\n\n/* Ostrich does not actually fly, so we create a different function for it. */\nvoid ostrichFly() {\n    /* Throwing error is not a C idiom, so we'll handle it differently. */\n    printf(\"Can't fly. This is an ostrich.\\n\");\n}\n\nint main() {\n    /* Instantiate a Bird and an Ostrich (technically still a Bird struct but with different behavior). */\n    Bird aBird;\n    Bird anOstrich;\n\n    aBird.fly = birdFly; /* setting function pointer for a general bird */\n    anOstrich.fly = ostrichFly; /* setting function pointer to illustrate ostrich's inability to fly */\n    \n    /* Demonstrating behavior */\n    aBird.fly(); /* Expected to fly */\n    anOstrich.fly(); /* Expected to not fly and instead print a message. */\n    \n    return 0;\n}"}]},{"title":"Interface Segregation Principle (ISP)","examples":[{"title":"Good Example","codeFile":"principles/solid/interface-segregation/good-example","code":"#include <stdio.h>\n\n/* Define Printer actions */\ntypedef struct PrinterActions {\n    void (*printDocument)(void);\n} PrinterActions;\n\n/* Define Fax actions */\ntypedef struct FaxActions {\n    void (*faxDocument)(void);\n} FaxActions;\n\n/* Define Scanner actions */\ntypedef struct ScannerActions {\n    void (*scanDocument)(void);\n} ScannerActions;\n\n/* SimplePrinter functions */\nvoid SimplePrinter_printDocument() {\n    printf(\"Printing document...\\n\");\n}\n\n/* MultifunctionalPrinter functions */\nvoid MultifunctionalPrinter_printDocument() {\n    printf(\"Printing document...\\n\");\n}\n\nvoid MultifunctionalPrinter_faxDocument() {\n    printf(\"Faxing document...\\n\");\n}\n\nvoid MultifunctionalPrinter_scanDocument() {\n    printf(\"Scanning document...\\n\");\n}\n\n/* Structs representing the devices */\ntypedef struct {\n    PrinterActions actions;\n} SimplePrinter;\n\ntypedef struct {\n    PrinterActions printerActions;\n    FaxActions faxActions;\n    ScannerActions scannerActions;\n} MultifunctionalPrinter;\n\n/* Function to initialize a SimplePrinter */\nvoid SimplePrinter_init(SimplePrinter *printer) {\n    printer->actions.printDocument = SimplePrinter_printDocument;\n}\n\n/* Function to initialize a MultifunctionalPrinter */\nvoid MultifunctionalPrinter_init(MultifunctionalPrinter *printer) {\n    printer->printerActions.printDocument = MultifunctionalPrinter_printDocument;\n    printer->faxActions.faxDocument = MultifunctionalPrinter_faxDocument;\n    printer->scannerActions.scanDocument = MultifunctionalPrinter_scanDocument;\n}\n\nint main() {\n    SimplePrinter mySimplePrinter;\n    SimplePrinter_init(&mySimplePrinter);\n    mySimplePrinter.actions.printDocument();\n\n    MultifunctionalPrinter myMultifunctionalPrinter;\n    MultifunctionalPrinter_init(&myMultifunctionalPrinter);\n    myMultifunctionalPrinter.printerActions.printDocument();\n    myMultifunctionalPrinter.faxActions.faxDocument();\n    myMultifunctionalPrinter.scannerActions.scanDocument();\n\n    return 0;\n}"},{"title":"Bad Example","codeFile":"principles/solid/interface-segregation/bad-example","code":"#include <stdio.h>\n#include <stdlib.h>\n\n// The machine interface with all functions, but in C, we will use function pointers.\ntypedef struct Machine {\n  void (*printDocument)(void);\n  void (*faxDocument)(void);\n  void (*scanDocument)(void);\n} Machine;\n\n// Functions for the OldPrinter\nvoid printDocument_OldPrinter() {\n  printf(\"Printing document...\\n\");\n}\n\n// Instead of throwing errors for unsupported operations, we'll print error messages. \n// This is a common pattern in C for handling unsupported operations.\nvoid faxDocument_OldPrinter() {\n  printf(\"This printer cannot fax documents.\\n\");\n}\n\nvoid scanDocument_OldPrinter() {\n  printf(\"This printer cannot scan documents.\\n\");\n}\n\n// Function to initialize an OldPrinter\nvoid initOldPrinter(Machine *printer) {\n  printer->printDocument = printDocument_OldPrinter;\n  printer->faxDocument = faxDocument_OldPrinter;\n  printer->scanDocument = scanDocument_OldPrinter;\n}\n\nint main() {\n  // Create an OldPrinter\n  Machine oldPrinter;\n  initOldPrinter(&oldPrinter);\n\n  // Use the OldPrinter\n  oldPrinter.printDocument();\n  oldPrinter.faxDocument();\n  oldPrinter.scanDocument();\n\n  return 0;\n}"}]},{"title":"Dependency Inversion Principle (DIP)","examples":[{"title":"Good Example","codeFile":"principles/solid/interface-segregation/good-example","code":"#include <stdio.h>\n\n/* Define Printer actions */\ntypedef struct PrinterActions {\n    void (*printDocument)(void);\n} PrinterActions;\n\n/* Define Fax actions */\ntypedef struct FaxActions {\n    void (*faxDocument)(void);\n} FaxActions;\n\n/* Define Scanner actions */\ntypedef struct ScannerActions {\n    void (*scanDocument)(void);\n} ScannerActions;\n\n/* SimplePrinter functions */\nvoid SimplePrinter_printDocument() {\n    printf(\"Printing document...\\n\");\n}\n\n/* MultifunctionalPrinter functions */\nvoid MultifunctionalPrinter_printDocument() {\n    printf(\"Printing document...\\n\");\n}\n\nvoid MultifunctionalPrinter_faxDocument() {\n    printf(\"Faxing document...\\n\");\n}\n\nvoid MultifunctionalPrinter_scanDocument() {\n    printf(\"Scanning document...\\n\");\n}\n\n/* Structs representing the devices */\ntypedef struct {\n    PrinterActions actions;\n} SimplePrinter;\n\ntypedef struct {\n    PrinterActions printerActions;\n    FaxActions faxActions;\n    ScannerActions scannerActions;\n} MultifunctionalPrinter;\n\n/* Function to initialize a SimplePrinter */\nvoid SimplePrinter_init(SimplePrinter *printer) {\n    printer->actions.printDocument = SimplePrinter_printDocument;\n}\n\n/* Function to initialize a MultifunctionalPrinter */\nvoid MultifunctionalPrinter_init(MultifunctionalPrinter *printer) {\n    printer->printerActions.printDocument = MultifunctionalPrinter_printDocument;\n    printer->faxActions.faxDocument = MultifunctionalPrinter_faxDocument;\n    printer->scannerActions.scanDocument = MultifunctionalPrinter_scanDocument;\n}\n\nint main() {\n    SimplePrinter mySimplePrinter;\n    SimplePrinter_init(&mySimplePrinter);\n    mySimplePrinter.actions.printDocument();\n\n    MultifunctionalPrinter myMultifunctionalPrinter;\n    MultifunctionalPrinter_init(&myMultifunctionalPrinter);\n    myMultifunctionalPrinter.printerActions.printDocument();\n    myMultifunctionalPrinter.faxActions.faxDocument();\n    myMultifunctionalPrinter.scannerActions.scanDocument();\n\n    return 0;\n}"},{"title":"Bad Example","codeFile":"principles/solid/interface-segregation/bad-example","code":"#include <stdio.h>\n#include <stdlib.h>\n\n// The machine interface with all functions, but in C, we will use function pointers.\ntypedef struct Machine {\n  void (*printDocument)(void);\n  void (*faxDocument)(void);\n  void (*scanDocument)(void);\n} Machine;\n\n// Functions for the OldPrinter\nvoid printDocument_OldPrinter() {\n  printf(\"Printing document...\\n\");\n}\n\n// Instead of throwing errors for unsupported operations, we'll print error messages. \n// This is a common pattern in C for handling unsupported operations.\nvoid faxDocument_OldPrinter() {\n  printf(\"This printer cannot fax documents.\\n\");\n}\n\nvoid scanDocument_OldPrinter() {\n  printf(\"This printer cannot scan documents.\\n\");\n}\n\n// Function to initialize an OldPrinter\nvoid initOldPrinter(Machine *printer) {\n  printer->printDocument = printDocument_OldPrinter;\n  printer->faxDocument = faxDocument_OldPrinter;\n  printer->scanDocument = scanDocument_OldPrinter;\n}\n\nint main() {\n  // Create an OldPrinter\n  Machine oldPrinter;\n  initOldPrinter(&oldPrinter);\n\n  // Use the OldPrinter\n  oldPrinter.printDocument();\n  oldPrinter.faxDocument();\n  oldPrinter.scanDocument();\n\n  return 0;\n}"}]}],"principles_other":[{"title":"Don't Repeat Yourself (DRY)","examples":[{"title":"Good Example","codeFile":"principles/other/dry/good-example","code":"#include <stdio.h>\n\n// Function declaration with default parameter for rate using function overloading\nfloat addTax(float price, float rate);\nfloat addTaxDefault(float price);\n\n// Function definitions\nfloat addTax(float price, float rate) {\n    // Adding tax to the price\n    return price + (price * rate);\n}\n\nfloat addTaxDefault(float price) {\n    // Calling addTax with the default tax rate\n    return addTax(price, 0.05);\n}\n\nint main() {\n    float basePrice = 100.0;\n\n    // Example usage\n    printf(\"Price including tax with specified rate: %.2f\\n\", addTax(basePrice, 0.10));\n    printf(\"Price including tax with default rate: %.2f\\n\", addTaxDefault(basePrice));\n\n    return 0;\n}"},{"title":"Bad Example","codeFile":"principles/other/dry/bad-example","code":"#include <stdio.h>\n\n// A better approach: a single function to add tax for any item\nfloat addTax(float price, float taxRate) {\n    return price + (price * taxRate);\n}\n\n// Example usage\nint main() {\n    float foodPrice = 100.0;\n    float electronicsPrice = 200.0;\n    float taxRate = 0.05; // 5% tax rate for simplicity\n\n    float foodPriceWithTax = addTax(foodPrice, taxRate);\n    float electronicsPriceWithTax = addTax(electronicsPrice, taxRate);\n\n    printf(\"Food price with tax: %.2f\\n\", foodPriceWithTax);\n    printf(\"Electronics price with tax: %.2f\\n\", electronicsPriceWithTax);\n\n    return 0;\n}"}]},{"title":"Keep It Simple Stupid (KISS)","examples":[{"title":"Good Example","codeFile":"principles/other/kiss/good-example","code":"#include <stdbool.h>\n#include <stdio.h>\n\n// Function to check if a number is even\nbool isEven(int num) {\n    return num % 2 == 0;\n}\n\nint main() {\n    int number = 4;\n    if (isEven(number)) {\n        printf(\"%d is even\\n\", number);\n    } else {\n        printf(\"%d is odd\\n\", number);\n    }\n    return 0;\n}"},{"title":"Bad Example","codeFile":"principles/other/kiss/bad-example","code":"#include <stdbool.h>\n\n// there is no need for absolute value here\nbool isEven(int num) {\n    return num % 2 == 0;\n}"}]},{"title":"You Aren't Gonna Need It (YAGNI)","examples":[{"codeFile":"principles/other/yagni/bad-example","code":"#include <stdio.h>\n#include <stdlib.h>\n\n// Function declarations\nint add(int a, int b);\nvoid errorDivisionByZero();\n\nint main() {\n    // Example usage\n    int sum = add(3, 4);\n    printf(\"Sum: %d\\n\", sum);\n    return 0;\n}\n\n// Add function (used in this example)\nint add(int a, int b) {\n    return a + b;\n}\n\n// Error handling for division by zero\nvoid errorDivisionByZero() {\n    printf(\"Division by zero is not allowed.\\n\");\n    exit(1);\n}\n\n// Do not define functions unless they are used\n\n// Removed multiply, divide, and subtract functions to adhere to YAGNI principle."}]},{"title":"Law of Demeter (Principle of Least Knowledge)","examples":[{"title":"Good Example","codeFile":"principles/other/demeter/good-example","code":"#include <stdio.h>\n#include <stdlib.h>\n\n// Wallet class equivalent in C\ntypedef struct {\n    int money;\n} Wallet;\n\n// Constructor equivalent for Wallet\nWallet* new_Wallet() {\n    Wallet* w = (Wallet*)malloc(sizeof(Wallet));\n    if (w == NULL) {\n        return NULL; // Handle malloc failure\n    }\n    w->money = 100;\n    return w;\n}\n\n// Method to get amount of money in Wallet\nint Wallet_getAmount(Wallet* w) {\n    return w->money;\n}\n\n// Person class equivalent in C\ntypedef struct {\n    Wallet* wallet;\n} Person;\n\n// Constructor equivalent for Person\nPerson* new_Person() {\n    Person* p = (Person*)malloc(sizeof(Person));\n    if (p == NULL) {\n        return NULL; // Handle malloc failure\n    }\n    p->wallet = new_Wallet();\n    if (p->wallet == NULL) {\n        free(p); // Cleanup if Wallet allocation fails\n        return NULL;\n    }\n    return p;\n}\n\n// Method to get the amount of money a Person has\nint Person_getMoneyAmount(Person* p) {\n    return Wallet_getAmount(p->wallet);\n}\n\n// Represents a purchase operation\nvoid purchase(int price, Person* buyer) {\n    if (Person_getMoneyAmount(buyer) >= price) {\n        // ... (Purchase logic)\n    }\n}\n\n// Remember to free allocated memory after use\n// This is crucial in C to prevent memory leaks\nvoid freePerson(Person* p) {\n    if (p) {\n        free(p->wallet); // Free associated Wallet\n        free(p); // Then free Person\n    }\n}\n\nint main() {\n    // Example of creating a person and attempting a purchase\n    Person* person = new_Person();\n    if (person == NULL) {\n        perror(\"Failed to allocate Person\");\n        return 1;\n    }\n\n    purchase(50, person);\n\n    freePerson(person); // Cleanup\n\n    return 0;\n}"},{"title":"Bad Example","codeFile":"principles/other/demeter/bad-example","code":"#include <stdio.h>\n\ntypedef struct {\n    int amount;\n} Money;\n\ntypedef struct {\n    Money money;\n} Wallet;\n\ntypedef struct {\n    Wallet wallet;\n} Person;\n\nvoid initWallet(Wallet *wallet) {\n    wallet->money.amount = 100;\n}\n\nvoid initPerson(Person *person) {\n    initWallet(&person->wallet);\n}\n\nvoid purchase(int itemPrice, Person *buyer) {\n    // This directly accesses the fields of another object,\n    // which is a violation of the Law of Demeter.\n    if (buyer->wallet.money.amount >= itemPrice) {\n        // Perform purchase...\n    }\n}"}]},{"title":"Separation of Concerns","examples":[{"title":"Good Example","codeFile":"principles/other/separation/good-example","code":"#include <stdbool.h>\n#include <stdio.h>\n\n// Authentication service\ntypedef struct {\n    // Future fields related to the authentication service could go here\n} AuthenticationService;\n\n// Initializes an AuthenticationService instance\nvoid AuthenticationService_init(AuthenticationService* self) {\n    // Initialization logic here\n}\n\n// AuthenticationService: Login\nbool AuthenticationService_login(AuthenticationService* self, const char* username, const char* password) {\n    // Authentication logic here\n    return true; // Dummy implementation\n}\n\n// AuthenticationService: Logout\nvoid AuthenticationService_logout(AuthenticationService* self) {\n    // Logout logic here\n}\n\n// Data service\ntypedef struct {\n    // Future fields related to the data service could go here\n} DataService;\n\n// Initializes a DataService instance\nvoid DataService_init(DataService* self) {\n    // Initialization logic here\n}\n\n// DataService: Fetch Data\n// Returns static array as a simple representation of fetching data\nint* DataService_fetchData(DataService* self, int* length) {\n    static int data[1] = {0}; // Dummy implementation\n    *length = 1;\n    return data;\n}\n\n// User controller\ntypedef struct {\n    AuthenticationService* authService;\n} UserController;\n\n// Initializes a UserController instance\nvoid UserController_init(UserController* self, AuthenticationService* authService) {\n    self->authService = authService;\n}\n\n// UserController: Login User\nbool UserController_loginUser(UserController* self, const char* username, const char* password) {\n    return AuthenticationService_login(self->authService, username, password);\n}\n\n// UserController: Logout User\nvoid UserController_logoutUser(UserController* self) {\n    AuthenticationService_logout(self->authService);\n}\n\n// Data controller\ntypedef struct {\n    DataService* dataService;\n} DataController;\n\n// Initializes a DataController instance\nvoid DataController_init(DataController* self, DataService* dataService) {\n    self->dataService = dataService;\n}\n\n// DataController: Get Data\nvoid DataController_getData(DataController* self) {\n    int length;\n    int* data = DataService_fetchData(self->dataService, &length);\n    // Dummy print to represent data usage\n    printf(\"Data[0]: %d\\n\", data[0]);\n}\n\n// Main function demonstrating usage\nint main() {\n    AuthenticationService authService;\n    DataService dataService;\n    UserController userController;\n    DataController dataController;\n\n    AuthenticationService_init(&authService);\n    DataService_init(&dataService);\n    UserController_init(&userController, &authService);\n    DataController_init(&dataController, &dataService);\n\n    // Simulate user login/logout\n    UserController_loginUser(&userController, \"username\", \"password\");\n    UserController_logoutUser(&userController);\n\n    // Retrieve data\n    DataController_getData(&dataController);\n\n    return 0;\n}"},{"title":"Bad Example","codeFile":"principles/other/separation/bad-example","code":"#include <stdio.h>\n#include <stdbool.h>\n\n// Authentication service function declarations\nbool login(const char *username, const char *password) {\n    // Authentication logic here\n    return true; // Dummy implementation\n}\n\nvoid logout() {\n    // Logout logic here\n}\n\n// Data service function declaration\nvoid fetchData() {\n    // Data retrieval logic here\n    // Dummy implementation with placeholder for actual data\n    printf(\"[]\\n\");\n}\n\n// Functions for combined operations\nbool loginUser(const char *username, const char *password) {\n    // Authentication logic here\n    bool isAuthenticated = login(username, password);\n    if (isAuthenticated) {\n        // Retrieve user data (previously mixing concerns, now separated)\n        fetchData();\n    }\n    return isAuthenticated;\n}\n\nvoid logoutUser() {\n    // Logout logic here\n    logout();\n}\n\nint main() {\n    // Simulate user login/logout\n    loginUser(\"username\", \"password\");\n    logoutUser();\n\n    return 0;\n}"}]}]}}