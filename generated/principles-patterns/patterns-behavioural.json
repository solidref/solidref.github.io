{"title":"<i>Behavioural</i> Design Patterns <br /> in Software Development","before":[{"variant":"body1","content":"The Chain of Responsibility pattern is a fundamental behavioral design pattern that allows an object\nto pass the request along a chain of handlers. Upon receiving a request, each handler decides either\nto process the request or to pass it to the next handler in the chain. This pattern is particularly\nuseful for implementing a system where multiple objects may handle a request without any of them\nnecessarily being the receiver for the request.\n"}],"accordion":{"Visitor":[{"variant":"body1","content":"The Visitor design pattern is a behavioral design pattern that allows for new operations to be added to \nobjects without modifying their classes. By introducing a visitor class that implements operations to be \nperformed on various elements of an object structure, this pattern separates an algorithm from the object \nstructure it operates on. This facilitates adding new operations to existing object structures without \naltering their implementations, making it particularly useful in situations where an object structure \nincludes many classes with differing interfaces, and you need to perform operations across these objects \nthat depend on their concrete classes.\n"},{"variant":"subtitle1","content":"Concept\n"},{"variant":"body1","content":"The Visitor pattern is about encapsulating operations in a separate object known as a 'visitor', which is \nthen passed to elements of an object structure. These elements then accept this visitor, which, in turn, \nperforms the operation on them. This approach allows for the addition of new operations without changing \nthe classes of the elements on which it operates.\n"},{"variant":"subtitle1","content":"Structure\n"},{"variant":"body1","content":"<ul>\n  <li>Visitor: Interface or abstract class declaring a visit operation for each class of ConcreteElement \n    in the object structure. The operation's name and signature identify the class that sends the visit \n    request to the visitor.</li>\n  <li>ConcreteVisitor: Each implements operations defined by the Visitor. Each operation implements a \n    fragment of the algorithm defined for the corresponding class of object in the structure.</li>\n  <li>Element: Defines an accept method that takes a visitor as an argument.</li>\n  <li>ConcreteElement: Implements an accept method that typically calls the visit method on the visitor, \n    with this as its argument.</li>\n  <li>ObjectStructure: A collection of Elements able to enumerate its elements and provide a high-level \n    interface to allow the visitor to visit its elements.</li>\n</ul>\n"},{"variant":"subtitle1","content":"Example\n"},{"variant":"body1","content":"Consider a computer hardware system where we want to perform operations (like updateDriver or \ndiagnoseHardware) on various components without altering their classes.\n"},{"variant":"body1","content":"class ComputerPartVisitor {\n  visitComputer(part) {}\n  visitMouse(part) {}\n  visitKeyboard(part) {}\n  visitMonitor(part) {}\n}\n\nclass ComputerPart {\n  accept(computerPartVisitor) {}\n}\n\nclass Computer extends ComputerPart {\n  constructor() {\n    super();\n    this.parts = [new Mouse(), new Keyboard(), new Monitor()];\n  }\n\n  accept(computerPartVisitor) {\n    this.parts.forEach(part => part.accept(computerPartVisitor));\n    computerPartVisitor.visitComputer(this);\n  }\n}\n\nclass Mouse extends ComputerPart {\n  accept(computerPartVisitor) {\n    computerPartVisitor.visitMouse(this);\n  }\n}\n\nclass Keyboard extends ComputerPart {\n  accept(computerPartVisitor) {\n    computerPartVisitor.visitKeyboard(this);\n  }\n}\n\nclass Monitor extends ComputerPart {\n  accept(computerPartVisitor) {\n    computerPartVisitor.visitMonitor(this);\n  }\n}\n\nclass ComputerPartUpdateVisitor extends ComputerPartVisitor {\n  visitComputer(part) {\n    console.log('Updating computer...');\n  }\n\n  visitMouse(part) {\n    console.log('Updating mouse driver...');\n  }\n\n  visitKeyboard(part) {\n    console.log('Updating keyboard driver...');\n  }\n\n  visitMonitor(part) {\n    console.log('Updating monitor firmware...');\n  }\n}\n\n// Usage\nconst computer = new Computer();\nconst updateVisitor = new ComputerPartUpdateVisitor();\ncomputer.accept(updateVisitor);\n"},{"variant":"body1","content":"In this example, ComputerPart and its subclasses (Mouse, Keyboard, Monitor) represent the Element hierarchy. \nComputerPartVisitor is the Visitor interface with a visit operation for each ConcreteElement. \nComputerPartUpdateVisitor is a ConcreteVisitor implementing specific operations to be performed on each \ncomputer part.\n"},{"variant":"body1","content":"The Visitor pattern decouples the operations from the object structure, making it easier to add new \noperations without changing the structures on which they operate. This approach promotes flexibility and reuse \nof the operation implementation.\n"}],"Template Method":[{"variant":"body1","content":"The Template Method design pattern is a behavioral design pattern that defines the skeleton of an algorithm \nin the superclass but lets subclasses override specific steps of the algorithm without changing its structure. \nThis pattern is particularly useful when there is a multi-step process that requires flexibility in some of \nits steps, allowing customization by clients without altering the core algorithm's architecture.\n"},{"variant":"subtitle1","content":"Concept\n"},{"variant":"body1","content":"The core idea behind the Template Method pattern is to encapsulate the invariant parts of an algorithm within \na base class \"template method\" and defer the variable parts to subclasses. This approach enables the reuse of \nthe algorithm structure while providing a mechanism to extend the behavior of individual steps in the process. \nIt promotes code reuse and offers a straightforward way to customize and extend standard behaviors.\n"},{"variant":"subtitle1","content":"Structure\n"},{"variant":"body1","content":"<ul>\n  <li>AbstractClass: Defines abstract primitive operations that concrete subclasses should implement and a \n    template method that outlines the algorithm's skeleton, calling the primitive operations as needed.</li>\n  <li>ConcreteClass: Implements the primitive operations to carry out subclass-specific steps of the \n    algorithm.</li>\n</ul>\n"},{"variant":"subtitle1","content":"Example\n"},{"variant":"body1","content":"Imagine a software framework for building different types of reports, where each report has common steps \n(like collecting data and rendering a report) but may vary in the way data is processed and presented.\n"},{"variant":"code","content":"class ReportGenerator {\n  // This is the template method.\n  generateReport() {\n    this.collectData();\n    this.processData();\n    this.renderReport();\n  }\n\n  collectData() {\n    console.log('Collecting data...');\n  }\n\n  // This method should be overridden.\n  processData() {\n    throw new Error('ProcessData should be implemented by subclasses');\n  }\n\n  renderReport() {\n    console.log('Rendering report...');\n  }\n}\n\nclass SalesReportGenerator extends ReportGenerator {\n  processData() {\n    console.log('Processing sales data...');\n  }\n}\n\nclass InventoryReportGenerator extends ReportGenerator {\n  processData() {\n    console.log('Processing inventory data...');\n  }\n}\n\n// Usage\nconst salesReport = new SalesReportGenerator();\nsalesReport.generateReport(); // Collecting data... Processing sales data... Rendering report...\n\nconst inventoryReport = new InventoryReportGenerator();\ninventoryReport.generateReport(); // Collecting data... Processing inventory data... Rendering report...\n"},{"variant":"body1","content":"In this example, ReportGenerator serves as the AbstractClass, providing a template method generateReport() \nthat defines the algorithm's structure. The processData() method is the step that varies and is therefore \nleft for subclasses (SalesReportGenerator and InventoryReportGenerator) to implement, providing their \nspecific processing logic.\n"},{"variant":"body1","content":"The Template Method pattern encapsulates what is common and standardizes the algorithm's framework while \noffering the flexibility to vary parts of the algorithm as required by different contexts. This design \npattern simplifies the development of extensions and modifications, ensuring that the overarching logic \nremains consistent and correct.\n"}],"Memento":[{"variant":"body1","content":"The Memento design pattern is a behavioral pattern that provides the ability to restore an object to its \nprevious state (undo via rollback) without revealing details about its implementation. This pattern is \nparticularly useful in applications where the ability to revert to a previous state is a key feature, such \nas in text editors for undoing changes or in game software for saving and loading game progress.\n"},{"variant":"subtitle1","content":"Concept\n"},{"variant":"body1","content":"The essence of the Memento pattern is to capture and externalize an object's internal state so that the \nobject can be returned to this state later. It thus encapsulates the complexities of the internal state \nwithin a memento object, preventing the object's encapsulation from being compromised. This approach allows \nfor the preservation and restoration of object states without violating the tenets of encapsulation.\n"},{"variant":"subtitle1","content":"Structure\n"},{"variant":"body1","content":"<ul>\n  <li>Originator: The object whose state needs to be saved and restored.</li>\n  <li>Memento: A lightweight representation of the originator's state. It stores the necessary state of \n    the originator, as defined by the originator, to be able to restore to its state.</li>\n  <li>Caretaker: Manages and protects the memento without examining its contents or its encapsulated \n    state.</li>\n</ul>\n"},{"variant":"subtitle1","content":"Example\n"},{"variant":"body1","content":"Imagine a simple text editor application that allows users to type text and undo their actions if necessary. \nHereâ€™s how the Memento pattern can be applied:\n"},{"variant":"body1","content":"class TextEditor {\n  constructor(content = '') {\n    this.content = content;\n  }\n\n  type(words) {\n    this.content += ' ' + words;\n  }\n\n  save() {\n    return new Memento(this.content);\n  }\n\n  restore(memento) {\n    this.content = memento.getContent();\n  }\n}\n\nclass Memento {\n  constructor(content) {\n    this.content = content;\n  }\n\n  getContent() {\n    return this.content;\n  }\n}\n\nclass Caretaker {\n  constructor() {\n    this.mementos = [];\n  }\n\n  addMemento(memento) {\n    this.mementos.push(memento);\n  }\n\n  getMemento(index) {\n    return this.mementos[index];\n  }\n}\n\n// Usage\nconst editor = new TextEditor();\nconst caretaker = new Caretaker();\n\neditor.type('This is the first sentence.');\neditor.type('This is the second.');\n\n// Save state\ncaretaker.addMemento(editor.save());\n\n// Type more and undo to saved state\neditor.type('And this is going to be removed.');\nconsole.log(editor.content); // Output before undo\n\neditor.restore(caretaker.getMemento(0));\nconsole.log(editor.content); // Output after undo\n"},{"variant":"body1","content":"In this example, TextEditor acts as the Originator, capable of creating mementos of its current state and \nrestoring its state from a memento. Memento encapsulates the state of a TextEditor instance. Caretaker, \nmeanwhile, keeps a list of mementos, allowing users to revert the TextEditor to a previous state.\n"},{"variant":"body1","content":"The Memento pattern allows for the efficient tracking and reversal of changes to an object's state, \nfacilitating features like undo mechanisms in a way that respects the encapsulation of the object's internal \nstructure. This pattern is invaluable in scenarios where it's crucial to be able to revert to prior states \nwithout maintaining a cumbersome history of changes directly within the objects of interest.\n"}],"Mediator":[{"variant":"body1","content":"The Mediator design pattern is a behavioral pattern that aims to reduce the complexity and dependencies \nbetween tightly coupled objects communicating directly with each other. By introducing a mediator object, \nthis pattern encapsulates how a set of objects interact, promoting loose coupling by preventing objects \nfrom referring to each other explicitly. The mediator enables objects to communicate indirectly through \nit, centralizing the control of interactions.\n"},{"variant":"subtitle1","content":"Concept\n"},{"variant":"body1","content":"At its core, the Mediator pattern facilitates the principle of least knowledge, where an object should only \nknow as little as possible about how other objects operate, thereby reducing system complexity. This pattern \nis particularly beneficial in scenarios where multiple components need to interact in a well-defined but \ncomplex manner, as it centralizes communication logic that might otherwise be distributed among many objects.\n"},{"variant":"subtitle1","content":"Structure\n"},{"variant":"body1","content":"<ul>\n<li>Mediator: Defines the interface for communication between Colleague objects.</li>\n<li>ConcreteMediator: Implements the Mediator interface and coordinates communication between Colleague \n  objects. It knows and maintains its colleagues.</li>\n<li>Colleague: Defines an interface for communicating with other Colleagues through the Mediator. Each \n  Colleague knows its Mediator object.</li>\n</ul>\n"},{"variant":"subtitle1","content":"Example\n"},{"variant":"body1","content":"Consider a scenario in an air traffic control system where multiple flights need to coordinate takeoffs and \nlandings with the control tower. The control tower (mediator) manages which flights can take off or land at \nany given time, preventing direct communication between flights (colleagues).\n"},{"variant":"code","content":"class ControlTower {\n  constructor() {\n    this.flights = [];\n  }\n\n  registerFlight(flight) {\n    this.flights.push(flight);\n    flight.setControlTower(this);\n  }\n\n  givePermissionToLand(flight) {\n    for (let f of this.flights) {\n      if (f !== flight && f.isInAirspace()) {\n        console.log(`Flight ${flight.id} waiting for clearance.`);\n        return false;\n      }\n    }\n    console.log(`Flight ${flight.id} cleared to land.`);\n    return true;\n  }\n}\n\nclass Flight {\n  constructor(id) {\n    this.id = id;\n    this.controlTower = null;\n  }\n\n  setControlTower(controlTower) {\n    this.controlTower = controlTower;\n  }\n\n  isInAirspace() {\n    // Implementation would determine if the flight is currently in the airspace and seeking to land.\n    return true; // Simplified for example\n  }\n\n  requestLanding() {\n    return this.controlTower.givePermissionToLand(this);\n  }\n}\n\n// Usage\nconst controlTower = new ControlTower();\nconst flight1 = new Flight(1);\nconst flight2 = new Flight(2);\n\ncontrolTower.registerFlight(flight1);\ncontrolTower.registerFlight(flight2);\n\nflight1.requestLanding();\nflight2.requestLanding();\n"},{"variant":"body1","content":"In this simplified example, ControlTower acts as the ConcreteMediator, managing interactions between Flight \ninstances (Colleagues). When a flight wants to land, it requests permission from the control tower, which \nchecks the status of other flights in the airspace before granting landing permission. This setup prevents \nflights from needing to communicate directly with each other, encapsulating the coordination logic within \nthe mediator.\n"},{"variant":"body1","content":"The Mediator pattern streamlines complex communication and interactions within a system, making it easier \nto maintain and extend. It shines in systems where components can perform their duties more efficiently by \ndelegating communication responsibilities to a central authority.\n"}],"Iterator":[{"variant":"body1","content":"The Iterator design pattern is a behavioral pattern that provides a way to access the elements of an \naggregate object sequentially without exposing its underlying representation. This pattern is especially \nuseful for traversing collections of objects in a uniform manner, regardless of the specific types of \ncollections being used. By encapsulating the traversal logic within an iterator, collections can change \ntheir internal structure without affecting the clients that iterate over them.\n"},{"variant":"subtitle1","content":"Concept\n"},{"variant":"body1","content":"The core idea behind the Iterator pattern is to abstract the process of scanning through elements, making \nit possible to use the same logic to traverse different types of collections. This not only simplifies \nclient code but also enhances modularity and facilitates maintenance. The pattern is widely used in modern \nsoftware development, where handling collections of objects is a common task.\n"},{"variant":"subtitle1","content":"Structure\n"},{"variant":"body1","content":"<ul>\n  <li>Iterator: Defines an interface for accessing and traversing elements.</li>\n  <li>ConcreteIterator: Implements the iterator interface and keeps track of the current position in the \n    traversal of the aggregate.</li>\n  <li>Aggregate: Defines an interface for creating an Iterator object.</li>\n  <li>ConcreteAggregate: Implements the Aggregate interface and returns an instance of the corresponding \n    ConcreteIterator.</li>\n</ul>\n"},{"variant":"subtitle1","content":"Example\n"},{"variant":"body1","content":"Let's consider a simple example where the Iterator pattern is used to iterate over a collection of books \nin a library. This example demonstrates how the pattern enables clients to iterate over a collection without \nknowing the internal structure of the collection.\n"},{"variant":"code","content":"class Book {\n  constructor(title) {\n    this.title = title;\n  }\n}\n\nclass BookShelf {\n  constructor() {\n    this.books = [];\n  }\n\n  addBook(book) {\n    this.books.push(book);\n  }\n\n  createIterator() {\n    return new BookShelfIterator(this);\n  }\n}\n\nclass BookShelfIterator {\n  constructor(bookShelf) {\n    this.bookShelf = bookShelf;\n    this.index = 0;\n  }\n\n  hasNext() {\n    return this.index < this.bookShelf.books.length;\n  }\n\n  next() {\n    return this.bookShelf.books[this.index++];\n  }\n}\n\n// Usage\nconst bookShelf = new BookShelf();\nbookShelf.addBook(new Book(\"Design Patterns: Elements of Reusable Object-Oriented Software\"));\nbookShelf.addBook(new Book(\"Refactoring: Improving the Design of Existing Code\"));\n\nconst iterator = bookShelf.createIterator();\nwhile (iterator.hasNext()) {\n  const book = iterator.next();\n  console.log(book.title);\n}\n"},{"variant":"body1","content":"In this example, BookShelf acts as a concrete aggregate, and BookShelfIterator is the concrete iterator that \nallows traversal over the books in the bookshelf. Clients, such as the usage example, interact with the \ncollection through the iterator interface, enabling seamless iteration over the collection without direct \naccess to its internal structure.\n"},{"variant":"body1","content":"The Iterator pattern facilitates the implementation of efficient and encapsulated traversal mechanisms, making \nit easier to work with complex data structures. It's a cornerstone of object-oriented design and is deeply \nintegrated into many programming languages and frameworks.\n"}],"Chain Of Responsibility":[{"variant":"body1","content":"The Chain of Responsibility pattern is a fundamental behavioral design pattern that allows an object\nto pass the request along a chain of handlers. Upon receiving a request, each handler decides either\nto process the request or to pass it to the next handler in the chain. This pattern is particularly\nuseful for implementing a system where multiple objects may handle a request without any of them\nnecessarily being the receiver for the request.\n"},{"variant":"subtitle1","content":"Concept\n"},{"variant":"body1","content":"At the heart of the Chain of Responsibility pattern is the idea that multiple objects can have the \nopportunity to handle a request, thereby decoupling senders and receivers. A request from a client \nis sent to a chain of objects without explicitly specifying the receiver. This allows for a high \nlevel of flexibility in distributing responsibilities among objects, as the request can be handled \nat any point in the chain.\n"},{"variant":"subtitle1","content":"Structure\n"},{"variant":"body1","content":"<ul>\n  <li>\n    Handler: Defines an interface for handling requests and optionally implements the successor link. \n    The handler has a reference to the next handler in the chain and can choose to pass the request \n    along the chain.\n  </li>\n  <li>\n    ConcreteHandler: Handles the request it is responsible for. If it can handle the request, it does \n    so; otherwise, it forwards the request to its successor in the chain.\n  </li>\n</ul>\n"},{"variant":"subtitle1","content":"Example\n"},{"variant":"body1","content":"In the context of a web application, the Chain of Responsibility pattern can be used to handle HTTP \nrequests. Different handlers can process various aspects of the request, such as authentication, logging, \nor data validation, before the request reaches the core processing logic.\nExample\n"},{"variant":"code","content":"class Handler {\n  constructor(successor = null) {\n    this.successor = successor;\n  }\n\n  handle(request) {\n    if (this.successor) {\n      this.successor.handle(request);\n    }\n  }\n}\n\nclass AuthenticationHandler extends Handler {\n  handle(request) {\n    console.log('Handling authentication');\n    if (request.isAuthenticated) {\n      super.handle(request);\n    } else {\n      console.log('Authentication failed');\n    }\n  }\n}\n\nclass LoggingHandler extends Handler {\n  handle(request) {\n    console.log('Logging request');\n    super.handle(request);\n  }\n}\n\nclass CoreProcessingHandler extends Handler {\n  handle(request) {\n    console.log('Processing request core');\n    // Core request processing logic here\n  }\n}\n\n// Usage\nconst coreProcessingHandler = new CoreProcessingHandler();\nconst loggingHandler = new LoggingHandler(coreProcessingHandler);\nconst authenticationHandler = new AuthenticationHandler(loggingHandler);\n\nconst request = { isAuthenticated: true };\nauthenticationHandler.handle(request);\n"}],"Observer":[{"variant":"body1","content":"The Observer pattern is one of the most widely used behavioural patterns. It defines a one-to-many\ndependency between objects, allowing an object to notify other objects about changes in its state.\n"},{"variant":"subtitle1","content":"Concept"},{"variant":"body1","content":"In this pattern, an object, known as the 'subject,' maintains a list of its dependents, 'observers,' and\nnotifies them automatically of any state changes. This is particularly useful in scenarios where a\nchange in one object requires changing others, and you don't know how many objects need to be changed.\n"},{"variant":"subtitle1","content":"Structure"},{"variant":"body1","content":"Subject: Holds references to observers and provides an interface for attaching and detaching them.\nObserver: Defines an updating interface for objects that need to be notified of a subject's changes.\n"},{"variant":"subtitle1","content":"Example"},{"variant":"body1","content":"In JavaScript, you can implement the Observer pattern as follows:\n"},{"variant":"code","content":"class Subject {\n  constructor() {\n      this.observers = [];\n  }\n\n  subscribe(observer) {\n      this.observers.push(observer);\n  }\n\n  unsubscribe(observer) {\n      this.observers = this.observers.filter(obs => obs !== observer);\n  }\n\n  notify(data) {\n      this.observers.forEach(observer => observer.update(data));\n  }\n}\n\nclass Observer {\n    update(data) {\n        console.log(`Observer received data: ${data}`);\n    }\n}\n\n// Usage\nconst subject = new Subject();\nconst observer1 = new Observer();\nconst observer2 = new Observer();\n\nsubject.subscribe(observer1);\nsubject.subscribe(observer2);\nsubject.notify(\"Hello Observers!\");\n"}],"Strategy":[{"variant":"body1","content":"The Strategy pattern enables selecting an algorithm's behavior at runtime. Instead of implementing a\nsingle algorithm directly, code receives run-time instructions specifying which of a family of\nalgorithms to use.\n"},{"variant":"subtitle1","content":"Concept"},{"variant":"body1","content":"This pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable.\nStrategy lets the algorithm vary independently from clients that use it. It's useful when there are\nmultiple ways to achieve a task, and the best approach depends on the context.\n"},{"variant":"subtitle1","content":"Structure"},{"variant":"body1","content":"Strategy: An interface common to all supported algorithms. ConcreteStrategy: Implements different\nalgorithms following the Strategy interface.\nContext: Maintains a reference to a Strategy object and\ncommunicates with this object to call the algorithm defined by the Strategy.\n"},{"variant":"subtitle1","content":"Example"},{"variant":"body1","content":"Using pseudo-code for the Strategy pattern:\n"},{"variant":"code","content":"interface Strategy {\n    execute(data);\n}\n\nclass ConcreteStrategyA implements Strategy {\n    execute(data) {\n        // Implementation of algorithm A\n    }\n}\n\nclass ConcreteStrategyB implements Strategy {\n    execute(data) {\n        // Implementation of algorithm B\n    }\n}\n\nclass Context {\n    constructor(strategy) {\n        this.strategy = strategy;\n    }\n\n    executeStrategy(data) {\n        this.strategy.execute(data);\n    }\n}\n\n// Usage\nconst strategyA = new ConcreteStrategyA();\nconst context = new Context(strategyA);\ncontext.executeStrategy(\"data\");`}\n"},{"variant":"body1","content":"This pattern offers flexibility in choosing which algorithm to run at runtime and isolates the algorithm\nimplementation from the code that uses it.\n"}],"Command":[{"variant":"body1","content":"The Command pattern encapsulates a request as an object, thereby allowing users to parameterize clients\nwith queues, requests, and operations. It also allows for the support of undoable operations.\n"},{"variant":"subtitle1","content":"Concept"},{"variant":"body1","content":"The key idea here is to provide a means to separate the responsibilities of issuing commands from\nanything executing commands, decoupling sender and receiver. Commands are first-class objects with their\nown lifetime and can be composed and passed around like any other objects.\n"},{"variant":"subtitle1","content":"Structure"},{"variant":"body1","content":"Command: Declares an interface for executing an operation. ConcreteCommand: Defines a binding between a\nReceiver object and an action. Client: Creates a ConcreteCommand object and sets its receiver. Invoker:\nAsks the command to carry out the request. Receiver: Knows how to perform the operations associated with\ncarrying out a request.\n"},{"variant":"subtitle1","content":"Example"},{"variant":"body1","content":"Here's a simple implementation in pseudo-code:\n"},{"variant":"code","content":"interface Command {\n    execute();\n}\n\nclass Light {\n    turnOn() { /* ... */ }\n    turnOff() { /* ... */ }\n}\n\nclass TurnOnCommand implements Command {\n    constructor(light) {\n        this.light = light;\n    }\n    execute() {\n        this.light.turnOn();\n    }\n}\n\nclass TurnOffCommand implements Command {\n    constructor(light) {\n        this.light = light;\n    }\n    execute() {\n        this.light.turnOff();\n    }\n}\n\nclass RemoteControl {\n    submit(command) {\n        command.execute();\n    }\n}\n\n// Usage\nconst light = new Light();\nconst turnOnCommand = new TurnOnCommand(light);\nconst turnOffCommand = new TurnOffCommand(light);\n\nconst remote = new RemoteControl();\nremote.submit(turnOnCommand); // Turns the light on\nremote.submit(turnOffCommand); // Turns the light off\n"}],"State":[{"variant":"body1","content":"The State pattern allows an object to alter its behavior when its internal state changes. The object\nwill appear to change its class.\n"},{"variant":"subtitle1","content":"Concept"},{"variant":"body1","content":"It's particularly useful in scenarios where an object's behavior is influenced by its state, and it must\nchange its behavior at runtime depending on that state. This pattern puts each branch of the conditional\nin a separate class.\n"},{"variant":"subtitle1","content":"Structure"},{"variant":"body1","content":"State: An interface defining an action that is associated with a state of the Context.\nConcreteStates: Classes that implement the State interface and define behavior for a state of the Context.\nContext: Maintains an instance of a ConcreteState subclass that defines the current state.\n"},{"variant":"subtitle1","content":"Example"},{"variant":"body1","content":"An implementation in JavaScript could look like this:\n"},{"variant":"code","content":"class State {\n    handle(context) {\n        // Handle request here\n    }\n}\n\nclass ConcreteStateA extends State {\n    handle(context) {\n        console.log('Handling in the state A');\n        context.state = new ConcreteStateB();\n    }\n}\n\nclass ConcreteStateB extends State {\n    handle(context) {\n        console.log('Handling in the state B');\n        context.state = new ConcreteStateA();\n    }\n}\n\nclass Context {\n    constructor() {\n        this.state = new ConcreteStateA();\n    }\n\n    request() {\n        this.state.handle(this);\n    }\n}\n\n// Usage\nconst context = new Context();\ncontext.request(); // Handling in the state A\ncontext.request(); // Handling in the state B\n"}]}}