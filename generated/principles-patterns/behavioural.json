{"title":"<i>Behavioural</i> Design Patterns <br /> in Software Development","before":[{"variant":"subtitle1","content":"Behavioural design patterns are fundamental to the structure and organization of software systems. They focus\non how objects interact and communicate with each other, leading to efficient problem-solving and an\nenhanced understanding of the system's dynamics. Below, we explore several key behavioural design patterns,\nproviding insights into their purposes, structures, and applications. To illustrate these patterns, I'll use\npseudo-code or JavaScript where appropriate.\n"}],"accordion":{"Observer":[{"variant":"subtitle1","content":"The Observer pattern is one of the most widely used behavioural patterns. It defines a one-to-many\ndependency between objects, allowing an object to notify other objects about changes in its state.\n"},{"variant":"h6","content":"Concept"},{"variant":"subtitle1","content":"In this pattern, an object, known as the 'subject,' maintains a list of its dependents, 'observers,' and\nnotifies them automatically of any state changes. This is particularly useful in scenarios where a\nchange in one object requires changing others, and you don't know how many objects need to be changed.\n"},{"variant":"h6","content":"Structure"},{"variant":"subtitle1","content":"Subject: Holds references to observers and provides an interface for attaching and detaching them.\nObserver: Defines an updating interface for objects that need to be notified of a subject's changes.\n"},{"variant":"h6","content":"Example"},{"variant":"subtitle1","content":"In JavaScript, you can implement the Observer pattern as follows:\n"},{"variant":"code","content":"class Subject {\n  constructor() {\n      this.observers = [];\n  }\n\n  subscribe(observer) {\n      this.observers.push(observer);\n  }\n\n  unsubscribe(observer) {\n      this.observers = this.observers.filter(obs => obs !== observer);\n  }\n\n  notify(data) {\n      this.observers.forEach(observer => observer.update(data));\n  }\n}\n\nclass Observer {\n    update(data) {\n        console.log(`Observer received data: ${data}`);\n    }\n}\n\n// Usage\nconst subject = new Subject();\nconst observer1 = new Observer();\nconst observer2 = new Observer();\n\nsubject.subscribe(observer1);\nsubject.subscribe(observer2);\nsubject.notify(\"Hello Observers!\");\n"}],"Strategy":[{"variant":"subtitle1","content":"The Strategy pattern enables selecting an algorithm's behavior at runtime. Instead of implementing a\nsingle algorithm directly, code receives run-time instructions specifying which of a family of\nalgorithms to use.\n"},{"variant":"h6","content":"Concept"},{"variant":"subtitle1","content":"This pattern defines a family of algorithms, encapsulates each one, and makes them interchangeable.\nStrategy lets the algorithm vary independently from clients that use it. It's useful when there are\nmultiple ways to achieve a task, and the best approach depends on the context.\n"},{"variant":"h6","content":"Structure"},{"variant":"subtitle1","content":"Strategy: An interface common to all supported algorithms. ConcreteStrategy: Implements different\nalgorithms following the Strategy interface.\nContext: Maintains a reference to a Strategy object and\ncommunicates with this object to call the algorithm defined by the Strategy.\n"},{"variant":"h6","content":"Example"},{"variant":"subtitle1","content":"Using pseudo-code for the Strategy pattern:\n"},{"variant":"code","content":"interface Strategy {\n    execute(data);\n}\n\nclass ConcreteStrategyA implements Strategy {\n    execute(data) {\n        // Implementation of algorithm A\n    }\n}\n\nclass ConcreteStrategyB implements Strategy {\n    execute(data) {\n        // Implementation of algorithm B\n    }\n}\n\nclass Context {\n    constructor(strategy) {\n        this.strategy = strategy;\n    }\n\n    executeStrategy(data) {\n        this.strategy.execute(data);\n    }\n}\n\n// Usage\nconst strategyA = new ConcreteStrategyA();\nconst context = new Context(strategyA);\ncontext.executeStrategy(\"data\");`}\n"},{"variant":"subtitle1","content":"This pattern offers flexibility in choosing which algorithm to run at runtime and isolates the algorithm\nimplementation from the code that uses it.\n"}],"Command":[{"variant":"subtitle1","content":"The Command pattern encapsulates a request as an object, thereby allowing users to parameterize clients\nwith queues, requests, and operations. It also allows for the support of undoable operations.\n"},{"variant":"h6","content":"Concept"},{"variant":"subtitle1","content":"The key idea here is to provide a means to separate the responsibilities of issuing commands from\nanything executing commands, decoupling sender and receiver. Commands are first-class objects with their\nown lifetime and can be composed and passed around like any other objects.\n"},{"variant":"h6","content":"Structure"},{"variant":"subtitle1","content":"Command: Declares an interface for executing an operation. ConcreteCommand: Defines a binding between a\nReceiver object and an action. Client: Creates a ConcreteCommand object and sets its receiver. Invoker:\nAsks the command to carry out the request. Receiver: Knows how to perform the operations associated with\ncarrying out a request.\n"},{"variant":"h6","content":"Example"},{"variant":"subtitle1","content":"Here's a simple implementation in pseudo-code:\n"},{"variant":"code","content":"interface Command {\n    execute();\n}\n\nclass Light {\n    turnOn() { /* ... */ }\n    turnOff() { /* ... */ }\n}\n\nclass TurnOnCommand implements Command {\n    constructor(light) {\n        this.light = light;\n    }\n    execute() {\n        this.light.turnOn();\n    }\n}\n\nclass TurnOffCommand implements Command {\n    constructor(light) {\n        this.light = light;\n    }\n    execute() {\n        this.light.turnOff();\n    }\n}\n\nclass RemoteControl {\n    submit(command) {\n        command.execute();\n    }\n}\n\n// Usage\nconst light = new Light();\nconst turnOnCommand = new TurnOnCommand(light);\nconst turnOffCommand = new TurnOffCommand(light);\n\nconst remote = new RemoteControl();\nremote.submit(turnOnCommand); // Turns the light on\nremote.submit(turnOffCommand); // Turns the light off\n"}],"State":[{"variant":"subtitle1","content":"The State pattern allows an object to alter its behavior when its internal state changes. The object\nwill appear to change its class.\n"},{"variant":"h6","content":"Concept"},{"variant":"subtitle1","content":"It's particularly useful in scenarios where an object's behavior is influenced by its state, and it must\nchange its behavior at runtime depending on that state. This pattern puts each branch of the conditional\nin a separate class.\n"},{"variant":"h6","content":"Structure"},{"variant":"subtitle1","content":"State: An interface defining an action that is associated with a state of the Context.\nConcreteStates: Classes that implement the State interface and define behavior for a state of the Context.\nContext: Maintains an instance of a ConcreteState subclass that defines the current state.\n"},{"variant":"h6","content":"Example"},{"variant":"subtitle1","content":"An implementation in JavaScript could look like this:\n"},{"variant":"code","content":"class State {\n    handle(context) {\n        // Handle request here\n    }\n}\n\nclass ConcreteStateA extends State {\n    handle(context) {\n        console.log('Handling in the state A');\n        context.state = new ConcreteStateB();\n    }\n}\n\nclass ConcreteStateB extends State {\n    handle(context) {\n        console.log('Handling in the state B');\n        context.state = new ConcreteStateA();\n    }\n}\n\nclass Context {\n    constructor() {\n        this.state = new ConcreteStateA();\n    }\n\n    request() {\n        this.state.handle(this);\n    }\n}\n\n// Usage\nconst context = new Context();\ncontext.request(); // Handling in the state A\ncontext.request(); // Handling in the state B\n"}]}}