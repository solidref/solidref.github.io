{"title":"<i>Creational</i> Design Patterns <br /> in Software Development","before":[{"variant":"subtitle1","content":"Creational design patterns abstract the instantiation process. They help make a system independent of how its objects are created, composed, and represented. A class creational pattern uses inheritance to vary the class that’s instantiated, whereas an object creational pattern will delegate instantiation to another object. Below, we explore several key creational design patterns, providing insights into their purposes, structures, and applications, using JavaScript for illustrations.\n"}],"accordion":{"Factory Method":[{"variant":"subtitle1","content":"The Factory Method Pattern defines an interface for creating an object, but lets subclasses alter the type of objects that will be created.\n"},{"variant":"h6","content":"Concept"},{"variant":"subtitle1","content":"This pattern involves a single class which is responsible to create an object while making sure that only one object gets created. It provides a way to delegate the instantiation logic to child classes.\n"},{"variant":"h6","content":"Structure"},{"variant":"subtitle1","content":"Creator: A class that contains the implementations for all of the methods to manipulate products, including the factory method.\nConcreteCreator: Overrides the factory method to return an instance of a ConcreteProduct.\n"},{"variant":"h6","content":"Example"},{"variant":"code","content":"class Creator {\n    factoryMethod() {\n        return new ConcreteProduct();\n    }\n    // Other methods\n}\n\nclass ConcreteCreator extends Creator {\n    factoryMethod() {\n        return new ConcreteProduct();\n    }\n}\n\nclass ConcreteProduct {\n    // Product implementation\n}\n\n// Usage\nconst creator = new ConcreteCreator();\nconst product = creator.factoryMethod();\n"}],"Abstract Factory":[{"variant":"subtitle1","content":"The Abstract Factory Pattern provides an interface for creating families of related or dependent objects without specifying their concrete classes.\n"},{"variant":"h6","content":"Concept"},{"variant":"subtitle1","content":"This pattern involves multiple Factory Methods, one for each type of object to be created and an abstract class to define the standard interface.\n"},{"variant":"h6","content":"Structure"},{"variant":"subtitle1","content":"AbstractFactory: Declares an interface for operations that create abstract product objects.\nConcreteFactory: Implements the operations to create concrete product objects.\nAbstractProduct: Declares an interface for a type of product object.\nConcreteProduct: Defines a product object to be created by the corresponding concrete factory.\n"},{"variant":"h6","content":"Example"},{"variant":"code","content":"class AbstractFactory {\n    createProductA() {}\n    createProductB() {}\n}\n\nclass ConcreteFactory1 extends AbstractFactory {\n    createProductA() {\n        return new ProductA1();\n    }\n    createProductB() {\n        return new ProductB1();\n    }\n}\n\nclass ConcreteFactory2 extends AbstractFactory {\n    createProductA() {\n        return new ProductA2();\n    }\n    createProductB() {\n        return new ProductB2();\n    }\n}\n\nclass ProductA1 {}\nclass ProductB1 {}\nclass ProductA2 {}\nclass ProductB2 {}\n\n// Usage\nconst factory1 = new ConcreteFactory1();\nconst productA1 = factory1.createProductA();\nconst productB1 = factory1.createProductB();\n"}],"Builder":[{"variant":"subtitle1","content":"The Builder Pattern separates the construction of a complex object from its representation, so that the same construction process can create different representations.\n"},{"variant":"h6","content":"Concept"},{"variant":"subtitle1","content":"This pattern allows you to produce different types and representations of an object using the same construction code.\n"},{"variant":"h6","content":"Structure"},{"variant":"subtitle1","content":"Builder: Interface that defines all the steps needed to construct a product.\nConcreteBuilder: Implements the Builder interface and provides an interface for retrieving the product.\nDirector: Constructs an object using the Builder interface.\nProduct: The final object that is being built.\n"},{"variant":"h6","content":"Example"},{"variant":"code","content":"class Builder {\n    // Builder steps\n}\n\nclass ConcreteBuilder extends Builder {\n    constructor() {\n        super();\n        this.product = new Product();\n    }\n    buildPartA() {\n        // build part A of the product\n    }\n    buildPartB() {\n        // build part B of the product\n    }\n    getResult() {\n        return this.product;\n    }\n}\n\nclass Director {\n    construct(builder) {\n        builder.buildPartA();\n        builder.buildPartB();\n        return builder.getResult();\n    }\n}\n\nclass Product {\n    // The final object\n}\n\n// Usage\nconst director = new Director();\nconst builder = new ConcreteBuilder();\nconst product = director.construct(builder);\n"}],"Prototype":[{"variant":"subtitle1","content":"The Prototype Pattern creates new objects, but instead of creating non-initialized objects, it returns objects that are initialized with values it copied from a prototype – or sample – object.\n"},{"variant":"h6","content":"Concept"},{"variant":"subtitle1","content":"The Prototype pattern is used when creating an instance of a class is more expensive or complex than copying an existing instance.\n"},{"variant":"h6","content":"Structure"},{"variant":"subtitle1","content":"Prototype: Declares an interface for cloning itself.\nConcretePrototype: Implements an operation for cloning itself.\nClient: Creates a new object by asking a prototype to clone itself.\n"},{"variant":"h6","content":"Example"},{"variant":"code","content":"class Prototype {\n    clone() {\n        // clone the prototype\n    }\n}\n\nclass ConcretePrototype extends Prototype {\n    constructor() {\n        super();\n        // initialize with default values\n    }\n    clone() {\n        return Object.assign({}, this);\n    }\n}\n\n// Usage\nconst prototype = new ConcretePrototype();\nconst clonedObject = prototype.clone();\n"}],"Singleton":[{"variant":"subtitle1","content":"The Singleton Pattern ensures a class has only one instance and provides a global point of access to it.\n"},{"variant":"h6","content":"Concept"},{"variant":"subtitle1","content":"Singleton pattern restricts a class from instantiating multiple objects. This pattern ensures a class has only one instance and provides a global point of access to it.\n"},{"variant":"h6","content":"Structure"},{"variant":"subtitle1","content":"Instance: A private static variable that holds the one and only instance of the class.\ngetInstance(): A public static method that returns the single instance of the class.\n"},{"variant":"h6","content":"Example"},{"variant":"code","content":"class Singleton {\n    constructor() {\n        if (!Singleton.instance) {\n            Singleton.instance = this;\n        }\n        return Singleton.instance;\n    }\n    // other methods...\n}\n\n// Usage\nconst instance1 = new Singleton();\nconst instance2 = new Singleton();\nconsole.log(instance1 === instance2);  // true\n"}]}}