{"title":"<i>Structural</i> Design Patterns <br /> in Software Development","before":[{"variant":"subtitle1","content":"Structural design patterns are concerned with how classes and objects are composed to form larger structures.\nThey help ensure that when one part of a system changes, the entire system does not need to change.\nBelow, we explore several key structural design patterns, providing insights into their purposes, structures,\nand applications, using JavaScript for illustrations.\n"}],"accordion":{"Adapter":[{"variant":"subtitle1","content":"The Adapter Pattern allows objects with incompatible interfaces to collaborate.\n"},{"variant":"h6","content":"Concept"},{"variant":"subtitle1","content":"This pattern involves a single class which is responsible to join functionalities of independent or incompatible interfaces.\n"},{"variant":"h6","content":"Structure"},{"variant":"subtitle1","content":"Target: Defines the domain-specific interface that Client uses.\nAdapter: Adapts the interface of Adaptee to the Target interface.\nAdaptee: Defines an existing interface that needs adapting.\n"},{"variant":"h6","content":"Example"},{"variant":"code","content":"class Target {\n    request() {\n        return 'Target: The default target\\'s behavior.';\n    }\n}\n\nclass Adaptee {\n    specificRequest() {\n        return '.eetpadA eht fo roivaheb laicepS';\n    }\n}\n\nclass Adapter extends Target {\n    constructor(adaptee) {\n        super();\n        this.adaptee = adaptee;\n    }\n\n    request() {\n        const result = this.adaptee.specificRequest().split('').reverse().join('');\n        return `Adapter: (TRANSLATED) ${result}`;\n    }\n}\n\n// Usage\nconst target = new Target();\nconst adaptee = new Adaptee();\nconsole.log(target.request());\n\nconst adapter = new Adapter(adaptee);\nconsole.log(adapter.request());\n"}],"Bridge":[{"variant":"subtitle1","content":"The Bridge Pattern decouples an abstraction from its implementation so that the two can vary independently.\n"},{"variant":"h6","content":"Concept"},{"variant":"subtitle1","content":"This pattern involves an interface which acts as a bridge between the abstraction class and implementer classes and also makes the functionality of implementer class independent from the abstraction class.\n"},{"variant":"h6","content":"Structure"},{"variant":"subtitle1","content":"Abstraction: Defines the abstraction's interface.\nRefinedAbstraction: Extends the interface defined by Abstraction.\nImplementor: Defines the interface for implementation classes.\nConcreteImplementor: Implements the Implementor interface and defines its concrete implementation.\n"},{"variant":"h6","content":"Example"},{"variant":"code","content":"class Implementor {\n    operationImp() {}\n}\n\nclass ConcreteImplementorA extends Implementor {\n    operationImp() {\n        console.log('ConcreteImplementorA Operation');\n    }\n}\n\nclass ConcreteImplementorB extends Implementor {\n    operationImp() {\n        console.log('ConcreteImplementorB Operation');\n    }\n}\n\nclass Abstraction {\n    constructor(implementor) {\n        this.implementor = implementor;\n    }\n    operation() {\n        this.implementor.operationImp();\n    }\n}\n\n// Usage\nconst implementorA = new ConcreteImplementorA();\nconst abstractionA = new Abstraction(implementorA);\nabstractionA.operation();\n\nconst implementorB = new ConcreteImplementorB();\nconst abstractionB = new Abstraction(implementorB);\nabstractionB.operation();\n"}],"Composite":[{"variant":"subtitle1","content":"The Composite Pattern composes objects into tree structures to represent part-whole hierarchies. Composite lets clients treat individual objects and compositions of objects uniformly.\n"},{"variant":"h6","content":"Concept"},{"variant":"subtitle1","content":"This pattern creates a tree structure of group of objects. This pattern creates a class that contains group of its own objects and also provides ways to modify them.\n"},{"variant":"h6","content":"Structure"},{"variant":"subtitle1","content":"Component: Declares the interface for objects in the composition and for accessing and managing its child components.\nLeaf: Represents leaf objects in the composition. A leaf has no children.\nComposite: Defines behavior for components having children and stores child components.\n"},{"variant":"h6","content":"Example"},{"variant":"code","content":"class Component {\n    constructor(name) {\n        this.name = name;\n    }\n    // methods like add, remove, getChild\n}\n\nclass Leaf extends Component {\n    constructor(name) {\n        super(name);\n    }\n    operation() {\n        console.log(`Leaf ${this.name} performs operation`);\n    }\n}\n\nclass Composite extends Component {\n    constructor(name) {\n        super(name);\n        this.children = [];\n    }\n    add(component) {\n        this.children.push(component);\n    }\n    operation() {\n        console.log(`Composite ${this.name}`);\n        for (const child of this.children) {\n            child.operation();\n        }\n    }\n}\n\n// Usage\nconst leaf1 = new Leaf('Leaf 1');\nconst leaf2 = new Leaf('Leaf 2');\nconst composite1 = new Composite('Composite 1');\ncomposite1.add(leaf1);\ncomposite1.add(leaf2);\ncomposite1.operation();\n"}],"Decorator":[{"variant":"subtitle1","content":"The Decorator Pattern attaches additional responsibilities to an object dynamically. Decorators provide a flexible alternative to subclassing for extending functionality.\n"},{"variant":"h6","content":"Concept"},{"variant":"subtitle1","content":"This pattern creates a decorator class which wraps the original class and provides additional functionality keeping class methods signature intact.\n"},{"variant":"h6","content":"Structure"},{"variant":"subtitle1","content":"Component: Defines the interface for objects that can have responsibilities added to them dynamically.\nConcreteComponent: Defines an object to which additional responsibilities can be attached.\nDecorator: Maintains a reference to a Component object and defines an interface that conforms to Component's interface.\nConcreteDecorator: Adds responsibilities to the component.\n"},{"variant":"h6","content":"Example"},{"variant":"code","content":"class Component {\n    operation() {}\n}\n\nclass ConcreteComponent extends Component {\n    operation() {\n        console.log('ConcreteComponent operation');\n    }\n}\n\nclass Decorator extends Component {\n    constructor(component) {\n        super();\n        this.component = component;\n    }\n\n    operation() {\n        this.component.operation();\n    }\n}\n\nclass ConcreteDecoratorA extends Decorator {\n    operation() {\n        super.operation();\n        console.log('ConcreteDecoratorA extra operation');\n    }\n}\n\n// Usage\nconst component = new ConcreteComponent();\nconst decoratorA = new ConcreteDecoratorA(component);\ndecoratorA.operation();\n"}],"Facade":[{"variant":"subtitle1","content":"The Facade Pattern provides a unified interface to a set of interfaces in a subsystem. Facade defines a higher-level interface that makes the subsystem easier to use.\n"},{"variant":"h6","content":"Concept"},{"variant":"subtitle1","content":"This pattern hides the complexities of the system and provides an interface to the client using which the client can access the system.\n"},{"variant":"h6","content":"Structure"},{"variant":"subtitle1","content":"Facade: Knows which subsystem classes are responsible for a request. Delegates client requests to appropriate subsystem objects.\nSubsystem classes: Implement subsystem functionality and handle work assigned by the Facade object. They don't know about the facade and keep no reference to it.\n"},{"variant":"h6","content":"Example"},{"variant":"code","content":"class Subsystem1 {\n    operation1() {\n        return 'Subsystem1: Ready!\\n';\n    }\n    operationN() {\n        return 'Subsystem1: Go!\\n';\n    }\n}\n\nclass Subsystem2 {\n    operation1() {\n        return 'Subsystem2: Get ready!\\n';\n    }\n    operationZ() {\n        return 'Subsystem2: Fire!';\n    }\n}\n\nclass Facade {\n    constructor(subsystem1, subsystem2) {\n        this.subsystem1 = subsystem1 || new Subsystem1();\n        this.subsystem2 = subsystem2 || new Subsystem2();\n    }\n\n    operation() {\n        let result = 'Facade initializes subsystems:\\n';\n        result += this.subsystem1.operation1();\n        result += this.subsystem2.operation1();\n        result += 'Facade orders subsystems to perform the action:\\n';\n        result += this.subsystem1.operationN();\n        result += this.subsystem2.operationZ();\n        return result;\n    }\n}\n\n// Usage\nconst subsystem1 = new Subsystem1();\nconst subsystem2 = new Subsystem2();\nconst facade = new Facade(subsystem1, subsystem2);\nconsole.log(facade.operation());\n"}],"Flyweight":[{"variant":"subtitle1","content":"The Flyweight Pattern uses sharing to support large numbers of fine-grained objects efficiently.\n"},{"variant":"h6","content":"Concept"},{"variant":"subtitle1","content":"This pattern is primarily used to reduce the number of objects created and to decrease memory footprint and increase performance. This type of design pattern comes under structural pattern as this pattern provides ways to decrease object count thus improving application required objects structure.\n"},{"variant":"h6","content":"Structure"},{"variant":"subtitle1","content":"Flyweight: Declares an interface through which flyweights can receive and act on extrinsic state.\nConcreteFlyweight: Implements the Flyweight interface and adds storage for intrinsic state. A ConcreteFlyweight object must be sharable.\nFlyweightFactory: Creates and manages flyweight objects.\n"},{"variant":"h6","content":"Example"},{"variant":"code","content":"class Flyweight {\n    operation(extrinsicState) {}\n}\n\nclass ConcreteFlyweight extends Flyweight {\n    constructor(intrinsicState) {\n        super();\n        this.intrinsicState = intrinsicState;\n    }\n    operation(extrinsicState) {\n        console.log(`ConcreteFlyweight: Intrinsic(${this.intrinsicState}) and Extrinsic(${extrinsicState})`);\n    }\n}\n\nclass FlyweightFactory {\n    constructor() {\n        this.flyweights = {};\n    }\n    getFlyweight(key) {\n        if (!(key in this.flyweights)) {\n            this.flyweights[key] = new ConcreteFlyweight(key);\n        }\n        return this.flyweights[key];\n    }\n}\n\n// Usage\nconst factory = new FlyweightFactory();\nconst flyweight = factory.getFlyweight('a');\nflyweight.operation('operation1');\n"}],"Proxy":[{"variant":"subtitle1","content":"The Proxy Pattern provides a surrogate or placeholder for another object to control access to it.\n"},{"variant":"h6","content":"Concept"},{"variant":"subtitle1","content":"This pattern involves a class which represents the functionality of another class. This type of design pattern comes under structural pattern.\nIn proxy pattern, we create object having original object to interface its functionality to outer world.\n"},{"variant":"h6","content":"Structure"},{"variant":"subtitle1","content":"Proxy: Maintains a reference that lets the proxy access the real subject. Proxy may refer to a Subject if the RealSubject and Subject interfaces are the same.\nSubject: Defines the common interface for RealSubject and Proxy so that a Proxy can be used anywhere a RealSubject is expected.\nRealSubject: Defines the real object that the proxy represents.\n"},{"variant":"h6","content":"Example"},{"variant":"code","content":"class Subject {\n    request() {}\n}\n\nclass RealSubject extends Subject {\n    request() {\n        console.log('RealSubject: Handling request.');\n    }\n}\n\nclass Proxy extends Subject {\n    constructor(realSubject) {\n        super();\n        this.realSubject = realSubject;\n    }\n\n    request() {\n        if (this.checkAccess()) {\n            this.realSubject.request();\n            this.logAccess();\n        }\n    }\n\n    checkAccess() {\n        // Some real checks should go here.\n        console.log('Proxy: Checking access prior to firing a real request.');\n        return true;\n    }\n\n    logAccess() {\n        console.log('Proxy: Logging the time of request.');\n    }\n}\n\n// Usage\nconst realSubject = new RealSubject();\nconst proxy = new Proxy(realSubject);\nproxy.request();\n"}]}}